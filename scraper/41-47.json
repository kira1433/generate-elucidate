[
  {
    "number": 1,
    "question": "Can you solve this real interview question? Minimum Number of Operations to Make Array Continuous - You are given an integer array nums. In one operation, you can replace any element in nums with any integer.\n\nnums is considered continuous if both of the following conditions are fulfilled:\n\n * All elements in nums are unique.\n * The difference between the maximum element and the minimum element in nums equals nums.length - 1.\n\nFor example, nums = [4, 2, 5, 3] is continuous, but nums = [1, 2, 3, 5, 6] is not continuous.\n\nReturn the minimum number of operations to make nums continuous.\n\n \n\nExample 1:\n\n\nInput: nums = [4,2,5,3]\nOutput: 0\nExplanation: nums is already continuous.\n\n\nExample 2:\n\n\nInput: nums = [1,2,3,5,6]\nOutput: 1\nExplanation: One possible solution is to change the last element to 4.\nThe resulting array is [1,2,3,5,4], which is continuous.\n\n\nExample 3:\n\n\nInput: nums = [1,10,100,1000]\nOutput: 3\nExplanation: One possible solution is to:\n- Change the second element to 2.\n- Change the third element to 3.\n- Change the fourth element to 4.\nThe resulting array is [1,2,3,4], which is continuous.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 109",
    "code": "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int n = nums.size();\n        int ans = n;\n        \n        // std::set automatically sorts\n        set<int> unique(nums.begin(), nums.end());\n        vector<int> newNums;\n        for (int num : unique) {\n            newNums.push_back(num);\n        }\n        \n        for (int i = 0; i < newNums.size(); i++) {\n            int left = newNums[i];\n            int right = left + n - 1;\n            int j = upper_bound(newNums.begin(), newNums.end(), right) - newNums.begin();\n            int count = j - i;\n            ans = min(ans, n - count);\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int minOperations(vector<int>& nums) {\n        int n = nums.size();\n        int ans = n;\n        \n        // std::set automatically sorts\n        set<int> unique(nums.begin(), nums.end());\n        vector<int> newNums;\n        for (int num : unique) {\n            newNums.push_back(num);\n        }\n        \n        int j = 0;\n        for (int i = 0; i < newNums.size(); i++) {\n            while (j < newNums.size() && newNums[j] < newNums[i] + n) {\n                j++;\n            }\n            \n            int count = j - i;\n            ans = min(ans, n - count);\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 2,
    "question": "Can you solve this real interview question? Accepted Candidates From the Interviews - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
    "code": "",
    "solution": [
      "import pandas as pd\n\ndef accepted_candidates(candidates: pd.DataFrame, rounds: pd.DataFrame) -> pd.DataFrame:\n    # Approach: Conditional Index, Groupby Sum, inner merge\n    # Filtering candidates who have at least two YoE\n    candidates = candidates[candidates['years_of_exp'] >= 2]\n\n    # .groupby('interview_id')['score'].sum(), filter for > 15\n    rounds = rounds.groupby('interview_id')['score'].sum().reset_index(name='total_score')\n    rounds = rounds[rounds['total_score'] > 15]\n\n    # Inner merge on `interview_id`, rounds onto candidates\n    result = candidates.merge(rounds, how='inner', on='interview_id')\n\n    # Return `candidate_id`\n    return result[['candidate_id']]\n    "
    ]
  },
  {
    "number": 3,
    "question": "Can you solve this real interview question? Second Minimum Time to Reach Destination - A city is represented as a bi-directional connected graph with n vertices where each vertex is labeled from 1 to n (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself. The time taken to traverse any edge is time minutes.\n\nEach vertex has a traffic signal which changes its color from green to red and vice versa every change minutes. All signals change at the same time. You can enter a vertex at any time, but can leave a vertex only when the signal is green. You cannot wait at a vertex if the signal is green.\n\nThe second minimum value is defined as the smallest value strictly larger than the minimum value.\n\n * For example the second minimum value of [2, 3, 4] is 3, and the second minimum value of [2, 2, 4] is 4.\n\nGiven n, edges, time, and change, return the second minimum time it will take to go from vertex 1 to vertex n.\n\nNotes:\n\n * You can go through any vertex any number of times, including 1 and n.\n * You can assume that when the journey starts, all signals have just turned green.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/09/29/e1.png]        [https://assets.leetcode.com/uploads/2021/09/29/e2.png]\n\n\nInput: n = 5, edges = [[1,2],[1,3],[1,4],[3,4],[4,5]], time = 3, change = 5\nOutput: 13\nExplanation:\nThe figure on the left shows the given graph.\nThe blue path in the figure on the right is the minimum time path.\nThe time taken is:\n- Start at 1, time elapsed=0\n- 1 -> 4: 3 minutes, time elapsed=3\n- 4 -> 5: 3 minutes, time elapsed=6\nHence the minimum time needed is 6 minutes.\n\nThe red path shows the path to get the second minimum time.\n- Start at 1, time elapsed=0\n- 1 -> 3: 3 minutes, time elapsed=3\n- 3 -> 4: 3 minutes, time elapsed=6\n- Wait at 4 for 4 minutes, time elapsed=10\n- 4 -> 5: 3 minutes, time elapsed=13\nHence the second minimum time is 13 minutes.      \n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/09/29/eg2.png]\n\n\nInput: n = 2, edges = [[1,2]], time = 3, change = 2\nOutput: 11\nExplanation:\nThe minimum time path is 1 -> 2 with time = 3 minutes.\nThe second minimum time path is 1 -> 2 -> 1 -> 2 with time = 11 minutes.\n\n \n\nConstraints:\n\n * 2 <= n <= 104\n * n - 1 <= edges.length <= min(2 * 104, n * (n - 1) / 2)\n * edges[i].length == 2\n * 1 <= ui, vi <= n\n * ui != vi\n * There are no duplicate edges.\n * Each vertex can be reached directly or indirectly from every other vertex.\n * 1 <= time, change <= 103",
    "code": "class Solution {\npublic:\n    int secondMinimum(int n, vector<vector<int>>& edges, int \ntime, int change) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\n        vector<vector<int>> adj(n + 1);\n        for (auto& edge: edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n\n        // dist1[i] stores the minimum time taken to reach node i from node 1. dist2[i] stores the\n        // second minimum time taken to reach node from node 1. freq[i] stores the number of times a\n        // node is popped out of the heap.\n        vector<int> dist1(n + 1, numeric_limits<int>::max()),\n            dist2(n + 1, numeric_limits<int>::max()), freq(n + 1);\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> min_heap;\n        min_heap.push({0, 1});\n        dist1[1] = 0;\n\n        while (!min_heap.empty()) {\n            auto [timeTaken, node] = min_heap.top();\n            min_heap.pop();\n\n            freq[node]++;\n            // If the node is being visited for the second time and is 'n', return the answer.\n            if (freq[node] == 2 && node == n) return timeTaken;\n            // If the current light is red, wait till the path turns green.\n            if ((timeTaken / change) % 2) {\n                timeTaken = change * (timeTaken / change + 1) + time;\n            } else {\n                timeTaken = timeTaken + time;\n            }\n\n            for (auto& neighbor: adj[node]) {\n                // Ignore nodes that have already popped out twice.\n                if (freq[neighbor] == 2) continue;\n                // Update dist1 if it's more than the current timeTaken and store its value in\n                // dist2 since that becomes the second minimum value now.\n                if (dist1[neighbor] > timeTaken) {\n                    dist2[neighbor] = dist1[neighbor];\n                    dist1[neighbor] = timeTaken;\n                    min_heap.push({timeTaken, neighbor});\n                } else if (dist2[neighbor] > timeTaken && dist1[neighbor] != timeTaken) {\n                    dist2[neighbor] = timeTaken;\n                    min_heap.push({timeTaken, neighbor});\n                }\n            }\n        }\n        return 0;\n    }\n};",
      "class Solution {\npublic:\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\n        vector<vector<int>> adj(n + 1);\n        // Build the adjacency list.\n        for (auto& edge : edges) {\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n\n        queue<pair<int, int>> q;\n        vector<int> dist1(n + 1, -1), dist2(n + 1, -1);\n        // Start with node 1, with its minimum distance.\n        q.push({1, 1});\n        dist1[1] = 0;\n\n        while (!q.empty()) {\n            auto [node, freq] = q.front();\n            q.pop();\n\n            int timeTaken = freq == 1 ? dist1[node] : dist2[node];\n            // If the timeTaken falls under the red bracket, wait till the path turns green.\n            if ((timeTaken / change) % 2) {\n                timeTaken = change * (timeTaken / change + 1) + time;\n            } else {\n                timeTaken = timeTaken + time;\n            }\n\n            for (auto& neighbor : adj[node]) {\n                if (dist1[neighbor] == -1) {\n                    dist1[neighbor] = timeTaken;\n                    q.push({neighbor, 1});\n                } else if (dist2[neighbor] == -1 && dist1[neighbor] != timeTaken) {\n                    if (neighbor == n) return timeTaken;\n                    dist2[neighbor] = timeTaken;\n                    q.push({neighbor, 2});\n                }\n            }\n        }\n        return 0;\n    }\n};"
    ]
  },
  {
    "number": 4,
    "question": "Can you solve this real interview question? Parallel Courses III - You are given an integer n, which indicates that there are n courses labeled from 1 to n. You are also given a 2D integer array relations where relations[j] = [prevCoursej, nextCoursej] denotes that course prevCoursej has to be completed before course nextCoursej (prerequisite relationship). Furthermore, you are given a 0-indexed integer array time where time[i] denotes how many months it takes to complete the (i+1)th course.\n\nYou must find the minimum number of months needed to complete all the courses following these rules:\n\n * You may start taking a course at any time if the prerequisites are met.\n * Any number of courses can be taken at the same time.\n\nReturn the minimum number of months needed to complete all the courses.\n\nNote: The test cases are generated such that it is possible to complete every course (i.e., the graph is a directed acyclic graph).\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/10/07/ex1.png]\n\n\nInput: n = 3, relations = [[1,3],[2,3]], time = [3,2,5]\nOutput: 8\nExplanation: The figure above represents the given graph and the time required to complete each course. \nWe start course 1 and course 2 simultaneously at month 0.\nCourse 1 takes 3 months and course 2 takes 2 months to complete respectively.\nThus, the earliest time we can start course 3 is at month 3, and the total time required is 3 + 5 = 8 months.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/10/07/ex2.png]\n\n\nInput: n = 5, relations = [[1,5],[2,5],[3,5],[3,4],[4,5]], time = [1,2,3,4,5]\nOutput: 12\nExplanation: The figure above represents the given graph and the time required to complete each course.\nYou can start courses 1, 2, and 3 at month 0.\nYou can complete them after 1, 2, and 3 months respectively.\nCourse 4 can be taken only after course 3 is completed, i.e., after 3 months. It is completed after 3 + 4 = 7 months.\nCourse 5 can be taken only after courses 1, 2, 3, and 4 have been completed, i.e., after max(1,2,3,7) = 7 months.\nThus, the minimum time needed to complete all the courses is 7 + 5 = 12 months.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 5 * 104\n * 0 <= relations.length <= min(n * (n - 1) / 2, 5 * 104)\n * relations[j].length == 2\n * 1 <= prevCoursej, nextCoursej <= n\n * prevCoursej != nextCoursej\n * All the pairs [prevCoursej, nextCoursej] are unique.\n * time.length == n\n * 1 <= time[i] <= 104\n * The given graph is a directed acyclic graph.",
    "code": "class Solution {\npublic:\n    int minimumTime(int n, vector<vector<int>>& relations, \nvector<int>& time) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    unordered_map<int, vector<int>> graph;\n    \n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) { \n        unordered_map<int, vector<int>> graph;\n        vector<int> indegree = vector(n, 0);\n\n        for (vector<int>& edge: relations) {\n            int x = edge[0] - 1;\n            int y = edge[1] - 1;\n            graph[x].push_back(y);\n            indegree[y]++;\n        }\n        \n        queue<int> queue;\n        vector<int> maxTime = vector(n, 0);\n        \n        for (int node = 0; node < n; node++) {\n            if (indegree[node] == 0) {\n                queue.push(node);\n                maxTime[node] = time[node];\n            }\n        }\n        \n        while (!queue.empty()) {\n            int node = queue.front();\n            queue.pop();\n            for (int neighbor: graph[node]) {\n                maxTime[neighbor] = max(maxTime[neighbor], maxTime[node] + time[neighbor]);\n                indegree[neighbor]--;\n                if (indegree[neighbor] == 0) {\n                    queue.push(neighbor);\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int node = 0; node < n; node++) {\n            ans = max(ans, maxTime[node]);\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    unordered_map<int, vector<int>> graph;\n    vector<int> memo;\n    \n    int minimumTime(int n, vector<vector<int>>& relations, vector<int>& time) { \n        for (vector<int>& edge: relations) {\n            int x = edge[0] - 1;\n            int y = edge[1] - 1;\n            graph[x].push_back(y);\n        }\n        \n        memo = vector(n, -1);\n        int ans = 0;\n        for (int node = 0; node < n; node++) {\n            ans = max(ans, dfs(node, time));\n        }\n        \n        return ans;\n    }\n    \n    int dfs(int node, vector<int>& time) {\n        if (memo[node] != -1) {\n            return memo[node];\n        }\n        \n        if (graph[node].size() == 0) {\n            return time[node];\n        }\n        \n        int ans = 0;\n        for (int neighbor: graph[node]) {\n            ans = max(ans, dfs(neighbor, time));\n        }\n        \n        memo[node] = time[node] + ans;\n        return time[node] + ans;\n    }\n};"
    ]
  },
  {
    "number": 5,
    "question": "Can you solve this real interview question? Check Whether Two Strings are Almost Equivalent - Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from 'a' to 'z' between word1 and word2 is at most 3.\n\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\n\nThe frequency of a letter x is the number of times it occurs in the string.\n\n \n\nExample 1:\n\n\nInput: word1 = \"aaaa\", word2 = \"bccb\"\nOutput: false\nExplanation: There are 4 'a's in \"aaaa\" but 0 'a's in \"bccb\".\nThe difference is 4, which is more than the allowed 3.\n\n\nExample 2:\n\n\nInput: word1 = \"abcdeef\", word2 = \"abaaacc\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 1 time in word1 and 4 times in word2. The difference is 3.\n- 'b' appears 1 time in word1 and 1 time in word2. The difference is 0.\n- 'c' appears 1 time in word1 and 2 times in word2. The difference is 1.\n- 'd' appears 1 time in word1 and 0 times in word2. The difference is 1.\n- 'e' appears 2 times in word1 and 0 times in word2. The difference is 2.\n- 'f' appears 1 time in word1 and 0 times in word2. The difference is 1.\n\n\nExample 3:\n\n\nInput: word1 = \"cccddabba\", word2 = \"babababab\"\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- 'a' appears 2 times in word1 and 4 times in word2. The difference is 2.\n- 'b' appears 2 times in word1 and 5 times in word2. The difference is 3.\n- 'c' appears 3 times in word1 and 0 times in word2. The difference is 3.\n- 'd' appears 2 times in word1 and 0 times in word2. The difference is 2.\n\n\n \n\nConstraints:\n\n * n == word1.length == word2.length\n * 1 <= n <= 100\n * word1 and word2 consist only of lowercase English letters.",
    "code": "class Solution {\npublic:\n    bool checkAlmostEquivalent(string word1, string word2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    bool checkAlmostEquivalent(string word1, string word2) {\n        int cnt[26] = {0};\n        \n        for (int i = 0; i < word1.size(); i++) {\n            cnt[word1[i] - 'a']++;\n            cnt[word2[i] - 'a']--;\n        }\n\n        for (int i = 0; i < 26; i++) {\n            if (abs(cnt[i]) > 3) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};"
    ]
  },
  {
    "number": 6,
    "question": "Can you solve this real interview question? Sum of Subarray Ranges - You are given an integer array nums. The range of a subarray of nums is the difference between the largest and smallest element in the subarray.\n\nReturn the sum of all subarray ranges of nums.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0 \n[2], range = 2 - 2 = 0\n[3], range = 3 - 3 = 0\n[1,2], range = 2 - 1 = 1\n[2,3], range = 3 - 2 = 1\n[1,2,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 1 + 1 + 2 = 4.\n\nExample 2:\n\n\nInput: nums = [1,3,3]\nOutput: 4\nExplanation: The 6 subarrays of nums are the following:\n[1], range = largest - smallest = 1 - 1 = 0\n[3], range = 3 - 3 = 0\n[3], range = 3 - 3 = 0\n[1,3], range = 3 - 1 = 2\n[3,3], range = 3 - 3 = 0\n[1,3,3], range = 3 - 1 = 2\nSo the sum of all ranges is 0 + 0 + 0 + 2 + 0 + 2 = 4.\n\n\nExample 3:\n\n\nInput: nums = [4,-2,-3,4,1]\nOutput: 59\nExplanation: The sum of all subarray ranges of nums is 59.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 1000\n * -109 <= nums[i] <= 109\n\n \n\nFollow-up: Could you find a solution with O(n) time complexity?",
    "code": "class Solution {\npublic:\n    long long subArrayRanges(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    long long subArrayRanges(vector<int>& nums) {\n        int n = int(nums.size());\n        long long answer = 0;\n        \n        for (int left = 0; left < n; ++left) {\n            int minVal = nums[left], maxVal = nums[left];\n            for (int right = left; right < n; ++right) {\n                maxVal = max(maxVal, nums[right]);\n                minVal = min(minVal, nums[right]);\n                answer += maxVal - minVal;\n            }\n        }\n        \n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    long long subArrayRanges(vector<int>& nums) {\n        int n = nums.size();\n        long long answer = 0;\n        stack<int> stk;\n        \n        // Find the sum of all the minimum.\n        for (int right = 0; right <= n; ++right) {\n            while (!stk.empty() && (right == n || nums[stk.top()] >= nums[right])) {\n                int mid = stk.top();\n                stk.pop();\n                int left = stk.empty() ? -1 : stk.top();\n                answer -= (long long)nums[mid] * (right - mid) * (mid - left);\n            }\n            stk.push(right); \n        }\n        \n        // Find the sum of all the maximum.\n        stk.pop();\n        for (int right = 0; right <= n; ++right) {\n            while (!stk.empty() && (right == n || nums[stk.top()] <= nums[right])) {\n                int mid = stk.top();\n                stk.pop();\n                int left = stk.empty() ? -1 : stk.top();\n                answer += (long long)nums[mid] * (right - mid) * (mid - left);\n            }\n            stk.push(right); \n        }\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 7,
    "question": "Can you solve this real interview question? Maximum Running Time of N Computers - You have n computers. You are given the integer n and a 0-indexed integer array batteries where the ith battery can run a computer for batteries[i] minutes. You are interested in running all n computers simultaneously using the given batteries.\n\nInitially, you can insert at most one battery into each computer. After that and at any integer time moment, you can remove a battery from a computer and insert another battery any number of times. The inserted battery can be a totally new battery or a battery from another computer. You may assume that the removing and inserting processes take no time.\n\nNote that the batteries cannot be recharged.\n\nReturn the maximum number of minutes you can run all the n computers simultaneously.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png]\n\n\nInput: n = 2, batteries = [3,3,3]\nOutput: 4\nExplanation: \nInitially, insert battery 0 into the first computer and battery 1 into the second computer.\nAfter two minutes, remove battery 1 from the second computer and insert battery 2 instead. Note that battery 1 can still run for one minute.\nAt the end of the third minute, battery 0 is drained, and you need to remove it from the first computer and insert battery 1 instead.\nBy the end of the fourth minute, battery 1 is also drained, and the first computer is no longer running.\nWe can run the two computers simultaneously for at most 4 minutes, so we return 4.\n\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2022/01/06/example2.png]\n\n\nInput: n = 2, batteries = [1,1,1,1]\nOutput: 2\nExplanation: \nInitially, insert battery 0 into the first computer and battery 2 into the second computer. \nAfter one minute, battery 0 and battery 2 are drained so you need to remove them and insert battery 1 into the first computer and battery 3 into the second computer. \nAfter another minute, battery 1 and battery 3 are also drained so the first and second computers are no longer running.\nWe can run the two computers simultaneously for at most 2 minutes, so we return 2.\n\n\n \n\nConstraints:\n\n * 1 <= n <= batteries.length <= 105\n * 1 <= batteries[i] <= 109",
    "code": "class Solution {\npublic:\n    long long maxRunTime(int n, vector<int>& batteries) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public long maxRunTime(int n, int[] batteries) {\n        // Get the sum of all extra batteries.\n        Arrays.sort(batteries);\n        long extra = 0;\n        for (int i = 0; i < batteries.length - n; i++) {\n            extra += batteries[i];\n        }\n\n        // live stands for the n largest batteries we chose for n computers.\n\n        int[] live = Arrays.copyOfRange(batteries, batteries.length - n, batteries.length);\n\n        // We increase the total running time using 'extra' by increasing \n        // the running time of the computer with the smallest battery.\n        for (int i = 0; i < n - 1; i++) {\n            // If the target running time is between live[i] and live[i + 1].\n            if (extra < (long)(i + 1) * (live[i + 1] - live[i])) {\n                return live[i] + extra / (long)(i + 1);\n            }\n\n            // Reduce 'extra' by the total power used.\n            extra -= (long)(i + 1) * (live[i + 1] - live[i]);\n        }\n\n        // If there is power left, we can increase the running time \n        // of all computers.\n        return live[n - 1] + extra / n;\n    }\n}",
      "class Solution {\n    public long maxRunTime(int n, int[] batteries) {\n        long sumPower = 0;\n        for (int power : batteries)\n            sumPower += power;\n        long left = 1, right = sumPower / n;\n        \n        while (left < right){\n            long target = right - (right - left) / 2;\n            long extra = 0;\n            \n            for (int power : batteries)\n                extra += Math.min(power, target);\n\n            if (extra >= (long)(n * target))\n                left = target;\n            else\n                right = target - 1;\n        }\n        return left;\n    }\n}"
    ]
  },
  {
    "number": 8,
    "question": "Can you solve this real interview question? Number of Ways to Divide a Long Corridor - Along a long library corridor, there is a line of seats and decorative plants. You are given a 0-indexed string corridor of length n consisting of letters 'S' and 'P' where each 'S' represents a seat and each 'P' represents a plant.\n\nOne room divider has already been installed to the left of index 0, and another to the right of index n - 1. Additional room dividers can be installed. For each position between indices i - 1 and i (1 <= i <= n - 1), at most one divider can be installed.\n\nDivide the corridor into non-overlapping sections, where each section has exactly two seats with any number of plants. There may be multiple ways to perform the division. Two ways are different if there is a position with a room divider installed in the first way but not in the second way.\n\nReturn the number of ways to divide the corridor. Since the answer may be very large, return it modulo 109 + 7. If there is no way, return 0.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/12/04/1.png]\n\n\nInput: corridor = \"SSPPSPS\"\nOutput: 3\nExplanation: There are 3 different ways to divide the corridor.\nThe black bars in the above image indicate the two room dividers already installed.\nNote that in each of the ways, each section has exactly two seats.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/12/04/2.png]\n\n\nInput: corridor = \"PPSPSP\"\nOutput: 1\nExplanation: There is only 1 way to divide the corridor, by not installing any additional dividers.\nInstalling any would create some section that does not have exactly two seats.\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2021/12/12/3.png]\n\n\nInput: corridor = \"S\"\nOutput: 0\nExplanation: There is no way to divide the corridor because there will always be a section that does not have exactly two seats.\n\n\n \n\nConstraints:\n\n * n == corridor.length\n * 1 <= n <= 105\n * corridor[i] is either 'S' or 'P'.",
    "code": "class Solution {\npublic:\n    int numberOfWays(string corridor) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    // Store 1000000007 in a variable for convenience\n    const int MOD = 1e9 + 7;\n    \n    // Count the number of ways to divide from \"index\" to the last index\n    // with \"seats\" number of \"S\" in the current section\n    int count(int index, int seats, string& corridor, int cache[][3]) {\n        // If we have reached the end of the corridor, then\n        // the current section is valid only if \"seats\" is 2\n        if (index == corridor.length()) {\n            return seats == 2 ? 1 : 0;\n        }\n\n        // If we have already computed the result of this sub-problem,\n        // then return the cached result\n        if (cache[index][seats] != -1) {\n            return cache[index][seats];\n        }\n\n        // Result of the sub-problem\n        int result = 0;\n\n        // If the current section has exactly 2 \"S\"\n        if (seats == 2) {\n            // If the current element is \"S\", then we have to close the\n            // section and start a new section from this index. Next index\n            // will have one \"S\" in the current section\n            if (corridor[index] == 'S') {\n                result = count(index + 1, 1, corridor, cache);\n            } else {\n                // If the current element is \"P\", then we have two options\n                // 1. Close the section and start a new section from this index\n                // 2. Keep growing the section\n                result = (count(index + 1, 0, corridor, cache) + count(index + 1, 2, corridor, cache)) % MOD;  \n            }\n        } else {\n            // Keep growing the section. Increment \"seats\" if present\n            // element is \"S\"\n            if (corridor[index] == 'S') {\n                result = count(index + 1, seats + 1, corridor, cache);\n            } else {\n                result = count(index + 1, seats, corridor, cache);\n            }\n        }\n\n        // Memoize the result, and return it\n        cache[index][seats] = result;\n        return cache[index][seats];\n    }\n\n    int numberOfWays(string corridor) {\n        // Cache the result of each sub-problem\n        int cache[corridor.length()][3];\n        memset(cache, -1, sizeof(cache));\n\n        // Call the count function\n        return count(0, 0, corridor, cache);\n    }\n};",
      "class Solution {\npublic:\n    int numberOfWays(string corridor) {\n        // Store 1000000007 in a variable for convenience\n        const int MOD = 1e9 + 7;\n\n        // Initialize the array to store the result of each sub-problem\n        int count[corridor.length() + 1][3];\n\n        // Base cases\n        count[corridor.length()][0] = 0;\n        count[corridor.length()][1] = 0;\n        count[corridor.length()][2] = 1;\n\n        // Fill the array in a bottom-up fashion\n        for (int index = corridor.length() - 1; index >= 0; index--) {\n            if (corridor[index] == 'S') {\n                count[index][0] = count[index + 1][1];\n                count[index][1] = count[index + 1][2];\n                count[index][2] = count[index + 1][1];\n            } else {\n                count[index][0] = count[index + 1][0];\n                count[index][1] = count[index + 1][1];\n                count[index][2] = (count[index + 1][0] + count[index + 1][2]) % MOD;\n            }\n        }\n\n        // Return the result\n        return count[0][0];\n    }\n};",
      "class Solution {\npublic:\n    int numberOfWays(string corridor) {\n        // Store 1000000007 in a variable for convenience\n        const int MOD = 1e9 + 7;\n\n        // Initial values of three variables\n        int zero = 0;\n        int one = 0;\n        int two = 1;\n\n        // Compute using derived equations\n        for (char thing : corridor) {\n            if (thing == 'S') {\n                zero = one;\n                swap(one, two);\n            } else {\n                two = (two + zero) % MOD;\n            }\n        }\n\n        // Return the result\n        return zero;\n    }\n};",
      "class Solution {\npublic:\n    int numberOfWays(string corridor) {\n        // Store 1000000007 in a variable for convenience\n        const int MOD = 1e9 + 7;\n\n        // Store indices of S in an array\n        vector<int> indices;\n        for (int index = 0; index < corridor.length(); index++) {\n            if (corridor[index] == 'S') {\n                indices.push_back(index);\n            }\n        }\n\n        // When division is not possible\n        if (indices.size() == 0 || indices.size() % 2 == 1) {\n            return 0;\n        }\n\n        // Total number of ways\n        long count = 1;\n\n        // Take product of non-paired neighbors\n        int previousPairLast = 1;\n        int currentPairFirst = 2;\n        while (currentPairFirst < indices.size()) {\n            count *= (indices[currentPairFirst] - indices[previousPairLast]);\n            count %= MOD;\n            previousPairLast += 2;\n            currentPairFirst += 2;\n        }\n\n        // Return the number of ways\n        return (int) count;\n    }\n};",
      "class Solution {\npublic:\n    int numberOfWays(string corridor) {\n        // Store 1000000007 in a variable for convenience\n        const int MOD = 1e9 + 7;\n\n        // Total number of ways\n        long count = 1;\n\n        // Number of seats in the current section\n        int seats = 0;\n\n        // Tracking Index of last S in the previous section\n        int previousPairLast = -1;\n\n        // Keep track of seats in corridor\n        for (int index = 0; index < corridor.length(); index++) {\n            if (corridor[index] == 'S') {\n                seats += 1;\n\n                // If two seats, then this is the last S in the section\n                // Update seats for the next section\n                if (seats == 2) {\n                    previousPairLast = index;\n                    seats = 0;\n                }\n\n                // If one seat, then this is the first S in the section\n                // Compute product of non-paired neighbors\n                else if (seats == 1 && previousPairLast != -1) {\n                    count *= (index - previousPairLast);\n                    count %= MOD;\n                }\n            }\n        }\n\n        // If odd seats, or zero seats\n        if (seats == 1 || previousPairLast == -1) {\n            return 0;\n        }\n\n        // Return the number of ways\n        return (int) count;\n    }\n};"
    ]
  },
  {
    "number": 9,
    "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
    "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
    ]
  },
  {
    "number": 10,
    "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
    "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
    ]
  },
  {
    "number": 11,
    "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
    ]
  },
  {
    "number": 12,
    "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
    "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
    ]
  },
  {
    "number": 13,
    "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
    "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
    ]
  },
  {
    "number": 14,
    "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
    "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
    ]
  },
  {
    "number": 15,
    "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
    "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
    "solution": [
      "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
      "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
    ]
  },
  {
    "number": 16,
    "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
    "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
    "solution": [
      " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
      "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
    ]
  },
  {
    "number": 17,
    "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
    "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
    ]
  },
  {
    "number": 18,
    "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
    "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
    ]
  },
  {
    "number": 19,
    "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
    "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
    ]
  },
  {
    "number": 20,
    "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
    "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
      "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 21,
    "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
    "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
    ]
  },
  {
    "number": 22,
    "question": "Can you solve this real interview question? Find the Difference of Two Arrays - Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\n\n * answer[0] is a list of all distinct integers in nums1 which are not present in nums2.\n * answer[1] is a list of all distinct integers in nums2 which are not present in nums1.\n\nNote that the integers in the lists may be returned in any order.\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,2,3], nums2 = [2,4,6]\nOutput: [[1,3],[4,6]]\nExplanation:\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].\n\nExample 2:\n\n\nInput: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\nOutput: [[3],[]]\nExplanation:\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].\n\n\n \n\nConstraints:\n\n * 1 <= nums1.length, nums2.length <= 1000\n * -1000 <= nums1[i], nums2[i] <= 1000",
    "code": "class Solution {\npublic:\n    vector<vector<int>> findDifference(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    // Returns the elements in the first arg nums1 that don't exist in the second arg nums2.\n    vector<int> getElementsOnlyInFirstList(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> onlyInNums1;\n        \n        // Iterate over each element in the list nums1.\n        for (int num : nums1) {\n            bool existInNums2 = false;\n            // Check if num is present in the second arg nums2.\n            for (int x : nums2) {\n                if (x == num) {\n                    existInNums2 = true;\n                    break;\n                }\n            }\n            \n            if (!existInNums2) {\n                onlyInNums1.insert(num);\n            }\n        }\n        \n        // Convert to vector.\n        return vector<int> (onlyInNums1.begin(), onlyInNums1.end());\n    }\n    \n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\n        return {getElementsOnlyInFirstList(nums1, nums2), getElementsOnlyInFirstList(nums2, nums1)};\n    }\n};",
      "class Solution {\npublic:\n    // Returns the elements in the first arg nums1 that don't exist in the second arg nums2.\n    vector<int> getElementsOnlyInFirstList(vector<int>& nums1, vector<int>& nums2) {\n        unordered_set<int> onlyInNums1;\n        \n        // Store nums2 elements in an unordered set. \n        unordered_set<int> existsInNums2;\n        for (int num : nums2) {\n            existsInNums2.insert(num);\n        }\n        \n        // Iterate over each element in the list nums1.\n        for (int num : nums1) {\n            if (existsInNums2.find(num) == existsInNums2.end()) {\n                onlyInNums1.insert(num);\n            }\n        }\n        \n        // Convert to vector.\n        return vector<int> (onlyInNums1.begin(), onlyInNums1.end());\n    }\n    \n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\n        return {getElementsOnlyInFirstList(nums1, nums2), getElementsOnlyInFirstList(nums2, nums1)};\n    }\n};"
    ]
  },
  {
    "number": 23,
    "question": "Can you solve this real interview question? Number of Flowers in Full Bloom - You are given a 0-indexed 2D integer array flowers, where flowers[i] = [starti, endi] means the ith flower will be in full bloom from starti to endi (inclusive). You are also given a 0-indexed integer array people of size n, where people[i] is the time that the ith person will arrive to see the flowers.\n\nReturn an integer array answer of size n, where answer[i] is the number of flowers that are in full bloom when the ith person arrives.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg]\n\n\nInput: flowers = [[1,6],[3,7],[9,12],[4,13]], people = [2,3,7,11]\nOutput: [1,2,2,2]\nExplanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg]\n\n\nInput: flowers = [[1,10],[3,3]], people = [3,3,2]\nOutput: [2,2,1]\nExplanation: The figure above shows the times when the flowers are in full bloom and when the people arrive.\nFor each person, we return the number of flowers in full bloom during their arrival.\n\n\n \n\nConstraints:\n\n * 1 <= flowers.length <= 5 * 104\n * flowers[i].length == 2\n * 1 <= starti <= endi <= 109\n * 1 <= people.length <= 5 * 104\n * 1 <= people[i] <= 109",
    "code": "class Solution {\npublic:\n    vector<int> fullBloomFlowers(vector<vector<int>>& \nflowers, vector<int>& people) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<int> fullBloomFlowers(vector<vector<int>>& flowers, vector<int>& people) {\n        vector<int> sortedPeople(people.begin(), people.end());\n        sort(sortedPeople.begin(), sortedPeople.end());\n        \n        sort(flowers.begin(), flowers.end());\n        unordered_map<int, int> dic;\n        priority_queue<int, vector<int>, greater<int>> heap;\n        \n        int i = 0;\n        for (int person : sortedPeople) {\n            while (i < flowers.size() && flowers[i][0] <= person) {\n                heap.push(flowers[i][1]);\n                i++;\n            }\n            \n            while (!heap.empty() && heap.top() < person) {\n                heap.pop();\n            }\n            \n            dic[person] = heap.size();\n        }\n        \n        vector<int> ans;\n        for (int person : people) {\n            ans.push_back(dic[person]);\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> fullBloomFlowers(vector<vector<int>>& flowers, vector<int>& people) {\n        map<int, int> difference;\n        difference[0] = 0;\n        \n        for (vector<int>& flower : flowers) {\n            difference[flower[0]]++;\n            difference[flower[1] + 1]--;\n        }\n        \n        vector<int> positions;\n        vector<int> prefix;\n        int curr = 0;\n        for (auto& pair : difference) {\n            positions.push_back(pair.first);\n            curr += pair.second;\n            prefix.push_back(curr);\n        }\n        \n        vector<int> ans;\n        for (int person : people) {\n            int i = upper_bound(positions.begin(), positions.end(), person) - positions.begin() - 1;\n            ans.push_back(prefix[i]);\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> fullBloomFlowers(vector<vector<int>>& flowers, vector<int>& people) {\n        vector<int> starts;\n        vector<int> ends;\n        \n        for (vector<int>& flower : flowers) {\n            starts.push_back(flower[0]);\n            ends.push_back(flower[1] + 1);\n        }\n        \n        sort(starts.begin(), starts.end());\n        sort(ends.begin(), ends.end());\n        vector<int> ans;\n        \n        for (int person : people) {\n            int i = upper_bound(starts.begin(), starts.end(), person) - starts.begin();\n            int j = upper_bound(ends.begin(), ends.end(), person) - ends.begin();\n            ans.push_back(i - j);\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 24,
    "question": "Can you solve this real interview question? Largest 3-Same-Digit Number in String - You are given a string num representing a large integer. An integer is good if it meets the following conditions:\n\n * It is a substring of num with length 3.\n * It consists of only one unique digit.\n\nReturn the maximum good integer as a string or an empty string \"\" if no such integer exists.\n\nNote:\n\n * A substring is a contiguous sequence of characters within a string.\n * There may be leading zeroes in num or a good integer.\n\n \n\nExample 1:\n\n\nInput: num = \"6777133339\"\nOutput: \"777\"\nExplanation: There are two distinct good integers: \"777\" and \"333\".\n\"777\" is the largest, so we return \"777\".\n\n\nExample 2:\n\n\nInput: num = \"2300019\"\nOutput: \"000\"\nExplanation: \"000\" is the only good integer.\n\n\nExample 3:\n\n\nInput: num = \"42352338\"\nOutput: \"\"\nExplanation: No substring of length 3 consists of only one unique digit. Therefore, there are no good integers.\n\n\n \n\nConstraints:\n\n * 3 <= num.length <= 1000\n * num only consists of digits.",
    "code": "class Solution {\npublic:\n    string largestGoodInteger(string num) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    vector<string> sameDigitNumbers = {\"999\", \"888\", \"777\", \"666\", \"555\", \"444\", \"333\", \"222\", \"111\", \"000\"};\n\n    // Check whether the 'num' string contains the 'sameDigitNumber' string or not.\n    bool contains(string sameDigitNumber, string num) {\n        for (int index = 0; index <= num.size() - 3; ++index) {\n            if (num[index] == sameDigitNumber[0] and \n                num[index + 1] == sameDigitNumber[1] and \n                num[index + 2] == sameDigitNumber[2]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\npublic:\n    string largestGoodInteger(string num) {\n        // Iterate on all 'sameDigitNumbers' and check if the string 'num' contains it.\n        for (auto& sameDigitNumber: sameDigitNumbers) {\n            if (contains(sameDigitNumber, num)) {\n                // Return the current 'sameDigitNumbers'.\n                return sameDigitNumber;\n            }\n        }\n        // No 3 consecutive same digits are present in the string 'num'.\n        return \"\";\n    }\n};",
      "class Solution {\npublic:\n    string largestGoodInteger(string num) {\n        // Assign 'maxDigit' to the NUL character (smallest ASCII value character)\n        char maxDigit = '\\0';\n\n        // Iterate on characters of the num string.\n        for (int index = 0; index <= num.size() - 3; ++index) {\n            // If 3 consecutive characters are the same,\n            // store the character in 'maxDigit' if bigger than what it already stores.\n            if (num[index] == num[index + 1] && num[index] == num[index + 2]) {\n                maxDigit = max(maxDigit, num[index]);\n            }\n        }\n\n        // If 'maxDigit' is NUL return an empty string, otherwise string of size 3 with 'maxDigit' characters.\n        return maxDigit == '\\0' ? \"\" : string(3, maxDigit);\n    }\n};"
    ]
  },
  {
    "number": 25,
    "question": "Can you solve this real interview question? Count Nodes Equal to Average of Subtree - Given the root of a binary tree, return the number of nodes where the value of the node is equal to the average of the values in its subtree.\n\nNote:\n\n * The average of n elements is the sum of the n elements divided by n and rounded down to the nearest integer.\n * A subtree of root is a tree consisting of root and all of its descendants.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png]\n\n\nInput: root = [4,8,5,0,1,null,6]\nOutput: 5\nExplanation: \nFor the node with value 4: The average of its subtree is (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4.\nFor the node with value 5: The average of its subtree is (5 + 6) / 2 = 11 / 2 = 5.\nFor the node with value 0: The average of its subtree is 0 / 1 = 0.\nFor the node with value 1: The average of its subtree is 1 / 1 = 1.\nFor the node with value 6: The average of its subtree is 6 / 1 = 6.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png]\n\n\nInput: root = [1]\nOutput: 1\nExplanation: For the node with value 1: The average of its subtree is 1 / 1 = 1.\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 1000].\n * 0 <= Node.val <= 1000",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int averageOfSubtree(TreeNode* root) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int count = 0;\n    \n    pair<int, int> postOrder(TreeNode* root) {\n        if (root == NULL) {\n            return {0, 0};\n        }\n        \n        // First iterate over left and right subtrees.\n        pair<int, int> left = postOrder(root->left);\n        pair<int, int> right = postOrder(root->right);\n        \n        int nodeSum = left.first + right.first + root->val;\n        int nodeCount = left.second + right.second + 1;\n\n        // Check if the average of the subtree is equal to the node value.\n        if (root->val == nodeSum / (nodeCount)) {\n            count++;\n        }\n        \n        // Return the sum of nodes and the count in the subtree.\n        return {nodeSum, nodeCount};\n    }\n    \n    int averageOfSubtree(TreeNode* root) {\n        postOrder(root);\n        return count;\n    }\n};"
    ]
  },
  {
    "number": 26,
    "question": "Can you solve this real interview question? Substring With Largest Variance - The variance of a string is defined as the largest difference between the number of occurrences of any 2 characters present in the string. Note the two characters may or may not be the same.\n\nGiven a string s consisting of lowercase English letters only, return the largest variance possible among all substrings of s.\n\nA substring is a contiguous sequence of characters within a string.\n\n \n\nExample 1:\n\n\nInput: s = \"aababbb\"\nOutput: 3\nExplanation:\nAll possible variances along with their respective substrings are listed below:\n- Variance 0 for substrings \"a\", \"aa\", \"ab\", \"abab\", \"aababb\", \"ba\", \"b\", \"bb\", and \"bbb\".\n- Variance 1 for substrings \"aab\", \"aba\", \"abb\", \"aabab\", \"ababb\", \"aababbb\", and \"bab\".\n- Variance 2 for substrings \"aaba\", \"ababbb\", \"abbb\", and \"babb\".\n- Variance 3 for substring \"babbb\".\nSince the largest possible variance is 3, we return it.\n\n\nExample 2:\n\n\nInput: s = \"abcde\"\nOutput: 0\nExplanation:\nNo letter occurs more than once in s, so the variance of every substring is 0.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 104\n * s consists of lowercase English letters.",
    "code": "class Solution {\npublic:\n    int largestVariance(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int largestVariance(string s) {\n        vector<int> counter(26, 0);\n        for (char ch : s) {\n            counter[ch - 'a']++;\n        }\n        int globalMax = 0;\n        \n        for (int i = 0; i < 26; i++) {\n            for (int j = 0; j < 26; j++) {\n                // major and minor cannot be the same, and both must appear in s.\n                if (i == j || counter[i] == 0 || counter[j] == 0) {\n                    continue;\n                }\n                \n                // Find the maximum variance of major - minor.        \n                char major = 'a' + i;\n                char minor = 'a' + j;\n                int majorCount = 0;\n                int minorCount = 0;\n                \n                // The remaining minor in the rest of s.\n                int restMinor = counter[j];\n                \n                for (char ch : s) {    \n                    if (ch == major) {\n                        majorCount++;\n                    }\n                    if (ch == minor) {\n                        minorCount++;\n                        restMinor--;\n                    }\n                    \n                    // Only update the variance (local_max) if there is at least one minor.\n                    if (minorCount > 0)\n                        globalMax = max(globalMax, majorCount - minorCount);\n                    \n                    // We can discard the previous string if there is at least one remaining minor\n                    if (majorCount < minorCount && restMinor > 0) {\n                        majorCount = 0;\n                        minorCount = 0;\n                    }\n                }\n            }\n        }\n        \n        return globalMax;\n    }\n};\n"
    ]
  },
  {
    "number": 27,
    "question": "Can you solve this real interview question? Fair Distribution of Cookies - You are given an integer array cookies, where cookies[i] denotes the number of cookies in the ith bag. You are also given an integer k that denotes the number of children to distribute all the bags of cookies to. All the cookies in the same bag must go to the same child and cannot be split up.\n\nThe unfairness of a distribution is defined as the maximum total cookies obtained by a single child in the distribution.\n\nReturn the minimum unfairness of all distributions.\n\n \n\nExample 1:\n\n\nInput: cookies = [8,15,10,20,8], k = 2\nOutput: 31\nExplanation: One optimal distribution is [8,15,8] and [10,20]\n- The 1st child receives [8,15,8] which has a total of 8 + 15 + 8 = 31 cookies.\n- The 2nd child receives [10,20] which has a total of 10 + 20 = 30 cookies.\nThe unfairness of the distribution is max(31,30) = 31.\nIt can be shown that there is no distribution with an unfairness less than 31.\n\n\nExample 2:\n\n\nInput: cookies = [6,1,3,2,2,4,1,2], k = 3\nOutput: 7\nExplanation: One optimal distribution is [6,1], [3,2,2], and [4,1,2]\n- The 1st child receives [6,1] which has a total of 6 + 1 = 7 cookies.\n- The 2nd child receives [3,2,2] which has a total of 3 + 2 + 2 = 7 cookies.\n- The 3rd child receives [4,1,2] which has a total of 4 + 1 + 2 = 7 cookies.\nThe unfairness of the distribution is max(7,7,7) = 7.\nIt can be shown that there is no distribution with an unfairness less than 7.\n\n\n \n\nConstraints:\n\n * 2 <= cookies.length <= 8\n * 1 <= cookies[i] <= 105\n * 2 <= k <= cookies.length",
    "code": "class Solution {\npublic:\n    int distributeCookies(vector<int>& cookies, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int dfs(int i, vector<int>& distribute, vector<int>& cookies, int k, int zeroCount) {\n        // If there are not enough cookies remaining, return INT_MAX \n        // as it leads to an invalid distribution.\n        if (cookies.size() - i < zeroCount) {\n            return INT_MAX;\n        }\n\n        // After distributing all cookies, return the unfairness of this\n        // distribution.\n        if (i == cookies.size()) {\n            return *max_element(distribute.begin(), distribute.end());\n        }\n\n        // Try to distribute the i-th cookie to each child, and update answer\n        // as the minimum unfairness in these distributions.\n        int answer = INT_MAX;\n        for (int j = 0; j < k; ++j) {\n            zeroCount -= distribute[j] == 0 ? 1 : 0;\n            distribute[j] += cookies[i];\n            \n            // Recursively distribute the next cookie.\n            answer = min(answer, dfs(i + 1, distribute, cookies, k, zeroCount)); \n            \n            distribute[j] -= cookies[i];\n            zeroCount += distribute[j] == 0 ? 1 : 0;\n        }\n        \n        return answer;\n    }\n    \n    int distributeCookies(vector<int>& cookies, int k) {\n        vector<int> distribute(k, 0);\n\n        return dfs(0, distribute, cookies, k, k);\n    }\n};"
    ]
  }
]