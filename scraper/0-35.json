[
    {
      "number": 1,
      "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
      "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
      ]
    },
    {
      "number": 2,
      "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
      "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 3,
      "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
      ]
    },
    {
      "number": 4,
      "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
      ]
    },
    {
      "number": 5,
      "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
      "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
      ]
    },
    {
      "number": 6,
      "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
      "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
      ]
    },
    {
      "number": 7,
      "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
      "solution": [
        "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
        "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
      ]
    },
    {
      "number": 8,
      "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
        "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
      ]
    },
    {
      "number": 9,
      "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
      ]
    },
    {
      "number": 10,
      "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
      "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
      ]
    },
    {
      "number": 11,
      "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
      ]
    },
    {
      "number": 12,
      "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
      "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
        "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 13,
      "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
      "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
      ]
    },
    {
      "number": 14,
      "question": "Can you solve this real interview question? Merge Intervals - Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n \n\nExample 1:\n\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\n\n\nExample 2:\n\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n\n\n \n\nConstraints:\n\n * 1 <= intervals.length <= 104\n * intervals[i].length == 2\n * 0 <= starti <= endi <= 104",
      "code": "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& \nintervals) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    map<vector<int>, vector<vector<int>>> graph;\n    map<int, vector<vector<int>>> nodes_in_comp;\n    set<vector<int>> visited;\n\n    bool overlap(vector<int>& a, vector<int>& b) {\n        return a[0] <= b[1] and b[0] <= a[1];\n    }\n\n    // build a graph where an undirected edge between intervals u and v exists\n    // iff u and v overlap.\n    void buildGraph(vector<vector<int>>& intervals) {\n        for (auto interval1 : intervals) {\n            for (auto interval2 : intervals) {\n                if (overlap(interval1, interval2)) {\n                    graph[interval1].push_back(interval2);\n                    graph[interval2].push_back(interval1);\n                }\n            }\n        }\n    }\n\n    // merges all of the nodes in this connected component into one interval.\n    vector<int> mergeNodes(vector<vector<int>>& nodes) {\n        int min_start = nodes[0][0];\n        for (auto node : nodes) {\n            min_start = min(min_start, node[0]);\n        }\n\n        int max_end = nodes[0][1];\n        for (auto node : nodes) {\n            max_end = max(max_end, node[1]);\n        }\n\n        return {min_start, max_end};\n    }\n\n    // use depth-first search to mark all nodes in the same connected component\n    // with the same integer.\n    void markComponentDFS(vector<int>& start, int comp_number) {\n        stack<vector<int>> stk;\n        stk.push(start);\n\n        while (!stk.empty()) {\n            vector<int> node = stk.top();\n            stk.pop();\n\n            // not found\n            if (visited.find(node) == visited.end()) {\n                visited.insert(node);\n\n                nodes_in_comp[comp_number].push_back(node);\n\n                for (auto child : graph[node]) {\n                    stk.push(child);\n                }\n            }\n        }\n    }\n\n    // gets the connected components of the interval overlap graph.\n    void buildComponents(vector<vector<int>>& intervals) {\n        int comp_number = 0;\n\n        for (auto interval : intervals) {\n            if (visited.find(interval) == visited.end()) {\n                markComponentDFS(interval, comp_number);\n                comp_number++;\n            }\n        }\n    }\n\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        buildGraph(intervals);\n        buildComponents(intervals);\n\n        // for each component, merge all intervals into one interval.\n        vector<vector<int>> merged;\n        for (size_t comp = 0; comp < nodes_in_comp.size(); comp++) {\n            merged.push_back(mergeNodes(nodes_in_comp[comp]));\n        }\n\n        return merged;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\n        sort(intervals.begin(), intervals.end());\n\n        vector<vector<int>> merged;\n        for (auto interval : intervals) {\n            // if the list of merged intervals is empty or if the current\n            // interval does not overlap with the previous, simply append it.\n            if (merged.empty() || merged.back()[1] < interval[0]) {\n                merged.push_back(interval);\n            }\n            // otherwise, there is overlap, so we merge the current and previous\n            // intervals.\n            else {\n                merged.back()[1] = max(merged.back()[1], interval[1]);\n            }\n        }\n        return merged;\n    }\n};"
      ]
    },
    {
      "number": 15,
      "question": "Can you solve this real interview question? Spiral Matrix II - Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg]\n\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\n\nExample 2:\n\n\nInput: n = 1\nOutput: [[1]]\n\n\n \n\nConstraints:\n\n * 1 <= n <= 20",
      "code": "class Solution {\npublic:\n    vector<vector<int>> generateMatrix(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n\n    vector<vector<int>> generateMatrix(int n) {\n\n        vector<vector<int>> result (n, vector<int>(n));\n        int cnt = 1;\n        for (int layer = 0; layer < (n + 1) / 2; layer++) {\n            // direction 1 - traverse from left to right\n            for (int ptr = layer; ptr < n - layer; ptr++) {\n                result[layer][ptr] = cnt++;\n            }\n            // direction 2 - traverse from top to bottom\n            for (int ptr = layer + 1; ptr < n - layer; ptr++) {\n                result[ptr][n - layer - 1] = cnt++;\n            }\n            // direction 3 - traverse from right to left\n            for (int ptr = n - layer - 2; ptr >= layer; ptr--) {\n                result[n - layer - 1][ptr] = cnt++;\n            }\n            // direction 4 - traverse from bottom to top\n            for (int ptr = n - layer - 2; ptr > layer; ptr--) {\n                result[ptr][layer] = cnt++;\n            }\n        }\n\n        return result;\n    }\n};",
        "class Solution {\npublic:\n\n    int floorMod(int x, int y) {\n        return ((x % y) + y) % y;\n    }\n\n    vector<vector<int>> generateMatrix(int n) {\n        vector<vector<int>> result (n, vector<int>(n));\n        int cnt = 1;\n        int dir[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n       int d = 0;\n        int row = 0;\n        int col = 0;\n        while (cnt <= n * n) {\n            result[row][col] = cnt++;\n            int r = floorMod(row + dir[d][0], n);\n            int c = floorMod(col + dir[d][1], n);\n            // change direction if next cell is non zero\n            if (result[r][c] != 0) d = (d + 1) % 4;\n            row += dir[d][0];\n            col += dir[d][1];\n        }\n        return result;\n    }\n};"
      ]
    },
    {
      "number": 16,
      "question": "Can you solve this real interview question? Subsets - Given an integer array nums of unique elements, return all possible subsets (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\nExample 2:\n\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 10\n * -10 <= nums[i] <= 10\n * All the numbers of nums are unique.",
      "code": "class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n  public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> output = new ArrayList();\n    output.add(new ArrayList<Integer>());\n\n    for (int num : nums) {\n      List<List<Integer>> newSubsets = new ArrayList();\n      for (List<Integer> curr : output) {\n        newSubsets.add(new ArrayList<Integer>(curr){{add(num);}});\n      }\n      for (List<Integer> curr : newSubsets) {\n        output.add(curr);\n      }\n    }\n    return output;\n  }\n}",
        "class Solution {\n  List<List<Integer>> output = new ArrayList();\n  int n, k;\n\n  public void backtrack(int first, ArrayList<Integer> curr, int[] nums) {\n    // if the combination is done\n    if (curr.size() == k) {\n      output.add(new ArrayList(curr));\n      return;\n    }\n    for (int i = first; i < n; ++i) {\n      // add i into the current combination\n      curr.add(nums[i]);\n      // use next integers to complete the combination\n      backtrack(i + 1, curr, nums);\n      // backtrack\n      curr.remove(curr.size() - 1);\n    }\n  }\n\n  public List<List<Integer>> subsets(int[] nums) {\n    n = nums.length;\n    for (k = 0; k < n + 1; ++k) {\n      backtrack(0, new ArrayList<Integer>(), nums);\n    }\n    return output;\n  }\n}",
        "int nthBit = 1 << n;\nfor (int i = 0; i < (int)Math.pow(2, n); ++i) {\n    // generate bitmask, from 0..00 to 1..11\n    String bitmask = Integer.toBinaryString(i | nthBit).substring(1);",
        "for (int i = (int)Math.pow(2, n); i < (int)Math.pow(2, n + 1); ++i) {\n  // generate bitmask, from 0..00 to 1..11\n  String bitmask = Integer.toBinaryString(i).substring(1);",
        "class Solution {\n  public List<List<Integer>> subsets(int[] nums) {\n    List<List<Integer>> output = new ArrayList();\n    int n = nums.length;\n\n    for (int i = (int)Math.pow(2, n); i < (int)Math.pow(2, n + 1); ++i) {\n      // generate bitmask, from 0..00 to 1..11\n      String bitmask = Integer.toBinaryString(i).substring(1);\n\n      // append subset corresponding to that bitmask\n      List<Integer> curr = new ArrayList();\n      for (int j = 0; j < n; ++j) {\n        if (bitmask.charAt(j) == '1') curr.add(nums[j]);\n      }\n      output.add(curr);\n    }\n    return output;\n  }\n}"
      ]
    },
    {
      "number": 17,
      "question": "Can you solve this real interview question? Scramble String - We can scramble a string s to get a string t using the following algorithm:\n\n 1. If the length of the string is 1, stop.\n 2. If the length of the string is > 1, do the following:\n    * Split the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\n    * Randomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\n    * Apply step 1 recursively on each of the two substrings x and y.\n\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n\n \n\nExample 1:\n\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\n\n\nExample 2:\n\n\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\n\n\nExample 3:\n\n\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n\n\n \n\nConstraints:\n\n * s1.length == s2.length\n * 1 <= s1.length <= 30\n * s1 and s2 consist of lowercase English letters.",
      "code": "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool isScramble(string s1, string s2) {\n        int n = s1.size();\n        vector dp(n + 1, vector(n, vector<int>(n)));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                dp[1][i][j] = s1[i] == s2[j];\n            }\n        }\n        for (int length = 2; length <= n; length++) {\n            for (int i = 0; i < n + 1 - length; i++) {\n                for (int j = 0; j < n + 1 - length; j++) {\n                    for (int newLength = 1; newLength < length; newLength++) {\n                        const vector<int>& dp1 = dp[newLength][i];\n                        const vector<int>& dp2 = dp[length - newLength][i + newLength];\n                        dp[length][i][j] |= dp1[j] && dp2[j + newLength];\n                        dp[length][i][j] |= dp1[j + length - newLength] && dp2[j];\n                    }\n                }\n            }\n        }\n        return dp[n][0][0];\n    }\n};"
      ]
    },
    {
      "number": 18,
      "question": "Can you solve this real interview question? Restore IP Addresses - A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\n * For example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\n\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\n \n\nExample 1:\n\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\n\n\nExample 2:\n\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\n\n\nExample 3:\n\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * s consists of digits only.",
      "code": "class Solution {\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    bool valid(const string& s, int start, int length) {\n        return length == 1 || (s[start] != '0' && (length < 3 || s.substr(start, length) <= \"255\"));\n    }\n\n    void helper(const string& s, int startIndex, vector<int>& dots, vector<string>& ans) {\n        const int remainingLength = s.length() - startIndex;\n        const int remainingNumberOfIntegers = 4 - dots.size();\n\n        if (remainingLength > remainingNumberOfIntegers * 3 ||\n            remainingLength < remainingNumberOfIntegers) {\n            return;\n        }\n        if (dots.size() == 3) {\n            if (valid(s, startIndex, remainingLength)) {\n                string temp;\n                int last = 0;\n                for (int dot : dots) {\n                    temp.append(s.substr(last, dot));\n                    last += dot;\n                    temp.append(\".\");\n                }\n                temp.append(s.substr(startIndex));\n                ans.push_back(temp);\n            }\n            return;\n        }\n        for (int curPos = 1; curPos <= 3 && curPos <= remainingLength; ++curPos) {\n            // Append a dot at the current position.\n            dots.push_back(curPos);\n            // Try making all combinations with the remaining string.\n            if (valid(s, startIndex, curPos)) {\n                helper(s, startIndex + curPos, dots, ans);\n            }\n            // Backtrack, i.e. remove the dot to try placing it at the next position.\n            dots.pop_back();\n        }\n    }\n\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        vector<int> dots;\n        vector<string> ans;\n        helper(s, 0, dots, ans);\n        return ans;\n    }\n};",
        "class Solution {\n    bool valid(const string& s, int start, int length) {\n        return length == 1 || (s[start] != '0' && (length < 3 || s.substr(start, length) <= \"255\"));\n    }\n\npublic:\n    vector<string> restoreIpAddresses(string s) {\n        vector<string> ans;\n        int length = s.length();\n        for (int len1 = max(1, length - 9); len1 <= 3 && len1 <= length - 3; ++len1) {\n            if (!valid(s, 0, len1)) {\n                continue;\n            }\n            for (int len2 = max(1, length - len1 - 6); len2 <= 3 && len2 <= length - len1 - 2;\n                 ++len2) {\n                if (!valid(s, len1, len2)) {\n                    continue;\n                }\n                for (int len3 = max(1, length - len1 - len2 - 3);\n                     len3 <= 3 && len3 <= length - len1 - len2 - 1; ++len3) {\n                    if (valid(s, len1 + len2, len3) &&\n                        valid(s, len1 + len2 + len3, length - len1 - len2 - len3)) {\n                        ans.push_back(s.substr(0, len1) + \".\" + s.substr(len1, len2) + \".\" +\n                                      s.substr(len1 + len2, len3) + \".\" +\n                                      s.substr(len1 + len2 + len3));\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 19,
      "question": "Can you solve this real interview question? Binary Tree Inorder Traversal - Given the root of a binary tree, return the inorder traversal of its nodes' values.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg]\n\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: root = []\nOutput: []\n\n\nExample 3:\n\n\nInput: root = [1]\nOutput: [1]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [0, 100].\n * -100 <= Node.val <= 100\n\n \n\nFollow up: Recursive solution is trivial, could you do it iteratively?",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        helper(root, res);\n        return res;\n    }\n\n    public void helper(TreeNode root, List<Integer> res) {\n        if (root != null) {\n            helper(root.left, res);\n            res.add(root.val);\n            helper(root.right, res);\n        }\n    }\n}",
        "public class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n        while (curr != null || !stack.isEmpty()) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            res.add(curr.val);\n            curr = curr.right;\n        }\n        return res;\n    }\n}",
        "class Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        TreeNode curr = root;\n        TreeNode pre;\n        while (curr != null) {\n            if (curr.left == null) {\n                res.add(curr.val);\n                curr = curr.right; // move to next right node\n            } else { // has a left subtree\n                pre = curr.left;\n                while (pre.right != null) { // find rightmost\n                    pre = pre.right;\n                }\n                pre.right = curr; // put cur after the pre node\n                TreeNode temp = curr; // store cur node\n                curr = curr.left; // move cur to the top of the new tree\n                temp.left = null; // original cur left be null, avoid infinite loops\n            }\n        }\n        return res;\n    }\n}"
      ]
    },
    {
      "number": 20,
      "question": "Can you solve this real interview question? Unique Binary Search Trees II - Given an integer n, return all the structurally unique BST's (binary search trees), which has exactly n nodes of unique values from 1 to n. Return the answer in any order.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/01/18/uniquebstn3.jpg]\n\n\nInput: n = 3\nOutput: [[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]\n\n\nExample 2:\n\n\nInput: n = 1\nOutput: [[1]]\n\n\n \n\nConstraints:\n\n * 1 <= n <= 8",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<TreeNode*> allPossibleBST(int start, int end, map<pair<int, int>, vector<TreeNode*>>& memo) {\n        vector<TreeNode*> res;\n        if (start > end) {\n            res.push_back(nullptr);\n            return res;\n        }\n        if (memo.find(make_pair(start, end)) != memo.end()) {\n            return memo[make_pair(start, end)];\n        }\n        // Iterate through all values from start to end to construct left and right subtrees recursively.\n        for (int i = start; i <= end; ++i) {\n            vector<TreeNode*> leftSubTrees = allPossibleBST(start, i - 1, memo);\n            vector<TreeNode*> rightSubTrees = allPossibleBST(i + 1, end, memo);\n\n            // Loop through all left and right subtrees and connect them to the ith root.\n            for (auto left: leftSubTrees) {\n                for (auto right: rightSubTrees) {\n                    TreeNode* root = new TreeNode(i, left, right);\n                    res.push_back(root);\n                }\n            }\n        }\n        return memo[make_pair(start, end)] = res;\n    }\n\n    vector<TreeNode*> generateTrees(int n) {\n        map<pair<int, int>, vector<TreeNode*>> memo;\n        return allPossibleBST(1, n, memo);\n    }\n};",
        "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        vector<vector<vector<TreeNode*>>> dp(n + 1, vector(n + 1, vector<TreeNode*>(0)));\n        for (int i = 1; i <= n; i++) {\n            dp[i][i].push_back(new TreeNode(i));\n        }\n\n        for (int numberOfNodes = 2; numberOfNodes <= n; numberOfNodes++) {\n            for (int start = 1; start <= n - numberOfNodes + 1; start++) {\n                int end = start + numberOfNodes - 1;\n                for (int i = start; i <= end; i++) {\n                    vector<TreeNode*> leftSubtrees =\n                        i - 1 >= start ? dp[start][i - 1] : vector<TreeNode*>({NULL});\n                    vector<TreeNode*> rightSubtrees =\n                        i + 1 <= end ? dp[i + 1][end] : vector<TreeNode*>({NULL});\n\n                    for (auto left : leftSubtrees) {\n                        for (auto right : rightSubtrees) {\n                            TreeNode* root = new TreeNode(i, left, right);\n                            dp[start][end].push_back(root);\n                        }\n                    }\n                }\n            }\n        }\n        return dp[1][n];\n    }\n};",
        "class Solution {\npublic:\n    vector<TreeNode*> generateTrees(int n) {\n        vector<vector<TreeNode*>> dp(n + 1);\n        dp[0].push_back(NULL);\n\n        for (int numberOfNodes = 1; numberOfNodes <= n; numberOfNodes ++) {\n            for (int i = 1; i <= numberOfNodes; i ++) {\n                int j = numberOfNodes - i;\n                for (auto left : dp[i - 1]) {\n                    for (auto right : dp[j]) {\n                        TreeNode* root = new TreeNode(i, left, clone(right, i));\n                        dp[numberOfNodes].push_back(root);\n                    }\n                }\n            }\n        }\n        return dp[n];\n    }\n\nprivate:\n    TreeNode* clone(TreeNode* node, int offset) {\n        if (node == NULL) {\n            return NULL;\n        }\n        TreeNode* clonedNode = new TreeNode(node->val + offset);\n        clonedNode->left = clone(node->left, offset);\n        clonedNode->right = clone(node->right, offset);\n        return clonedNode;\n    }\n};"
      ]
    },
    {
      "number": 21,
      "question": "Can you solve this real interview question? Word Break - Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n \n\nExample 1:\n\n\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\n\n\nExample 2:\n\n\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\n\n\nExample 3:\n\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 300\n * 1 <= wordDict.length <= 1000\n * 1 <= wordDict[i].length <= 20\n * s and wordDict[i] consist of only lowercase English letters.\n * All the strings of wordDict are unique.",
      "code": "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        unordered_set<string> words(wordDict.begin(), wordDict.end());\n        queue<int> queue;\n        vector<bool> seen(s.length(), false);\n        queue.push(0);\n        \n        while (!queue.empty()) {\n            int start = queue.front();\n            queue.pop();\n            \n            if (start == s.length()) {\n                return true;\n            }\n            \n            for (int end = start + 1; end <= s.length(); end++) {\n                if (seen[end]) {\n                    continue;\n                }\n\n                if (words.find(s.substr(start, end - start)) != words.end()) {\n                    queue.push(end);\n                    seen[end] = true;\n                }\n            }\n        }\n        \n        return false;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> memo;\n    vector<string> wordDict;\n    string s;\n    \n    bool wordBreak(string s, vector<string>& wordDict) {\n        memo = vector(s.length(), -1);\n        this->wordDict = wordDict;\n        this->s = s;\n        return dp(s.length() - 1);\n    }\n    \n    bool dp(int i) {\n        if (i < 0) return true;\n        \n        if (memo[i] != -1) {\n            return memo[i] == 1;\n        }\n        \n        for (string word: wordDict) {\n            int currSize = word.length();\n            // Handle out of bounds case\n            if (i - currSize + 1 < 0) {\n                continue;\n            }\n\n            if (s.substr(i - currSize + 1, currSize) == word && dp(i - currSize)) {\n                memo[i] = 1;\n                return true;\n            }\n        }\n        \n        memo[i] = 0;\n        return false;\n    }\n};",
        "class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        vector<bool> dp(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            for (string word: wordDict) {\n                // Handle out of bounds case\n                if (i < word.length() - 1) {\n                    continue;\n                }\n                \n                if (i == word.length() - 1 || dp[i - word.length()]) {\n                    if (s.substr(i - word.length() + 1, word.length()) == word) {\n                        dp[i] = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return dp[s.length() - 1];\n    }\n};",
        "struct TrieNode {\n    bool isWord;\n    unordered_map<char, TrieNode*> children;\n    TrieNode() : isWord(false), children(unordered_map<char, TrieNode*>()) {}\n};\n\nclass Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        TrieNode* root = new TrieNode();\n        for (string word: wordDict) {\n            TrieNode* curr = root;\n            for (char c: word) {\n                if (curr->children.find(c) == curr->children.end()) {\n                    curr->children[c] = new TrieNode();\n                }\n                curr = curr->children[c];\n            }\n            \n            curr->isWord = true;\n        }\n        \n        vector<bool> dp(s.length());\n        for (int i = 0; i < s.length(); i++) {\n            if (i == 0 || dp[i - 1]) {\n                TrieNode* curr = root;\n                for (int j = i; j < s.length(); j++) {\n                    char c = s[j];\n                    if (curr->children.find(c) == curr->children.end()) {\n                        // No words exist\n                        break;\n                    }\n                    \n                    curr = curr->children[c];\n                    if (curr->isWord) {\n                        dp[j] = true;\n                    }\n                }\n            }\n        }\n        \n        return dp[s.length() - 1];\n    }\n};",
        "class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        int n = s.length();\n        Set<String> words = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n        \n        for (int i = 1; i <= n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (dp[j] && words.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n        \n        return dp[n];\n    }\n}"
      ]
    },
    {
      "number": 22,
      "question": "Can you solve this real interview question? Insertion Sort List - Given the head of a singly linked list, sort the list using insertion sort, and return the sorted list's head.\n\nThe steps of the insertion sort algorithm:\n\n 1. Insertion sort iterates, consuming one input element each repetition and growing a sorted output list.\n 2. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list and inserts it there.\n 3. It repeats until no input elements remain.\n\nThe following is a graphical example of the insertion sort algorithm. The partially sorted list (black) initially contains only the first element in the list. One element (red) is removed from the input data and inserted in-place into the sorted list with each iteration.\n\n[https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif]\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/03/04/sort1linked-list.jpg]\n\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/03/04/sort2linked-list.jpg]\n\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\n\n \n\nConstraints:\n\n * The number of nodes in the list is in the range [1, 5000].\n * -5000 <= Node.val <= 5000",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* insertionSortList(ListNode* head) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        ListNode dummy = new ListNode();\n        ListNode curr = head;\n\n        while (curr != null) {\n            // At each iteration, we insert an element into the resulting list.\n            ListNode prev = dummy;\n\n            // find the position to insert the current node\n            while (prev.next != null && prev.next.val <= curr.val) {\n                prev = prev.next;\n            }\n\n            ListNode next = curr.next;\n            // insert the current node to the new list\n            curr.next = prev.next;\n            prev.next = curr;\n\n            // moving on to the next iteration\n            curr = next;\n        }\n\n        return dummy.next;\n    }\n}"
      ]
    },
    {
      "number": 23,
      "question": "Can you solve this real interview question? Excel Sheet Column Title - Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\n\nFor example:\n\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n\n\n \n\nExample 1:\n\n\nInput: columnNumber = 1\nOutput: \"A\"\n\n\nExample 2:\n\n\nInput: columnNumber = 28\nOutput: \"AB\"\n\n\nExample 3:\n\n\nInput: columnNumber = 701\nOutput: \"ZY\"\n\n\n \n\nConstraints:\n\n * 1 <= columnNumber <= 231 - 1",
      "code": "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    string convertToTitle(int columnNumber) {\n        string ans;\n        \n        while (columnNumber) {\n            columnNumber--;\n            // Get the last character and append it at the end of string.\n            ans = ans + (char)((columnNumber) % 26 + 'A');\n            columnNumber = (columnNumber) / 26;\n        }\n        \n        // Reverse it, as we appended characters in reverse order.\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 24,
      "question": "Can you solve this real interview question? Combine Two Tables - Table: Person\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| personId    | int     |\n| lastName    | varchar |\n| firstName   | varchar |\n+-------------+---------+\npersonId is the primary key (column with unique values) for this table.\nThis table contains information about the ID of some persons and their first and last names.\n\n\n \n\nTable: Address\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| addressId   | int     |\n| personId    | int     |\n| city        | varchar |\n| state       | varchar |\n+-------------+---------+\naddressId is the primary key (column with unique values) for this table.\nEach row of this table contains information about the city and state of one person with ID = PersonId.\n\n\n \n\nWrite a solution to report the first name, last name, city, and state of each person in the Person table. If the address of a personId is not present in the Address table, report null instead.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nPerson table:\n+----------+----------+-----------+\n| personId | lastName | firstName |\n+----------+----------+-----------+\n| 1        | Wang     | Allen     |\n| 2        | Alice    | Bob       |\n+----------+----------+-----------+\nAddress table:\n+-----------+----------+---------------+------------+\n| addressId | personId | city          | state      |\n+-----------+----------+---------------+------------+\n| 1         | 2        | New York City | New York   |\n| 2         | 3        | Leetcode      | California |\n+-----------+----------+---------------+------------+\nOutput: \n+-----------+----------+---------------+----------+\n| firstName | lastName | city          | state    |\n+-----------+----------+---------------+----------+\n| Allen     | Wang     | Null          | Null     |\n| Bob       | Alice    | New York City | New York |\n+-----------+----------+---------------+----------+\nExplanation: \nThere is no address in the address table for the personId = 1 so we return null in their city and state.\naddressId = 1 contains information about the address of personId = 2.\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef combine_two_tables(person: pd.DataFrame, address: pd.DataFrame) -> pd.DataFrame:\n    result = pd.merge(person, address, on='personId', how='left')\n    result = result[['firstName', 'lastName', 'city', 'state']]\n    return result\n"
      ]
    },
    {
      "number": 25,
      "question": "Can you solve this real interview question? Largest Number - Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n \n\nExample 1:\n\n\nInput: nums = [10,2]\nOutput: \"210\"\n\n\nExample 2:\n\n\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 109",
      "code": "class Solution {\npublic:\n    string largestNumber(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    private class LargerNumberComparator implements Comparator<String> {\n        @Override\n        public int compare(String a, String b) {\n            String order1 = a + b;\n            String order2 = b + a;\n           return order2.compareTo(order1);\n        }\n    }\n\n    public String largestNumber(int[] nums) {\n        // Get input integers as strings.\n        String[] asStrs = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            asStrs[i] = String.valueOf(nums[i]);\n        }\n\n        // Sort strings according to custom comparator.\n        Arrays.sort(asStrs, new LargerNumberComparator());\n\n        // If, after being sorted, the largest number is `0`, the entire number\n        // is zero.\n        if (asStrs[0].equals(\"0\")) {\n            return \"0\";\n        }\n\n        // Build largest number from sorted array.\n        String largestNumberStr = new String();\n        for (String numAsStr : asStrs) {\n            largestNumberStr += numAsStr;\n        }\n\n        return largestNumberStr;\n    }\n}"
      ]
    },
    {
      "number": 26,
      "question": "Can you solve this real interview question? Department Top Three Salaries - Table: Employee\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| id           | int     |\n| name         | varchar |\n| salary       | int     |\n| departmentId | int     |\n+--------------+---------+\nid is the primary key (column with unique values) for this table.\ndepartmentId is a foreign key (reference column) of the ID from the Department table.\nEach row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.\n\n\n \n\nTable: Department\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| name        | varchar |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table indicates the ID of a department and its name.\n\n\n \n\nA company's executives are interested in seeing who earns the most money in each of the company's departments. A high earner in a department is an employee who has a salary in the top three unique salaries for that department.\n\nWrite a solution to find the employees who are high earners in each of the departments.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nEmployee table:\n+----+-------+--------+--------------+\n| id | name  | salary | departmentId |\n+----+-------+--------+--------------+\n| 1  | Joe   | 85000  | 1            |\n| 2  | Henry | 80000  | 2            |\n| 3  | Sam   | 60000  | 2            |\n| 4  | Max   | 90000  | 1            |\n| 5  | Janet | 69000  | 1            |\n| 6  | Randy | 85000  | 1            |\n| 7  | Will  | 70000  | 1            |\n+----+-------+--------+--------------+\nDepartment table:\n+----+-------+\n| id | name  |\n+----+-------+\n| 1  | IT    |\n| 2  | Sales |\n+----+-------+\nOutput: \n+------------+----------+--------+\n| Department | Employee | Salary |\n+------------+----------+--------+\n| IT         | Max      | 90000  |\n| IT         | Joe      | 85000  |\n| IT         | Randy    | 85000  |\n| IT         | Will     | 70000  |\n| Sales      | Henry    | 80000  |\n| Sales      | Sam      | 60000  |\n+------------+----------+--------+\nExplanation: \nIn the IT department:\n- Max earns the highest unique salary\n- Both Randy and Joe earn the second-highest unique salary\n- Will earns the third-highest unique salary\n\nIn the Sales department:\n- Henry earns the highest salary\n- Sam earns the second-highest salary\n- There is no third-highest salary as there are only two employees\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\n    \n    Employee_Department = employee.merge(department, left_on='departmentId', right_on='id').rename(columns = {'name_y': 'Department'})\n\n    Employee_Department = Employee_Department[['Department', 'departmentId', 'salary']].drop_duplicates()\n    \n    top_salary = Employee_Department.groupby(['Department', 'departmentId']).salary.nlargest(3).reset_index()\n    \n    df = top_salary.merge(employee, on=['departmentId', 'salary'])\n    \n    return df[['Department', 'name', 'salary']].rename(columns = {'name': 'Employee', 'salary': 'Salary'})",
        "import pandas as pd\n\ndef top_three_salaries(employee: pd.DataFrame, department: pd.DataFrame) -> pd.DataFrame:\n\n    top_salary = employee[employee.groupby('departmentId').salary.rank(method='dense', ascending=False) <= 3]\n\n    employee_department = top_salary.merge(department, left_on='departmentId', right_on='id')[['name_y', 'name_x', 'salary']]\n\n    return employee_department.rename(columns = {'name_y': 'Department', 'name_x': 'Employee', 'salary': 'Salary'})"
      ]
    },
    {
      "number": 27,
      "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
      "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
      ]
    },
    {
      "number": 28,
      "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
      "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 29,
      "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
      ]
    },
    {
      "number": 30,
      "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
      ]
    },
    {
      "number": 31,
      "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
      "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
      ]
    },
    {
      "number": 32,
      "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
      "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
      ]
    },
    {
      "number": 33,
      "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
      "solution": [
        "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
        "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
      ]
    },
    {
      "number": 34,
      "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
        "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
      ]
    },
    {
      "number": 35,
      "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
      ]
    },
    {
      "number": 36,
      "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
      "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
      ]
    },
    {
      "number": 37,
      "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
      ]
    },
    {
      "number": 38,
      "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
      "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
        "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 39,
      "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
      "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
      ]
    },
    {
      "number": 40,
      "question": "Can you solve this real interview question? Trips and Users - Table: Trips\n\n\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| id          | int      |\n| client_id   | int      |\n| driver_id   | int      |\n| city_id     | int      |\n| status      | enum     |\n| request_at  | date     |     \n+-------------+----------+\nid is the primary key (column with unique values) for this table.\nThe table holds all taxi trips. Each trip has a unique id, while client_id and driver_id are foreign keys to the users_id at the Users table.\nStatus is an ENUM (category) type of ('completed', 'cancelled_by_driver', 'cancelled_by_client').\n\n\n \n\nTable: Users\n\n\n+-------------+----------+\n| Column Name | Type     |\n+-------------+----------+\n| users_id    | int      |\n| banned      | enum     |\n| role        | enum     |\n+-------------+----------+\nusers_id is the primary key (column with unique values) for this table.\nThe table holds all users. Each user has a unique users_id, and role is an ENUM type of ('client', 'driver', 'partner').\nbanned is an ENUM (category) type of ('Yes', 'No').\n\n\n \n\nThe cancellation rate is computed by dividing the number of canceled (by client or driver) requests with unbanned users by the total number of requests with unbanned users on that day.\n\nWrite a solution to find the cancellation rate of requests with unbanned users (both client and driver must not be banned) each day between \"2013-10-01\" and \"2013-10-03\". Round Cancellation Rate to two decimal points.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nTrips table:\n+----+-----------+-----------+---------+---------------------+------------+\n| id | client_id | driver_id | city_id | status              | request_at |\n+----+-----------+-----------+---------+---------------------+------------+\n| 1  | 1         | 10        | 1       | completed           | 2013-10-01 |\n| 2  | 2         | 11        | 1       | cancelled_by_driver | 2013-10-01 |\n| 3  | 3         | 12        | 6       | completed           | 2013-10-01 |\n| 4  | 4         | 13        | 6       | cancelled_by_client | 2013-10-01 |\n| 5  | 1         | 10        | 1       | completed           | 2013-10-02 |\n| 6  | 2         | 11        | 6       | completed           | 2013-10-02 |\n| 7  | 3         | 12        | 6       | completed           | 2013-10-02 |\n| 8  | 2         | 12        | 12      | completed           | 2013-10-03 |\n| 9  | 3         | 10        | 12      | completed           | 2013-10-03 |\n| 10 | 4         | 13        | 12      | cancelled_by_driver | 2013-10-03 |\n+----+-----------+-----------+---------+---------------------+------------+\nUsers table:\n+----------+--------+--------+\n| users_id | banned | role   |\n+----------+--------+--------+\n| 1        | No     | client |\n| 2        | Yes    | client |\n| 3        | No     | client |\n| 4        | No     | client |\n| 10       | No     | driver |\n| 11       | No     | driver |\n| 12       | No     | driver |\n| 13       | No     | driver |\n+----------+--------+--------+\nOutput: \n+------------+-------------------+\n| Day        | Cancellation Rate |\n+------------+-------------------+\n| 2013-10-01 | 0.33              |\n| 2013-10-02 | 0.00              |\n| 2013-10-03 | 0.50              |\n+------------+-------------------+\nExplanation: \nOn 2013-10-01:\n  - There were 4 requests in total, 2 of which were canceled.\n  - However, the request with Id=2 was made by a banned client (User_Id=2), so it is ignored in the calculation.\n  - Hence there are 3 unbanned requests in total, 1 of which was canceled.\n  - The Cancellation Rate is (1 / 3) = 0.33\nOn 2013-10-02:\n  - There were 3 requests in total, 0 of which were canceled.\n  - The request with Id=6 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned requests in total, 0 of which were canceled.\n  - The Cancellation Rate is (0 / 2) = 0.00\nOn 2013-10-03:\n  - There were 3 requests in total, 1 of which was canceled.\n  - The request with Id=8 was made by a banned client, so it is ignored.\n  - Hence there are 2 unbanned request in total, 1 of which were canceled.\n  - The Cancellation Rate is (1 / 2) = 0.50\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef trips_and_users(trips: pd.DataFrame, users: pd.DataFrame) -> pd.DataFrame:\n\n    # Step 1: Preliminary Check\n    if trips.empty or users.empty:\n        return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"])\n\n    # Step 2: Prepare Data for Client Merge\n    renamed_users_for_clients = users.rename(\n        columns={\"users_id\": \"client_id\", \"banned\": \"client_banned\"}\n    )\n\n    # Step 3: Client Merge\n    trips_with_clients = trips.merge(\n        renamed_users_for_clients, on=\"client_id\", how=\"left\"\n    )\n\n    # Step 4: Prepare Data for Driver Merge\n    renamed_users_for_drivers = users.rename(\n        columns={\"users_id\": \"driver_id\", \"banned\": \"driver_banned\"}\n    )\n\n    # Step 5: Driver Merge\n    full_trips = trips_with_clients.merge(\n        renamed_users_for_drivers, on=\"driver_id\", how=\"left\"\n    )\n\n    # Step 6: Filtering\n    filtered_trips = full_trips[\n        (full_trips[\"client_banned\"] == \"No\")\n        & (full_trips[\"driver_banned\"] == \"No\")\n        & (full_trips[\"request_at\"].between(\"2013-10-01\", \"2013-10-03\"))\n    ]\n\n    # Step 7: Calculate Cancellation Rate\n    result = filtered_trips.groupby(\"request_at\").apply(\n        lambda group: pd.Series(\n            {\n                \"Cancellation Rate\": round(\n                    (group[\"status\"] != \"completed\").sum() / len(group), 2\n                )\n            }\n        )\n    )\n\n    # Step 8: Result Presentation\n    if result.empty:\n        return pd.DataFrame(columns=[\"Day\", \"Cancellation Rate\"])\n    else:\n        return result.reset_index().rename(columns={\"request_at\": \"Day\"})"
      ]
    },
    {
      "number": 41,
      "question": "Can you solve this real interview question? Expression Add Operators - Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\n\nNote that operands in the returned expressions should not contain leading zeros.\n\n \n\nExample 1:\n\n\nInput: num = \"123\", target = 6\nOutput: [\"1*2*3\",\"1+2+3\"]\nExplanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6.\n\n\nExample 2:\n\n\nInput: num = \"232\", target = 8\nOutput: [\"2*3+2\",\"2+3*2\"]\nExplanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8.\n\n\nExample 3:\n\n\nInput: num = \"3456237490\", target = 9191\nOutput: []\nExplanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191.\n\n\n \n\nConstraints:\n\n * 1 <= num.length <= 10\n * num consists of only digits.\n * -231 <= target <= 231 - 1",
      "code": "class Solution {\npublic:\n    vector<string> addOperators(string num, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n  public ArrayList<String> answer;\n  public String digits;\n  public long target;\n\n  public void recurse(\n      int index, long previousOperand, long currentOperand, long value, ArrayList<String> ops) {\n    String nums = this.digits;\n\n    // Done processing all the digits in num\n    if (index == nums.length()) {\n\n      // If the final value == target expected AND\n      // no operand is left unprocessed\n      if (value == this.target && currentOperand == 0) {\n        StringBuilder sb = new StringBuilder();\n        ops.subList(1, ops.size()).forEach(v -> sb.append(v));\n        this.answer.add(sb.toString());\n      }\n      return;\n    }\n\n    // Extending the current operand by one digit\n    currentOperand = currentOperand * 10 + Character.getNumericValue(nums.charAt(index));\n    String current_val_rep = Long.toString(currentOperand);\n    int length = nums.length();\n\n    // To avoid cases where we have 1 + 05 or 1 * 05 since 05 won't be a\n    // valid operand. Hence this check\n    if (currentOperand > 0) {\n\n      // NO OP recursion\n      recurse(index + 1, previousOperand, currentOperand, value, ops);\n    }\n\n    // ADDITION\n    ops.add(\"+\");\n    ops.add(current_val_rep);\n    recurse(index + 1, currentOperand, 0, value + currentOperand, ops);\n    ops.remove(ops.size() - 1);\n    ops.remove(ops.size() - 1);\n\n    if (ops.size() > 0) {\n\n      // SUBTRACTION\n      ops.add(\"-\");\n      ops.add(current_val_rep);\n      recurse(index + 1, -currentOperand, 0, value - currentOperand, ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n\n      // MULTIPLICATION\n      ops.add(\"*\");\n      ops.add(current_val_rep);\n      recurse(\n          index + 1,\n          currentOperand * previousOperand,\n          0,\n          value - previousOperand + (currentOperand * previousOperand),\n          ops);\n      ops.remove(ops.size() - 1);\n      ops.remove(ops.size() - 1);\n    }\n  }\n\n  public List<String> addOperators(String num, int target) {\n\n    if (num.length() == 0) {\n      return new ArrayList<String>();\n    }\n\n    this.target = target;\n    this.digits = num;\n    this.answer = new ArrayList<String>();\n    this.recurse(0, 0, 0, 0, new ArrayList<String>());\n    return this.answer;\n  }\n}"
      ]
    },
    {
      "number": 42,
      "question": "Can you solve this real interview question? Move Zeroes - Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\n \n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n\n\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * -231 <= nums[i] <= 231 - 1\n\n \n\nFollow up: Could you minimize the total number of operations done?",
      "code": "class Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "void moveZeroes(vector<int>& nums) {\n    int n = nums.size();\n\n    // Count the zeroes\n    int numZeroes = 0;\n    for (int i = 0; i < n; i++) {\n        numZeroes += (nums[i] == 0);\n    }\n\n    // Make all the non-zero elements retain their original order.\n    vector<int> ans;\n    for (int i = 0; i < n; i++) {\n        if (nums[i] != 0) {\n            ans.push_back(nums[i]);\n        }\n    }\n\n    // Move all zeroes to the end\n    while (numZeroes--) {\n        ans.push_back(0);\n    }\n\n    // Combine the result\n    for (int i = 0; i < n; i++) {\n        nums[i] = ans[i];\n    }\n}",
        "void moveZeroes(vector<int>& nums) {\n    int lastNonZeroFoundAt = 0;\n    // If the current element is not 0, then we need to\n    // append it just in front of last non 0 element we found.\n    for (int i = 0; i < nums.size(); i++) {\n        if (nums[i] != 0) {\n            nums[lastNonZeroFoundAt++] = nums[i];\n        }\n    }\n \t// After we have finished processing new elements,\n \t// all the non-zero elements are already at beginning of array.\n \t// We just need to fill remaining array with 0's.\n    for (int i = lastNonZeroFoundAt; i < nums.size(); i++) {\n        nums[i] = 0;\n    }\n}",
        "void moveZeroes(vector<int>& nums) {\n    for (int lastNonZeroFoundAt = 0, cur = 0; cur < nums.size(); cur++) {\n        if (nums[cur] != 0) {\n            swap(nums[lastNonZeroFoundAt++], nums[cur]);\n        }\n    }\n}"
      ]
    },
    {
      "number": 43,
      "question": "Can you solve this real interview question? Remove Invalid Parentheses - Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\n\n\nExample 2:\n\n\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\n\n\nExample 3:\n\n\nInput: s = \")(\"\nOutput: [\"\"]\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 25\n * s consists of lowercase English letters and parentheses '(' and ')'.\n * There will be at most 20 parentheses in s.",
      "code": "class Solution {\npublic:\n    vector<string> removeInvalidParentheses(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n  private Set<String> validExpressions = new HashSet<String>();\n  private int minimumRemoved;\n\n  private void reset() {\n    this.validExpressions.clear();\n    this.minimumRemoved = Integer.MAX_VALUE;\n  }\n\n  private void recurse(\n      String s,\n      int index,\n      int leftCount,\n      int rightCount,\n      StringBuilder expression,\n      int removedCount) {\n\n    // If we have reached the end of string.\n    if (index == s.length()) {\n\n      // If the current expression is valid.\n      if (leftCount == rightCount) {\n\n        // If the current count of removed parentheses is <= the current minimum count\n        if (removedCount <= this.minimumRemoved) {\n\n          // Convert StringBuilder to a String. This is an expensive operation.\n          // So we only perform this when needed.\n          String possibleAnswer = expression.toString();\n\n          // If the current count beats the overall minimum we have till now\n          if (removedCount < this.minimumRemoved) {\n            this.validExpressions.clear();\n            this.minimumRemoved = removedCount;\n          }\n          this.validExpressions.add(possibleAnswer);\n        }\n      }\n    } else {\n\n      char currentCharacter = s.charAt(index);\n      int length = expression.length();\n\n      // If the current character is neither an opening bracket nor a closing one,\n      // simply recurse further by adding it to the expression StringBuilder\n      if (currentCharacter != '(' && currentCharacter != ')') {\n        expression.append(currentCharacter);\n        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount);\n        expression.deleteCharAt(length);\n      } else {\n\n        // Recursion where we delete the current character and move forward\n        this.recurse(s, index + 1, leftCount, rightCount, expression, removedCount + 1);\n        expression.append(currentCharacter);\n\n        // If it's an opening parenthesis, consider it and recurse\n        if (currentCharacter == '(') {\n          this.recurse(s, index + 1, leftCount + 1, rightCount, expression, removedCount);\n        } else if (rightCount < leftCount) {\n          // For a closing parenthesis, only recurse if right < left\n          this.recurse(s, index + 1, leftCount, rightCount + 1, expression, removedCount);\n        }\n\n        // Undoing the append operation for other recursions.\n        expression.deleteCharAt(length);\n      }\n    }\n  }\n\n  public List<String> removeInvalidParentheses(String s) {\n\n    this.reset();\n    this.recurse(s, 0, 0, 0, new StringBuilder(), 0);\n    return new ArrayList(this.validExpressions);\n  }\n}",
        "class Solution {\n\n  private Set<String> validExpressions = new HashSet<String>();\n\n  private void recurse(\n      String s,\n      int index,\n      int leftCount,\n      int rightCount,\n      int leftRem,\n      int rightRem,\n      StringBuilder expression) {\n\n    // If we reached the end of the string, just check if the resulting expression is\n    // valid or not and also if we have removed the total number of left and right\n    // parentheses that we should have removed.\n    if (index == s.length()) {\n      if (leftRem == 0 && rightRem == 0) {\n        this.validExpressions.add(expression.toString());\n      }\n\n    } else {\n      char character = s.charAt(index);\n      int length = expression.length();\n\n      // The discard case. Note that here we have our pruning condition.\n      // We don't recurse if the remaining count for that parenthesis is == 0.\n      if ((character == '(' && leftRem > 0) || (character == ')' && rightRem > 0)) {\n        this.recurse(\n            s,\n            index + 1,\n            leftCount,\n            rightCount,\n            leftRem - (character == '(' ? 1 : 0),\n            rightRem - (character == ')' ? 1 : 0),\n            expression);\n      }\n\n      expression.append(character);\n\n      // Simply recurse one step further if the current character is not a parenthesis.\n      if (character != '(' && character != ')') {\n\n        this.recurse(s, index + 1, leftCount, rightCount, leftRem, rightRem, expression);\n\n      } else if (character == '(') {\n\n        // Consider an opening bracket.\n        this.recurse(s, index + 1, leftCount + 1, rightCount, leftRem, rightRem, expression);\n\n      } else if (rightCount < leftCount) {\n\n        // Consider a closing bracket.\n        this.recurse(s, index + 1, leftCount, rightCount + 1, leftRem, rightRem, expression);\n      }\n\n      // Delete for backtracking.\n      expression.deleteCharAt(length);\n    }\n  }\n\n  public List<String> removeInvalidParentheses(String s) {\n\n    int left = 0, right = 0;\n\n    // First, we find out the number of misplaced left and right parentheses.\n    for (int i = 0; i < s.length(); i++) {\n\n      // Simply record the left one.\n      if (s.charAt(i) == '(') {\n        left++;\n      } else if (s.charAt(i) == ')') {\n        // If we don't have a matching left, then this is a misplaced right, record it.\n        right = left == 0 ? right + 1 : right;\n\n        // Decrement count of left parentheses because we have found a right\n        // which CAN be a matching one for a left.\n        left = left > 0 ? left - 1 : left;\n      }\n    }\n\n    this.recurse(s, 0, 0, 0, left, right, new StringBuilder());\n    return new ArrayList<String>(this.validExpressions);\n  }\n}"
      ]
    },
    {
      "number": 44,
      "question": "Can you solve this real interview question? Bulb Switcher - There are n bulbs that are initially off. You first turn on all the bulbs, then you turn off every second bulb.\n\nOn the third round, you toggle every third bulb (turning on if it's off or turning off if it's on). For the ith round, you toggle every i bulb. For the nth round, you only toggle the last bulb.\n\nReturn the number of bulbs that are on after n rounds.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/11/05/bulb.jpg]\n\n\nInput: n = 3\nOutput: 1\nExplanation: At first, the three bulbs are [off, off, off].\nAfter the first round, the three bulbs are [on, on, on].\nAfter the second round, the three bulbs are [on, off, on].\nAfter the third round, the three bulbs are [on, off, off]. \nSo you should return 1 because there is only one bulb is on.\n\nExample 2:\n\n\nInput: n = 0\nOutput: 0\n\n\nExample 3:\n\n\nInput: n = 1\nOutput: 1\n\n\n \n\nConstraints:\n\n * 0 <= n <= 109",
      "code": "class Solution {\npublic:\n    int bulbSwitch(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int bulbSwitch(int n) {\n        return sqrt(n);\n    }\n};"
      ]
    },
    {
      "number": 45,
      "question": "Can you solve this real interview question? Top K Frequent Elements - Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n\n\nExample 2:\n\nInput: nums = [1], k = 1\nOutput: [1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * -104 <= nums[i] <= 104\n * k is in the range [1, the number of unique elements in the array].\n * It is guaranteed that the answer is unique.\n\n \n\nFollow up: Your algorithm's time complexity must be better than O(n log n), where n is the array's size.",
      "code": "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        // O(1) time\n        if (k == nums.size()) {\n            return nums;\n        }\n\n        // 1. build hash map : element and how often it appears\n        // O(N) time\n        map<int, int> count_map;\n        for (int n : nums) {\n            count_map[n] += 1;\n        }\n\n        // initialise a heap with most frequent elements at the top\n        auto comp = [&count_map](int n1, int n2) { return count_map[n1] > count_map[n2]; };\n        priority_queue<int, vector<int>, decltype(comp)> heap(comp);\n\n        // 2. keep k top fequent elements in the heap\n        // O(N log k) < O(N log N) time\n        for (pair<int, int> p : count_map) {\n            heap.push(p.first);\n            if (heap.size() > k) heap.pop();\n        }\n\n        // 3. build an output array\n        // O(k log k) time\n        vector<int> top(k);\n        for (int i = k - 1; i >= 0; i--) {\n            top[i] = heap.top();\n            heap.pop();\n        }\n        return top;\n    }\n};",
        "int partition(int left, int right, int pivot_index) {\n    int pivot_frequency = count_map[unique[pivot_index]];\n    // 1. move pivot to the end\n    swap(unique[pivot_index], unique[right]);\n\n    // 2. move all less frequent elements to the left\n    int store_index = left;\n    for (int i = left; i <= right; i++) {\n        if (count_map[unique[i]] < pivot_frequency) {\n            swap(unique[store_index], unique[i]);\n            store_index += 1;\n        }\n    }\n\n    // 3. move pivot to its final place\n    swap(unique[right], unique[store_index]);\n\n    return store_index;\n}",
        "class Solution {\nprivate:\n    vector<int> unique;\n    map<int, int> count_map;\n\npublic:\n    int partition(int left, int right, int pivot_index) {\n        int pivot_frequency = count_map[unique[pivot_index]];\n        // 1. move pivot to the end\n        swap(unique[pivot_index], unique[right]);\n\n        // 2. move all less frequent elements to the left\n        int store_index = left;\n        for (int i = left; i <= right; i++) {\n            if (count_map[unique[i]] < pivot_frequency) {\n                swap(unique[store_index], unique[i]);\n                store_index += 1;\n            }\n        }\n\n        // 3. move pivot to its final place\n        swap(unique[right], unique[store_index]);\n\n        return store_index;\n    }\n\n    void quickselect(int left, int right, int k_smallest) {\n        /*\n        Sort a list within left..right till kth less frequent element\n        takes its place. \n        */\n\n        // base case: the list contains only one element\n        if (left == right) return;\n\n        int pivot_index = left + rand() % (right - left + 1);\n\n        // find the pivot position in a sorted list\n        pivot_index = partition(left, right, pivot_index);\n\n        // if the pivot is in its final sorted position\n        if (k_smallest == pivot_index) {\n            return;\n        } else if (k_smallest < pivot_index) {\n            // go left\n            quickselect(left, pivot_index - 1, k_smallest);\n        } else {\n            // go right\n            quickselect(pivot_index + 1, right, k_smallest);\n        }\n    }\n\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        // build hash map : element and how often it appears\n        for (int n : nums) {\n            count_map[n] += 1;\n        }\n\n        // array of unique elements\n        int n = count_map.size();\n        for (pair<int, int> p : count_map) {\n            unique.push_back(p.first);\n        }\n\n        // kth top frequent element is (n - k)th less frequent.\n        // Do a partial sort: from less frequent to the most frequent, till\n        // (n - k)th less frequent element takes its place (n - k) in a sorted array.\n        // All element on the left are less frequent.\n        // All the elements on the right are more frequent.\n        quickselect(0, n - 1, n - k);\n        // Return top k frequent elements\n        vector<int> top_k_frequent(k);\n        copy(unique.begin() + n - k, unique.end(), top_k_frequent.begin());\n        return top_k_frequent;\n    }\n};"
      ]
    },
    {
      "number": 46,
      "question": "Can you solve this real interview question? Intersection of Two Arrays - Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n\n\nExample 2:\n\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.\n\n\n \n\nConstraints:\n\n * 1 <= nums1.length, nums2.length <= 1000\n * 0 <= nums1[i], nums2[i] <= 1000",
      "code": "class Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n  public int[] set_intersection(HashSet<Integer> set1, HashSet<Integer> set2) {\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (Integer s : set1)\n      if (set2.contains(s)) output[idx++] = s;\n\n    return Arrays.copyOf(output, idx);\n  }\n\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n\n    if (set1.size() < set2.size()) return set_intersection(set1, set2);\n    else return set_intersection(set2, set1);\n  }\n}",
        "class Solution {\n  public int[] intersection(int[] nums1, int[] nums2) {\n    HashSet<Integer> set1 = new HashSet<Integer>();\n    for (Integer n : nums1) set1.add(n);\n    HashSet<Integer> set2 = new HashSet<Integer>();\n    for (Integer n : nums2) set2.add(n);\n\n    set1.retainAll(set2);\n\n    int [] output = new int[set1.size()];\n    int idx = 0;\n    for (int s : set1) output[idx++] = s;\n    return output;\n  }\n}"
      ]
    },
    {
      "number": 47,
      "question": "Can you solve this real interview question? Data Stream as Disjoint Intervals - Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.\n\nImplement the SummaryRanges class:\n\n * SummaryRanges() Initializes the object with an empty stream.\n * void addNum(int value) Adds the integer value to the stream.\n * int[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.\n\n \n\nExample 1:\n\n\nInput\n[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\nOutput\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\nExplanation\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n\n\n \n\nConstraints:\n\n * 0 <= value <= 104\n * At most 3 * 104 calls will be made to addNum and getIntervals.\n * At most 102 calls will be made to getIntervals.\n\n \n\nFollow up: What if there are lots of merges and the number of disjoint intervals is small compared to the size of the data stream?",
      "code": "class SummaryRanges {\npublic:\n    SummaryRanges() {\n        \n    }\n    \n    void addNum(int value) {\n        \n    }\n    \n    vector<vector<int>> getIntervals() {\n        \n    }\n};\n\n/**\n * Your SummaryRanges object will be instantiated and \ncalled as such:\n * SummaryRanges* obj = new SummaryRanges();\n * obj->addNum(value);\n * vector<vector<int>> param_2 = obj->getIntervals();\n */",
      "solution": [
        "class SummaryRanges {\n    set<int> values;\n\npublic:\n    SummaryRanges() {}\n\n    void addNum(int value) { values.insert(value); }\n\n    vector<vector<int>> getIntervals() {\n        if (values.empty()) {\n            return {};\n        }\n        vector<vector<int>> intervals;\n        int left = -1, right = -1;\n        for (int value : values) {\n            if (left < 0) {\n                left = right = value;\n            } else if (value == right + 1) {\n                right = value;\n            } else {\n                intervals.push_back({left, right});\n                left = right = value;\n            }\n        }\n        intervals.push_back({left, right});\n        return intervals;\n    }\n};",
        "class SummaryRanges {\n    map<int, int> intervals;\n\npublic:\n    SummaryRanges() {}\n\n    void addNum(int value) {\n        int left = value, right = value;\n        auto small_entry = intervals.upper_bound(value);\n        if (small_entry != intervals.begin()) {\n            auto max_entry = small_entry;\n            --max_entry;\n            if (max_entry->second >= value) {\n                return;\n            }\n            if (max_entry->second == value - 1) {\n                left = max_entry->first;\n            }\n        }\n        if (small_entry != intervals.end() && small_entry->first == value + 1) {\n            right = small_entry->second;\n            intervals.erase(small_entry);\n        }\n        intervals[left] = right;\n    }\n\n    vector<vector<int>> getIntervals() {\n        vector<vector<int>> answer;\n        for (const auto& p : intervals) {\n            answer.push_back({p.first, p.second});\n        }\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 48,
      "question": "Can you solve this real interview question? Find K Pairs with Smallest Sums - You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\n\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\n\n\nExample 2:\n\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\n\n\nExample 3:\n\n\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [[1,3],[2,3]]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n\n\n \n\nConstraints:\n\n * 1 <= nums1.length, nums2.length <= 105\n * -109 <= nums1[i], nums2[i] <= 109\n * nums1 and nums2 both are sorted in non-decreasing order.\n * 1 <= k <= 104",
      "code": "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, \nvector<int>& nums2, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n        int m = nums1.size();\n        int n = nums2.size();\n\n        vector<vector<int>> ans;\n        set<pair<int, int>> visited;\n\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>,\n                       greater<pair<int, pair<int, int>>>> minHeap;\n        minHeap.push({nums1[0] + nums2[0], {0, 0}});\n        visited.insert({0, 0});\n\n        while (k-- && !minHeap.empty()) {\n            auto top = minHeap.top();\n            minHeap.pop();\n            int i = top.second.first;\n            int j = top.second.second;\n\n            ans.push_back({nums1[i], nums2[j]});\n\n            if (i + 1 < m && visited.find({i + 1, j}) == visited.end()) {\n                minHeap.push({nums1[i + 1] + nums2[j], {i + 1, j}});\n                visited.insert({i + 1, j});\n            }\n\n            if (j + 1 < n && visited.find({i, j + 1}) == visited.end()) {\n                minHeap.push({nums1[i] + nums2[j + 1], {i, j + 1}});\n                visited.insert({i, j + 1});\n            }\n        }\n\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 49,
      "question": "Can you solve this real interview question? Insert Delete GetRandom O(1) - Duplicates allowed - RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the RandomizedCollection class:\n\n * RandomizedCollection() Initializes the empty RandomizedCollection object.\n * bool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\n * bool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\n * int getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\n\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\n\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n\n \n\nExample 1:\n\n\nInput\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]\n\nExplanation\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains [1,1].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains [1,2].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n\n\n \n\nConstraints:\n\n * -231 <= val <= 231 - 1\n * At most 2 * 105 calls in total will be made to insert, remove, and getRandom.\n * There will be at least one element in the data structure when getRandom is called.",
      "code": "class RandomizedCollection {\npublic:\n    RandomizedCollection() {\n        \n    }\n    \n    bool insert(int val) {\n        \n    }\n    \n    bool remove(int val) {\n        \n    }\n    \n    int getRandom() {\n        \n    }\n};\n\n/**\n * Your RandomizedCollection object will be instantiated \nand called as such:\n * RandomizedCollection* obj = new RandomizedCollection();\n * bool param_1 = obj->insert(val);\n * bool param_2 = obj->remove(val);",
      "solution": [
        "public class RandomizedCollection {\n    ArrayList<Integer> lst;\n    HashMap<Integer, Set<Integer>> idx;\n    java.util.Random rand = new java.util.Random();\n    /** Initialize your data structure here. */\n\n    public RandomizedCollection() {\n        lst = new ArrayList<Integer>();\n        idx = new HashMap<Integer, Set<Integer>>();\n    }\n\n    /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n    public boolean insert(int val) {\n        if (!idx.containsKey(val)) idx.put(val, new LinkedHashSet<Integer>());\n        idx.get(val).add(lst.size());\n        lst.add(val);\n        return idx.get(val).size() == 1;\n    }\n\n    /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n    public boolean remove(int val) {\n        if (!idx.containsKey(val) || idx.get(val).size() == 0) return false;\n        int remove_idx = idx.get(val).iterator().next();\n        idx.get(val).remove(remove_idx);\n        int last = lst.get(lst.size() - 1);\n        lst.set(remove_idx, last);\n        idx.get(last).add(remove_idx);\n        idx.get(last).remove(lst.size() - 1);\n\n        lst.remove(lst.size() - 1);\n        return true;\n    }\n\n    /** Get a random element from the collection. */\n    public int getRandom() {\n        return lst.get(rand.nextInt(lst.size()));\n    }\n}"
      ]
    },
    {
      "number": 50,
      "question": "Can you solve this real interview question? Shuffle an Array - Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.\n\nImplement the Solution class:\n\n * Solution(int[] nums) Initializes the object with the integer array nums.\n * int[] reset() Resets the array to its original configuration and returns it.\n * int[] shuffle() Returns a random shuffling of the array.\n\n \n\nExample 1:\n\n\nInput\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\nOutput\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // Shuffle the array [1,2,3] and return its result.\n                       // Any permutation of [1,2,3] must be equally likely to be returned.\n                       // Example: return [3, 1, 2]\nsolution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]\nsolution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]\n\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 50\n * -106 <= nums[i] <= 106\n * All the elements of nums are unique.\n * At most 104 calls in total will be made to reset and shuffle.",
      "code": "class Solution {\npublic:\n    Solution(vector<int>& nums) {\n        \n    }\n    \n    vector<int> reset() {\n        \n    }\n    \n    vector<int> shuffle() {\n        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as \nsuch:\n * Solution* obj = new Solution(nums);\n * vector<int> param_1 = obj->reset();\n * vector<int> param_2 = obj->shuffle();\n */",
      "solution": [
        "class Solution {\n    private int[] array;\n    private int[] original;\n\n    private Random rand = new Random();\n\n    private List<Integer> getArrayCopy() {\n        List<Integer> asList = new ArrayList<Integer>();\n        for (int i = 0; i < array.length; i++) {\n            asList.add(array[i]);\n        }\n        return asList;\n    }\n\n    public Solution(int[] nums) {\n        array = nums;\n        original = nums.clone();\n    }\n    \n    public int[] reset() {\n        array = original;\n        original = original.clone();\n        return array;\n    }\n    \n    public int[] shuffle() {\n        List<Integer> aux = getArrayCopy();\n\n        for (int i = 0; i < array.length; i++) {\n            int removeIdx = rand.nextInt(aux.size());\n            array[i] = aux.get(removeIdx);\n            aux.remove(removeIdx);\n        }\n\n        return array;\n    }\n}",
        "class Solution {\n    private int[] array;\n    private int[] original;\n\n    Random rand = new Random();\n\n    private int randRange(int min, int max) {\n        return rand.nextInt(max - min) + min;\n    }\n\n    private void swapAt(int i, int j) {\n        int temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n\n    public Solution(int[] nums) {\n        array = nums;\n        original = nums.clone();\n    }\n    \n    public int[] reset() {\n        array = original;\n        original = original.clone();\n        return original;\n    }\n    \n    public int[] shuffle() {\n        for (int i = 0; i < array.length; i++) {\n            swapAt(i, randRange(i, array.length));\n        }\n        return array;\n    }\n}"
      ]
    },
    {
      "number": 51,
      "question": "Can you solve this real interview question? First Unique Character in a String - Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n \n\nExample 1:\n\nInput: s = \"leetcode\"\nOutput: 0\n\n\nExample 2:\n\nInput: s = \"loveleetcode\"\nOutput: 2\n\n\nExample 3:\n\nInput: s = \"aabb\"\nOutput: -1\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    int firstUniqChar(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> count = new HashMap<Character, Integer>();\n        int n = s.length();\n        // build hash map : character and how often it appears\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n        \n        // find the index\n        for (int i = 0; i < n; i++) {\n            if (count.get(s.charAt(i)) == 1) \n                return i;\n        }\n        return -1;\n    }\n}"
      ]
    },
    {
      "number": 52,
      "question": "Can you solve this real interview question? UTF-8 Validation - Given an integer array data representing the data, return whether it is a valid UTF-8 encoding (i.e. it translates to a sequence of valid UTF-8 encoded characters).\n\nA character in UTF8 can be from 1 to 4 bytes long, subjected to the following rules:\n\n 1. For a 1-byte character, the first bit is a 0, followed by its Unicode code.\n 2. For an n-bytes character, the first n bits are all one's, the n + 1 bit is 0, followed by n - 1 bytes with the most significant 2 bits being 10.\n\nThis is how the UTF-8 encoding would work:\n\n\n     Number of Bytes   |        UTF-8 Octet Sequence\n                       |              (binary)\n   --------------------+-----------------------------------------\n            1          |   0xxxxxxx\n            2          |   110xxxxx 10xxxxxx\n            3          |   1110xxxx 10xxxxxx 10xxxxxx\n            4          |   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n\n\nx denotes a bit in the binary form of a byte that may be either 0 or 1.\n\nNote: The input is an array of integers. Only the least significant 8 bits of each integer is used to store the data. This means each integer represents only 1 byte of data.\n\n \n\nExample 1:\n\n\nInput: data = [197,130,1]\nOutput: true\nExplanation: data represents the octet sequence: 11000101 10000010 00000001.\nIt is a valid utf-8 encoding for a 2-bytes character followed by a 1-byte character.\n\n\nExample 2:\n\n\nInput: data = [235,140,4]\nOutput: false\nExplanation: data represented the octet sequence: 11101011 10001100 00000100.\nThe first 3 bits are all one's and the 4th bit is 0 means it is a 3-bytes character.\nThe next byte is a continuation byte which starts with 10 and that's correct.\nBut the second continuation byte does not start with 10, so it is invalid.\n\n\n \n\nConstraints:\n\n * 1 <= data.length <= 2 * 104\n * 0 <= data[i] <= 255",
      "code": "class Solution {\npublic:\n    bool validUtf8(vector<int>& data) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n  public boolean validUtf8(int[] data) {\n\n    // Number of bytes in the current UTF-8 character\n    int numberOfBytesToProcess = 0;\n\n    // For each integer in the data array.\n    for (int i = 0; i < data.length; i++) {\n\n      // Get the binary representation. We only need the least significant 8 bits\n      // for any given number.\n      String binRep = Integer.toBinaryString(data[i]);\n      binRep =\n          binRep.length() >= 8\n              ? binRep.substring(binRep.length() - 8)\n              : \"00000000\".substring(binRep.length() % 8) + binRep;\n\n      // If this is the case then we are to start processing a new UTF-8 character.\n      if (numberOfBytesToProcess == 0) {\n\n        // Get the number of 1s in the beginning of the string.\n        for (int j = 0; j < binRep.length(); j++) {\n          if (binRep.charAt(j) == '0') {\n            break;\n          }\n\n          numberOfBytesToProcess += 1;\n        }\n\n        // 1 byte characters\n        if (numberOfBytesToProcess == 0) {\n          continue;\n        }\n\n        // Invalid scenarios according to the rules of the problem.\n        if (numberOfBytesToProcess > 4 || numberOfBytesToProcess == 1) {\n          return false;\n        }\n\n      } else {\n\n        // Else, we are processing integers which represent bytes which are a part of\n        // a UTF-8 character. So, they must adhere to the pattern `10xxxxxx`.\n        if (!(binRep.charAt(0) == '1' && binRep.charAt(1) == '0')) {\n          return false;\n        }\n      }\n\n      // We reduce the number of bytes to process by 1 after each integer.\n      numberOfBytesToProcess -= 1;\n    }\n\n    // This is for the case where we might not have the complete data for\n    // a particular UTF-8 character.\n    return numberOfBytesToProcess == 0;\n  }\n}",
        "class Solution {\n    public boolean validUtf8(int[] data) {\n\n        // Number of bytes in the current UTF-8 character\n        int numberOfBytesToProcess = 0;\n\n        // Masks to check two most significant bits in a byte.\n        int mask1 = 1 << 7;\n        int mask2 = 1 << 6;\n\n        // For each integer in the data array.\n        for(int i = 0; i < data.length; i++) {\n            // If this is the case then we are to start processing a new UTF-8 character.\n            if (numberOfBytesToProcess == 0) {\n                int mask = 1 << 7;\n                 while ((mask & data[i]) != 0) {\n                    numberOfBytesToProcess += 1;\n                    mask = mask >> 1;\n                 }\n\n                // 1 byte characters\n                if (numberOfBytesToProcess == 0) {\n                    continue;\n                }\n\n                // Invalid scenarios according to the rules of the problem.\n                if (numberOfBytesToProcess > 4 || numberOfBytesToProcess == 1) {\n                    return false;\n                }\n\n            } else {\n\n                // data[i] should have most significant bit set and\n                // second most significant bit unset. So, we use the two masks\n                // to make sure this is the case.\n                if (!((data[i] & mask1) != 0 && (mask2 & data[i]) == 0)) {\n                    return false;\n                }\n            }\n\n            // We reduce the number of bytes to process by 1 after each integer.\n            numberOfBytesToProcess -= 1;\n        }\n\n        // This is for the case where we might not have the complete data for\n        // a particular UTF-8 character.\n        return numberOfBytesToProcess == 0;\n    }\n}"
      ]
    },
    {
      "number": 53,
      "question": "Can you solve this real interview question? Longest Substring with At Least K Repeating Characters - Given a string s and an integer k, return the length of the longest substring of s such that the frequency of each character in this substring is greater than or equal to k.\n\nif no such substring exists, return 0.\n\n \n\nExample 1:\n\n\nInput: s = \"aaabb\", k = 3\nOutput: 3\nExplanation: The longest substring is \"aaa\", as 'a' is repeated 3 times.\n\n\nExample 2:\n\n\nInput: s = \"ababbc\", k = 2\nOutput: 5\nExplanation: The longest substring is \"ababb\", as 'a' is repeated 2 times and 'b' is repeated 3 times.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 104\n * s consists of only lowercase English letters.\n * 1 <= k <= 105",
      "code": "class Solution {\npublic:\n    int longestSubstring(string s, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int longestSubstring(string s, int k) {\n        if (s.size() == 0 || k > s.length()) {\n            return 0;\n        }\n        int countMap[26] = {0};\n        int n = s.length();\n        int result = 0;\n        for (int start = 0; start < n; start++) {\n            // reset the count map\n            memset(countMap, 0, sizeof(countMap));\n            for (int end = start; end < n; end++) {\n                countMap[s[end] - 'a']++;\n                if (isValid(s, start, end, k, countMap)) {\n                    result = max(result, end - start + 1);\n                }\n            }\n        }\n        return result;\n    }\n\n    bool isValid(string s, int start, int end, int k, int countMap[26]) {\n        int countLetters = 0, countAtLeastK = 0;\n        for (int i = 0; i < 26; i++) {\n            if (countMap[i] > 0) countLetters++;\n            if (countMap[i] >= k) countAtLeastK++;\n        }\n        return countAtLeastK == countLetters;\n    }\n\n};\n\n",
        "class Solution {\n    public:\n    int longestSubstring(string s, int k) {\n        int n = s.size();\n        return longestSubstringUtil(s, 0, n, k);\n    }\n    int longestSubstringUtil(string &s, int start, int end, int k) {\n        if (end < k) return 0;\n        int countMap[26] = {0};\n        // update the countMap with the count of each character\n        for (int i = start; i < end; i++)\n            countMap[s[i] - 'a']++;\n        for (int mid = start; mid < end; mid++) {\n            if (countMap[s[mid] - 'a'] >= k) continue;\n            int midNext = mid + 1;\n            while (midNext < end && countMap[s[midNext] - 'a'] < k) midNext++;\n            return max(longestSubstringUtil(s, start, mid, k),\n                    longestSubstringUtil(s, midNext, end, k));\n        }\n        return (end - start);\n    }\n};\n\n",
        "class Solution {\npublic:\n    int longestSubstring(string s, int k) {\n        int countMap[26];\n        int maxUnique = getMaxUniqueLetters(s);\n        int result = 0;\n        for (int currUnique = 1; currUnique <= maxUnique; currUnique++) {\n            // reset countMap\n            memset(countMap, 0, sizeof(countMap));\n            int windowStart = 0, windowEnd = 0, idx = 0, unique = 0, countAtLeastK = 0;\n            while (windowEnd < s.size()) {\n                // expand the sliding window\n                if (unique <= currUnique) {\n                    idx = s[windowEnd] - 'a';\n                    if (countMap[idx] == 0) unique++;\n                    countMap[idx]++;\n                    if (countMap[idx] == k) countAtLeastK++;\n                    windowEnd++;\n                }\n                // shrink the sliding window\n                else {\n                    idx = s[windowStart] - 'a';\n                    if (countMap[idx] == k) countAtLeastK--;\n                    countMap[idx]--;\n                    if (countMap[idx] == 0) unique--;\n                    windowStart++;\n                }\n                if (unique == currUnique && unique == countAtLeastK)\n                    result = max(windowEnd - windowStart, result);\n            }\n        }\n\n        return result;\n    }\n\n    // get the maximum number of unique letters in the string s\n    int getMaxUniqueLetters(string s) {\n        bool map[26] = {0};\n        int maxUnique = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (!map[s[i] - 'a']) {\n                maxUnique++;\n                map[s[i] - 'a'] = true;\n            }\n        }\n        return maxUnique;\n    }\n};\n"
      ]
    },
    {
      "number": 54,
      "question": "Can you solve this real interview question? Random Pick Index - Given an integer array nums with possible duplicates, randomly output the index of a given target number. You can assume that the given target number must exist in the array.\n\nImplement the Solution class:\n\n * Solution(int[] nums) Initializes the object with the array nums.\n * int pick(int target) Picks a random index i from nums where nums[i] == target. If there are multiple valid i's, then each index should have an equal probability of returning.\n\n \n\nExample 1:\n\n\nInput\n[\"Solution\", \"pick\", \"pick\", \"pick\"]\n[[[1, 2, 3, 3, 3]], [3], [1], [3]]\nOutput\n[null, 4, 0, 2]\n\nExplanation\nSolution solution = new Solution([1, 2, 3, 3, 3]);\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\nsolution.pick(1); // It should return 0. Since in the array only nums[0] is equal to 1.\nsolution.pick(3); // It should return either index 2, 3, or 4 randomly. Each index should have equal probability of returning.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 2 * 104\n * -231 <= nums[i] <= 231 - 1\n * target is an integer from nums.\n * At most 104 calls will be made to pick.",
      "code": "class Solution {\npublic:\n    Solution(vector<int>& nums) {\n        \n    }\n    \n    int pick(int target) {\n        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as \nsuch:\n * Solution* obj = new Solution(nums);\n * int param_1 = obj->pick(target);\n */",
      "solution": [
        "class Solution {\nprivate:\n\n    vector<int> nums;\n\npublic:\n    \n    Solution(vector<int>& nums) {\n        // Do not allocate extra space for the nums array\n        this->nums.swap(nums);\n    }\n    \n    int pick(int target) {\n        vector<int> indices;\n        int n = nums.size();\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == target) {\n                indices.push_back(i);\n            }\n        }\n        int l = indices.size();\n        int randomIndex = indices[rand() % l];\n        return randomIndex;\n    }\n};",
        "class Solution {\nprivate:\n\n    unordered_map<int, vector<int>> indices;\n\npublic:\n    \n    Solution(vector<int>& nums) {\n        int l = nums.size();\n        for (int i = 0; i < l; ++i) {\n            this->indices[nums[i]].push_back(i);\n        }\n    }\n    \n    int pick(int target) {\n        int l = indices[target].size();\n        // pick an index at random\n        int randomIndex = indices[target][rand() % l];\n        return randomIndex;\n    }\n};",
        "class Solution {\npublic:\n    \n    vector<int> nums;\n    \n    Solution(vector<int>& nums) {\n        this->nums.swap(nums);\n    }\n    \n    int pick(int target) {\n        int n = nums.size();\n        int count = 0;\n        int idx = 0;\n        for (int i = 0; i < n; ++i) {\n            // if nums[i] is equal to target, i is a potential candidate\n            // which needs to be chosen uniformly at random\n            if (nums[i] == target) {\n                // increment the count of total candidates\n                // available to be chosen uniformly at random\n                count++;\n                // we pick the current number with probability 1 / count (reservoir sampling)\n                if (rand() % count == 0) {\n                    idx = i;\n                }\n            }\n        }\n        return idx;\n    }\n};"
      ]
    },
    {
      "number": 55,
      "question": "Can you solve this real interview question? Longest Palindrome - Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\n\nLetters are case sensitive, for example, \"Aa\" is not considered a palindrome here.\n\n \n\nExample 1:\n\n\nInput: s = \"abccccdd\"\nOutput: 7\nExplanation: One longest palindrome that can be built is \"dccaccd\", whose length is 7.\n\n\nExample 2:\n\n\nInput: s = \"a\"\nOutput: 1\nExplanation: The longest palindrome that can be built is \"a\", whose length is 1.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 2000\n * s consists of lowercase and/or uppercase English letters only.",
      "code": "class Solution {\npublic:\n    int longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int longestPalindrome(String s) {\n        int[] count = new int[128];\n        for (char c: s.toCharArray())\n            count[c]++;\n\n        int ans = 0;\n        for (int v: count) {\n            ans += v / 2 * 2;\n            if (ans % 2 == 0 && v % 2 == 1)\n                ans++;\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 56,
      "question": "Can you solve this real interview question? Third Maximum Number - Given an integer array nums, return the third distinct maximum number in this array. If the third maximum does not exist, return the maximum number.\n\n \n\nExample 1:\n\n\nInput: nums = [3,2,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2.\nThe third distinct maximum is 1.\n\n\nExample 2:\n\n\nInput: nums = [1,2]\nOutput: 2\nExplanation:\nThe first distinct maximum is 2.\nThe second distinct maximum is 1.\nThe third distinct maximum does not exist, so the maximum (2) is returned instead.\n\n\nExample 3:\n\n\nInput: nums = [2,2,3,1]\nOutput: 1\nExplanation:\nThe first distinct maximum is 3.\nThe second distinct maximum is 2 (both 2's are counted together since they have the same value).\nThe third distinct maximum is 1.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * -231 <= nums[i] <= 231 - 1\n\n \n\nFollow up: Can you find an O(n) solution?",
      "code": "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        // Sort the array in non-increasing order.\n        sort(nums.begin(), nums.end(), greater<int>());\n        \n        int elemCounted = 1;\n        int prevElem = nums[0];\n        \n        for (int index = 1; index < nums.size(); ++index) {\n            // Current element is different from previous.\n            if (nums[index] != prevElem) {\n                elemCounted += 1;\n                prevElem = nums[index];\n            }\n            \n            // If we have counted 3 numbers then return current number.\n            if (elemCounted == 3) {\n                return nums[index];\n            }\n        }\n        \n        // We never counted 3 distinct numbers, return largest number.\n        return nums[0];\n    }\n};",
        "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        priority_queue<int, vector<int>, greater<int>> minHeap;\n        unordered_set<int> taken;\n        \n        for (int index = 0; index < nums.size(); ++index) {\n            // If current number was already taken, skip it.\n            if (taken.count(nums[index])) {\n                continue;\n            }\n            \n            // If min heap already has three numbers in it.\n            // Pop the smallest if current number is bigger than it.\n            if (minHeap.size() == 3) {\n                if (minHeap.top() < nums[index]) {\n                    taken.erase(minHeap.top());\n                    minHeap.pop();\n                    \n                    minHeap.push(nums[index]);\n                    taken.insert(nums[index]);\n                }\n            } \n            // If min heap does not have three numbers we can push it.\n            else {\n                minHeap.push(nums[index]);\n                taken.insert(nums[index]);\n            }\n        }\n        \n        // 'nums' has only one distinct element it will be the maximum.\n        if (minHeap.size() == 1) {\n            return minHeap.top();\n        }\n        // 'nums' has two distinct elements.\n        else if (minHeap.size() == 2) {\n            int firstNum = minHeap.top();\n            minHeap.pop();\n            return max(firstNum, minHeap.top());\n        }\n        \n        return minHeap.top();\n    }\n};",
        "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        // Sorted set to keep elements in sorted order.\n        set<int> sortedNums;\n        \n        // Iterate on all elements of 'nums' array.\n        for (int& num : nums) {\n            // Do not insert same element again.\n            if (sortedNums.count(num)) {\n                continue;\n            }\n            \n            // If sorted set has 3 elements.\n            if (sortedNums.size() == 3) {\n                // And the smallest element is smaller than current element.\n                if (*sortedNums.begin() < num) {\n                    // Then remove the smallest element and push the current element.\n                    sortedNums.erase(sortedNums.begin());\n                    sortedNums.insert(num);\n                }\n                \n            } \n            // Otherwise push the current element of nums array.\n            else {\n                sortedNums.insert(num);\n            }\n        }\n        \n        // If sorted set has three elements return the smallest among those 3.\n        if (sortedNums.size() == 3) {\n            return *sortedNums.begin();\n        }\n        \n        // Otherwise return the biggest element of nums array.\n        return *sortedNums.rbegin();\n    }\n};",
        "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        // Three variables to store maxiumum three numbers till now.\n        long long firstMax = numeric_limits<long long>::min();\n        long long secondMax = numeric_limits<long long>::min();\n        long long thirdMax = numeric_limits<long long>::min();\n        \n        for (int& num : nums) {\n            // This number is already used once, thus we skip it.\n            if (firstMax == num || secondMax == num || thirdMax == num) {\n                continue;\n            }\n            \n            // If current number is greater than first maximum,\n            // It means that this is the greatest number and first maximum and second max\n            // will become the next two greater numbers.\n            if (firstMax <= num) {\n                thirdMax = secondMax;\n                secondMax = firstMax;\n                firstMax = num;\n            }\n            // When current number is greater than second maximum,\n            // it means that this is the second greatest number.\n            else if (secondMax <= num) {\n                thirdMax = secondMax;\n                secondMax = num;\n            }\n            // It is the third greatest number.\n            else if (thirdMax <= num) {\n                thirdMax = num;\n            }\n        }\n        \n        // If third max was never updated, it means we don't have 3 distinct numbers.\n        if (thirdMax == numeric_limits<long long>::min()) {\n            return firstMax;\n        }\n        \n        return thirdMax;\n    }\n};",
        "class Solution {\npublic:\n    int thirdMax(vector<int>& nums) {\n        pair<int, bool> firstMax = {-1, false};\n        pair<int, bool> secondMax = {-1, false};\n        pair<int, bool> thirdMax = {-1, false};\n        \n        for (int& num : nums) {\n            // If current number is already stored, skip it.\n            if ((firstMax.second && firstMax.first == num) || \n                (secondMax.second && secondMax.first == num) || \n                (thirdMax.second && thirdMax.first == num)) {\n                continue;\n            }\n            \n            // If we never stored any variable in firstMax\n            // or curr num is bigger than firstMax, then curr num is the biggest number.\n            if (!firstMax.second || firstMax.first <= num) {\n                thirdMax = secondMax;\n                secondMax = firstMax;\n                firstMax = make_pair(num, true);\n            }\n            // If we never stored any variable in secondMax\n            // or curr num is bigger than secondMax, then curr num is 2nd biggest number.\n            else if (!secondMax.second || secondMax.first <= num) {\n                thirdMax = secondMax;\n                secondMax = make_pair(num, true);\n            }\n            // If we never stored any variable in thirdMax\n            // or curr num is bigger than thirdMax, then curr num is 3rd biggest number.\n            else if (!thirdMax.second || thirdMax.first <= num) {\n                thirdMax = make_pair(num, true);\n            }\n        }\n        \n        // If third max was never updated, it means we don't have 3 distinct numbers.\n        if (!thirdMax.second) {\n            return firstMax.first;\n        }\n        \n        return thirdMax.first;\n    }\n};"
      ]
    },
    {
      "number": 57,
      "question": "Can you solve this real interview question? Number of Segments in a String - Given a string s, return the number of segments in the string.\n\nA segment is defined to be a contiguous sequence of non-space characters.\n\n \n\nExample 1:\n\n\nInput: s = \"Hello, my name is John\"\nOutput: 5\nExplanation: The five segments are [\"Hello,\", \"my\", \"name\", \"is\", \"John\"]\n\n\nExample 2:\n\n\nInput: s = \"Hello\"\nOutput: 1\n\n\n \n\nConstraints:\n\n * 0 <= s.length <= 300\n * s consists of lowercase and uppercase English letters, digits, or one of the following characters \"!@#$%^&*()_+-=',.:\".\n * The only space character in s is ' '.",
      "code": "class Solution {\npublic:\n    int countSegments(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int countSegments(String s) {\n        String trimmed = s.trim();\n        if (trimmed.equals(\"\")) {\n            return 0;\n        }\n        return trimmed.split(\"\\\\s+\").length;\n    }\n}",
        "class Solution {\n    public int countSegments(String s) {\n        int segmentCount = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            if ((i == 0 || s.charAt(i-1) == ' ') && s.charAt(i) != ' ') {\n                segmentCount++;\n            }\n        }\n\n        return segmentCount;\n    }\n}"
      ]
    },
    {
      "number": 58,
      "question": "Can you solve this real interview question? String Compression - Given an array of characters chars, compress it using the following algorithm:\n\nBegin with an empty string s. For each group of consecutive repeating characters in chars:\n\n * If the group's length is 1, append the character to s.\n * Otherwise, append the character followed by the group's length.\n\nThe compressed string s should not be returned separately, but instead, be stored in the input character array chars. Note that group lengths that are 10 or longer will be split into multiple characters in chars.\n\nAfter you are done modifying the input array, return the new length of the array.\n\nYou must write an algorithm that uses only constant extra space.\n\n \n\nExample 1:\n\n\nInput: chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\nOutput: Return 6, and the first 6 characters of the input array should be: [\"a\",\"2\",\"b\",\"2\",\"c\",\"3\"]\nExplanation: The groups are \"aa\", \"bb\", and \"ccc\". This compresses to \"a2b2c3\".\n\n\nExample 2:\n\n\nInput: chars = [\"a\"]\nOutput: Return 1, and the first character of the input array should be: [\"a\"]\nExplanation: The only group is \"a\", which remains uncompressed since it's a single character.\n\n\nExample 3:\n\n\nInput: chars = [\"a\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\",\"b\"]\nOutput: Return 4, and the first 4 characters of the input array should be: [\"a\",\"b\",\"1\",\"2\"].\nExplanation: The groups are \"a\" and \"bbbbbbbbbbbb\". This compresses to \"ab12\".\n\n \n\nConstraints:\n\n * 1 <= chars.length <= 2000\n * chars[i] is a lowercase English letter, uppercase English letter, digit, or symbol.",
      "code": "class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int compress(vector<char>& chars) {\n        int i = 0, res = 0;\n        while (i < chars.size()) {\n            int groupLength = 1;\n            while (i + groupLength < chars.size() && chars[i + groupLength] == chars[i]) {\n                groupLength++;\n            }\n            chars[res++] = chars[i];\n            if (groupLength > 1) {\n                for (char c : to_string(groupLength)) {\n                    chars[res++] = c;\n                }\n            }\n            i += groupLength;\n        }\n        return res;\n    }\n};"
      ]
    },
    {
      "number": 59,
      "question": "Can you solve this real interview question? Add Two Numbers II - You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/04/09/sumii-linked-list.jpg]\n\n\nInput: l1 = [7,2,4,3], l2 = [5,6,4]\nOutput: [7,8,0,7]\n\n\nExample 2:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [8,0,7]\n\n\nExample 3:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.\n\n \n\nFollow up: Could you solve it without reversing the input lists?",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* temp;\n        while (head) {\n            // Keep the next node.\n             temp = head->next;\n            // reverse the link\n            head->next = prev;\n            // Update the previous node and the current node.\n            prev = head;\n            head = temp;\n        }\n        return prev;\n    }\n\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* r1 = reverseList(l1);\n        ListNode* r2 = reverseList(l2);\n\n        int totalSum = 0;\n        int carry = 0;\n        ListNode* ans = new ListNode();\n        while (r1 || r2) {\n            if (r1) {\n                totalSum += r1->val;\n                r1 = r1->next;\n            }\n            if (r2) {\n                totalSum += r2->val;\n                r2 = r2->next;\n            }\n\n            ans->val = totalSum % 10;\n            carry = totalSum / 10;\n            ListNode* head = new ListNode(carry);\n            head->next = ans;\n            ans = head;\n            totalSum = carry;\n        }\n\n        return carry == 0 ? ans->next : ans;\n    }\n};",
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        stack<int> s1, s2;\n\n        while (l1 != nullptr) {\n            s1.push(l1->val);\n            l1 = l1->next;\n        }\n\n        while (l2 != nullptr) {\n            s2.push(l2->val);\n            l2 = l2->next;\n        }\n\n        int totalSum = 0, carry = 0;\n        ListNode* ans = new ListNode();\n        while (!s1.empty() || !s2.empty()) {\n            if (!s1.empty()) {\n                totalSum += s1.top();\n                s1.pop();\n            }\n            if (!s2.empty()) {\n                totalSum += s2.top();\n                s2.pop();\n            }\n\n            ans->val = totalSum % 10;\n            carry = totalSum / 10;\n            ListNode* newNode = new ListNode(carry);\n            newNode->next = ans;\n            ans = newNode;\n            totalSum = carry;\n        }\n\n        return carry == 0 ? ans->next : ans;\n    }\n};"
      ]
    },
    {
      "number": 60,
      "question": "Can you solve this real interview question? 132 Pattern - Given an array of n integers nums, a 132 pattern is a subsequence of three integers nums[i], nums[j] and nums[k] such that i < j < k and nums[i] < nums[k] < nums[j].\n\nReturn true if there is a 132 pattern in nums, otherwise, return false.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3,4]\nOutput: false\nExplanation: There is no 132 pattern in the sequence.\n\n\nExample 2:\n\n\nInput: nums = [3,1,4,2]\nOutput: true\nExplanation: There is a 132 pattern in the sequence: [1, 4, 2].\n\n\nExample 3:\n\n\nInput: nums = [-1,3,2,0]\nOutput: true\nExplanation: There are three 132 patterns in the sequence: [-1, 3, 2], [-1, 3, 0] and [-1, 2, 0].\n\n\n \n\nConstraints:\n\n * n == nums.length\n * 1 <= n <= 2 * 105\n * -109 <= nums[i] <= 109",
      "code": "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        if (nums.size() < 3) {\n            return false;\n        }\n        for (size_t i = 0; i < nums.size() - 2; i++) {\n            for (size_t j = i + 1; j < nums.size() - 1; j++) {\n                for (size_t k = j + 1; k < nums.size(); k++) {\n                    if (nums[k] > nums[i] and nums[j] > nums[k]) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n};",
        "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        int min_i = INT_MAX;\n        for (size_t j = 0; j < nums.size() - 1; j++) {\n            min_i = min(min_i, nums[j]);\n            for (size_t k = j + 1; k < nums.size(); k++) {\n                if (nums[k] < nums[j] and min_i < nums[k]) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};",
        "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        vector<pair<int, int>> intervals;\n        size_t min_point_after_last_peak_index = 0;\n        for (size_t i = 1; i < nums.size(); i++) {\n            // if we encounter a falling edge, then element i - 1 is a peak\n            if (nums[i] < nums[i - 1]) {\n                // make sure the peak occurs after the rising edge's minimum\n                if (min_point_after_last_peak_index < i - 1) {\n                    // nums[min_point_after_last_peak_index...(i-1)] is a valid rising peak\n                    intervals.push_back({nums[min_point_after_last_peak_index], nums[i - 1]});\n                }\n                // the current element is the minimum for the next rising peak\n                min_point_after_last_peak_index = i;\n            }\n            for (auto interval : intervals) {\n                if (nums[i] > interval.first and nums[i] < interval.second) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n};",
        "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        if (nums.size() < 3) {\n            return false;\n        }\n        stack<int> stk;\n        vector<int> min_array(nums.size());\n        min_array[0] = nums[0];\n\n        for (size_t i = 1; i < nums.size(); i++) {\n            min_array[i] = min(min_array[i - 1], nums[i]);\n        }\n        for (size_t j = nums.size() - 1; j > 0; j--) {\n            if (nums[j] <= min_array[j]) {\n                continue;\n            }\n            while (!stk.empty() and stk.top() <= min_array[j]) {\n                stk.pop();\n            }\n            if (!stk.empty() and stk.top() < nums[j]) {\n                return true;\n            }\n            stk.push(nums[j]);\n        }\n        return false;\n    }\n};",
        "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        if (nums.size() < 3) {\n            return false;\n        }\n        vector<int> min_array(nums.size());\n        min_array[0] = nums[0];\n\n        for (size_t i = 1; i < nums.size(); i++) {\n            min_array[i] = min(min_array[i - 1], nums[i]);\n        }\n        int k = nums.size();\n        for (size_t j = nums.size() - 1; j > 0; j--) {\n            if (nums[j] <= min_array[j]) {\n                continue;\n            }\n            auto it = lower_bound(nums.begin() + k, nums.end(), min_array[j] + 1);\n            k = it - nums.begin();\n            if (k < nums.size() and nums[k] < nums[j]) {\n                return true;\n            }\n            nums[--k] = nums[j];\n        }\n        return false;\n    }\n};",
        "class Solution {\npublic:\n    bool find132pattern(vector<int>& nums) {\n        if (nums.size() < 3) {\n            return false;\n        }\n        vector<int> min_array(nums.size());\n        min_array[0] = nums[0];\n\n        for (size_t i = 1; i < nums.size(); i++) {\n            min_array[i] = min(min_array[i - 1], nums[i]);\n        }\n\n        for (size_t j = nums.size() - 1, k = nums.size(); j > 0; j--) {\n            if (nums[j] <= min_array[j]) {\n                continue;\n            }\n            while (k < nums.size() and nums[k] <= min_array[j]) {\n                k++;\n            }\n            if (k < nums.size() and nums[k] < nums[j]) {\n                return true;\n            }\n            nums[--k] = nums[j];\n        }\n        return false;\n    }\n};"
      ]
    },
    {
      "number": 61,
      "question": "Can you solve this real interview question? LFU Cache - Design and implement a data structure for a Least Frequently Used (LFU) [https://en.wikipedia.org/wiki/Least_frequently_used] cache.\n\nImplement the LFUCache class:\n\n * LFUCache(int capacity) Initializes the object with the capacity of the data structure.\n * int get(int key) Gets the value of the key if the key exists in the cache. Otherwise, returns -1.\n * void put(int key, int value) Update the value of the key if present, or inserts the key if not already present. When the cache reaches its capacity, it should invalidate and remove the least frequently used key before inserting a new item. For this problem, when there is a tie (i.e., two or more keys with the same frequency), the least recently used key would be invalidated.\n\nTo determine the least frequently used key, a use counter is maintained for each key in the cache. The key with the smallest use counter is the least frequently used key.\n\nWhen a key is first inserted into the cache, its use counter is set to 1 (due to the put operation). The use counter for a key in the cache is incremented either a get or put operation is called on it.\n\nThe functions get and put must each run in O(1) average time complexity.\n\n \n\nExample 1:\n\n\nInput\n[\"LFUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [3], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, 3, null, -1, 3, 4]\n\nExplanation\n// cnt(x) = the use counter for key x\n// cache=[] will show the last used order for tiebreakers (leftmost element is  most recent)\nLFUCache lfu = new LFUCache(2);\nlfu.put(1, 1);   // cache=[1,_], cnt(1)=1\nlfu.put(2, 2);   // cache=[2,1], cnt(2)=1, cnt(1)=1\nlfu.get(1);      // return 1\n                 // cache=[1,2], cnt(2)=1, cnt(1)=2\nlfu.put(3, 3);   // 2 is the LFU key because cnt(2)=1 is the smallest, invalidate 2.\n                 // cache=[3,1], cnt(3)=1, cnt(1)=2\nlfu.get(2);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,1], cnt(3)=2, cnt(1)=2\nlfu.put(4, 4);   // Both 1 and 3 have the same cnt, but 1 is LRU, invalidate 1.\n                 // cache=[4,3], cnt(4)=1, cnt(3)=2\nlfu.get(1);      // return -1 (not found)\nlfu.get(3);      // return 3\n                 // cache=[3,4], cnt(4)=1, cnt(3)=3\nlfu.get(4);      // return 4\n                 // cache=[4,3], cnt(4)=2, cnt(3)=3\n\n\n \n\nConstraints:\n\n * 1 <= capacity <= 104\n * 0 <= key <= 105\n * 0 <= value <= 109\n * At most 2 * 105 calls will be made to get and put.\n\n \n\n ",
      "code": "class LFUCache {\npublic:\n    LFUCache(int capacity) {\n        \n    }\n    \n    int get(int key) {\n        \n    }\n    \n    void put(int key, int value) {\n        \n    }\n};\n\n/**\n * Your LFUCache object will be instantiated and called as \nsuch:\n * LFUCache* obj = new LFUCache(capacity);\n * int param_1 = obj->get(key);\n * obj->put(key,value);\n */",
      "solution": [
        "class LFUCache {\n    // key: frequency, value: list of original key-value pairs that have the same frequency.\n    unordered_map<int, list<pair<int, int>>> frequencies;\n    // key: original key, value: pair of frequency and the iterator corresponding key int the\n    // frequencies map's list.\n    unordered_map<int, pair<int, list<pair<int, int>>::iterator>> cache;\n    int capacity;\n    int minf;\n\n    void insert(int key, int frequency, int value) {\n        frequencies[frequency].push_back({key, value});\n        cache[key] = {frequency, --frequencies[frequency].end()};\n    }\n\npublic:\n    LFUCache(int capacity) : capacity(capacity), minf(0) {}\n\n    int get(int key) {\n        const auto it = cache.find(key);\n        if (it == cache.end()) {\n            return -1;\n        }\n        const int f = it->second.first;\n        const auto iter = it->second.second;\n        const pair<int, int> kv = *iter;\n        frequencies[f].erase(iter);\n        if (frequencies[f].empty()){\n            frequencies.erase(f);\n\n            if(minf == f) {\n                ++minf;\n            }\n        }\n        \n        insert(key, f + 1, kv.second);\n        return kv.second;\n    }\n\n    void put(int key, int value) {\n        if (capacity <= 0) {\n            return;\n        }\n        const auto it = cache.find(key);\n        if (it != cache.end()) {\n            it->second.second->second = value;\n            get(key);\n            return;\n        }\n        if (capacity == cache.size()) {\n            cache.erase(frequencies[minf].front().first);\n            frequencies[minf].pop_front();\n\n            if(frequencies[minf].empty()) {\n                frequencies.erase(minf);\n            }\n        }\n\n        minf = 1;\n        insert(key, 1, value);\n    }\n};"
      ]
    },
    {
      "number": 62,
      "question": "Can you solve this real interview question? Count The Repetitions - We define str = [s, n] as the string str which consists of the string s concatenated n times.\n\n * For example, str == [\"abc\", 3] ==\"abcabcabc\".\n\nWe define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n\n * For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n\nYou are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n\nReturn the maximum integer m such that str = [str2, m] can be obtained from str1.\n\n \n\nExample 1:\n\nInput: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\nOutput: 2\n\n\nExample 2:\n\nInput: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= s1.length, s2.length <= 100\n * s1 and s2 consist of lowercase English letters.\n * 1 <= n1, n2 <= 106",
      "code": "class Solution {\npublic:\n    int getMaxRepetitions(string s1, int n1, string s2, int \nn2) {\n        \n    }\n};",
      "solution": [
        "int getMaxRepetitions(string s1, int n1, string s2, int n2)\n{\n    int index = 0, repeat_count = 0;\n    int s1_size = s1.size(), s2_size = s2.size();\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < s1_size; j++) {\n            if (s1[j] == s2[index])\n                ++index;\n            if (index == s2_size) {\n                index = 0;\n                ++repeat_count;\n            }\n        }\n    }\n    return repeat_count / n2;\n}",
        "int getMaxRepetitions(string s1, int n1, string s2, int n2)\n{\n    if (n1 == 0)\n        return 0;\n    int indexr[s2.size() + 1] = { 0 }; // index at start of each s1 block\n    int countr[s2.size() + 1] = { 0 }; // count of repititions till the present s1 block\n    int index = 0, count = 0;\n    for (int i = 0; i < n1; i++) {\n        for (int j = 0; j < s1.size(); j++) {\n            if (s1[j] == s2[index])\n                ++index;\n            if (index == s2.size()) {\n                index = 0;\n                ++count;\n            }\n        }\n        countr[i] = count;\n        indexr[i] = index;\n        for (int k = 0; k < i; k++) {\n            if (indexr[k] == index) {\n                int prev_count = countr[k];\n                int pattern_count = (countr[i] - countr[k]) * (n1 - 1 - k) / (i - k);\n                int remain_count = countr[k + (n1 - 1 - k) % (i - k)] - countr[k];\n                return (prev_count + pattern_count + remain_count) / n2;\n            }\n        }\n    }\n    return countr[n1 - 1] / n2;\n}"
      ]
    },
    {
      "number": 63,
      "question": "Can you solve this real interview question? Validate IP Address - Given a string queryIP, return \"IPv4\" if IP is a valid IPv4 address, \"IPv6\" if IP is a valid IPv6 address or \"Neither\" if IP is not a correct IP of any type.\n\nA valid IPv4 address is an IP in the form \"x1.x2.x3.x4\" where 0 <= xi <= 255 and xi cannot contain leading zeros. For example, \"192.168.1.1\" and \"192.168.1.0\" are valid IPv4 addresses while \"192.168.01.1\", \"192.168.1.00\", and \"192.168@1.1\" are invalid IPv4 addresses.\n\nA valid IPv6 address is an IP in the form \"x1:x2:x3:x4:x5:x6:x7:x8\" where:\n\n * 1 <= xi.length <= 4\n * xi is a hexadecimal string which may contain digits, lowercase English letter ('a' to 'f') and upper-case English letters ('A' to 'F').\n * Leading zeros are allowed in xi.\n\nFor example, \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\" and \"2001:db8:85a3:0:0:8A2E:0370:7334\" are valid IPv6 addresses, while \"2001:0db8:85a3::8A2E:037j:7334\" and \"02001:0db8:85a3:0000:0000:8a2e:0370:7334\" are invalid IPv6 addresses.\n\n \n\nExample 1:\n\n\nInput: queryIP = \"172.16.254.1\"\nOutput: \"IPv4\"\nExplanation: This is a valid IPv4 address, return \"IPv4\".\n\n\nExample 2:\n\n\nInput: queryIP = \"2001:0db8:85a3:0:0:8A2E:0370:7334\"\nOutput: \"IPv6\"\nExplanation: This is a valid IPv6 address, return \"IPv6\".\n\n\nExample 3:\n\n\nInput: queryIP = \"256.256.256.256\"\nOutput: \"Neither\"\nExplanation: This is neither a IPv4 address nor a IPv6 address.\n\n\n \n\nConstraints:\n\n * queryIP consists only of English letters, digits and the characters '.' and ':'.",
      "code": "class Solution {\npublic:\n    string validIPAddress(string queryIP) {\n        \n    }\n};",
      "solution": [
        "import java.net.*;\nclass Solution {\n  public String validIPAddress(String IP) {\n    try {\n      return (InetAddress.getByName(IP) instanceof Inet6Address) ? \"IPv6\": \"IPv4\";\n    } catch(Exception e) {}\n    return \"Neither\";\n  }\n}",
        "import java.util.regex.Pattern;\nclass Solution {\n  String chunkIPv4 = \"([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\";\n  Pattern pattenIPv4 =\n          Pattern.compile(\"^(\" + chunkIPv4 + \"\\\\.){3}\" + chunkIPv4 + \"$\");\n\n  String chunkIPv6 = \"([0-9a-fA-F]{1,4})\";\n  Pattern pattenIPv6 =\n          Pattern.compile(\"^(\" + chunkIPv6 + \"\\\\:){7}\" + chunkIPv6 + \"$\");\n\n  public String validIPAddress(String IP) {\n    if (pattenIPv4.matcher(IP).matches()) return \"IPv4\";\n    return (pattenIPv6.matcher(IP).matches()) ? \"IPv6\" : \"Neither\";\n  }\n}",
        "class Solution {\n  public String validateIPv4(String IP) {\n    String[] nums = IP.split(\"\\\\.\", -1);\n    for (String x : nums) {\n      // Validate integer in range (0, 255):\n      // 1. length of chunk is between 1 and 3\n      if (x.length() == 0 || x.length() > 3) return \"Neither\";\n      // 2. no extra leading zeros\n      if (x.charAt(0) == '0' && x.length() != 1) return \"Neither\";\n      // 3. only digits are allowed\n      for (char ch : x.toCharArray()) {\n        if (! Character.isDigit(ch)) return \"Neither\";\n      }\n      // 4. less than 255\n      if (Integer.parseInt(x) > 255) return \"Neither\";\n    }\n    return \"IPv4\";\n  }\n\n  public String validateIPv6(String IP) {\n    String[] nums = IP.split(\":\", -1);\n    String hexdigits = \"0123456789abcdefABCDEF\";\n    for (String x : nums) {\n      // Validate hexadecimal in range (0, 2**16):\n      // 1. at least one and not more than 4 hexdigits in one chunk\n      if (x.length() == 0 || x.length() > 4) return \"Neither\";\n      // 2. only hexdigits are allowed: 0-9, a-f, A-F\n      for (Character ch : x.toCharArray()) {\n        if (hexdigits.indexOf(ch) == -1) return \"Neither\";\n      }\n    }\n    return \"IPv6\";\n  }\n\n  public String validIPAddress(String IP) {\n    if (IP.chars().filter(ch -> ch == '.').count() == 3) {\n      return validateIPv4(IP);\n    }\n    else if (IP.chars().filter(ch -> ch == ':').count() == 7) {\n      return validateIPv6(IP);\n    }\n    else return \"Neither\";\n  }\n}"
      ]
    },
    {
      "number": 64,
      "question": "Can you solve this real interview question? Concatenated Words - Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n\nA concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct) in the given array.\n\n \n\nExample 1:\n\n\nInput: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\nOutput: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\nExplanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n\"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n\"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n\nExample 2:\n\n\nInput: words = [\"cat\",\"dog\",\"catdog\"]\nOutput: [\"catdog\"]\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 104\n * 1 <= words[i].length <= 30\n * words[i] consists of only lowercase English letters.\n * All the strings of words are unique.\n * 1 <= sum(words[i].length) <= 105",
      "code": "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict\n(vector<string>& words) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        unordered_set<string> dictionary(words.begin(), words.end());\n        vector<string> answer;\n        for (const string& word : words) {\n            const int length = word.length();\n            vector<bool> dp(length + 1);\n            dp[0] = true;\n            for (int i = 1; i <= length; ++i) {\n                for (int j = (i == length ? 1 : 0); !dp[i] && j < i; ++j) {\n                    dp[i] = dp[j] && dictionary.count(word.substr(j, i - j));\n                }\n            }\n            if (dp[length]) {\n                answer.push_back(word);\n            }\n        }\n        return answer;\n    }\n};\n",
        "class Solution {\n    bool dfs(const string& word, int length, vector<bool>& visited,\n             const unordered_set<string>& dictionary) {\n        if (length == word.length()) {\n            return true;\n        }\n        if (visited[length]) {\n            return false;\n        }\n        visited[length] = true;\n        for (int i = word.length() - (length == 0 ? 1 : 0); i > length; --i) {\n            if (dictionary.count(word.substr(length, i - length)) &&\n                dfs(word, i, visited, dictionary)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\npublic:\n    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {\n        unordered_set<string> dictionary(words.begin(), words.end());\n        vector<string> answer;\n        for (const string& word : words) {\n            vector<bool> visited(word.length());\n            if (dfs(word, 0, visited, dictionary)) {\n                answer.push_back(word);\n            }\n        }\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 65,
      "question": "Can you solve this real interview question? Matchsticks to Square - You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.\n\nReturn true if you can make this square and false otherwise.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/04/09/matchsticks1-grid.jpg]\n\n\nInput: matchsticks = [1,1,2,2,2]\nOutput: true\nExplanation: You can form a square with length 2, one side of the square came two sticks with length 1.\n\n\nExample 2:\n\n\nInput: matchsticks = [3,3,3,3,4]\nOutput: false\nExplanation: You cannot find a way to form a square with all the matchsticks.\n\n\n \n\nConstraints:\n\n * 1 <= matchsticks.length <= 15\n * 1 <= matchsticks[i] <= 108",
      "code": "class Solution {\npublic:\n    bool makesquare(vector<int>& matchsticks) {\n        \n    }\n};",
      "solution": [
        "import java.util.HashMap;\nimport java.util.Collections;\n\nclass Solution {\n    public List<Integer> nums;\n    public int[] sums;\n    public int possibleSquareSide;\n\n    public Solution() {\n        this.sums = new int[4];\n    }\n\n    // Depth First Search function.\n    public boolean dfs(int index) {\n\n        // If we have exhausted all our matchsticks, check if all sides of the square are of equal length\n        if (index == this.nums.size()) {\n            return sums[0] == sums[1] && sums[1] == sums[2] && sums[2] == sums[3];\n        }\n\n        // Get current matchstick.\n        int element = this.nums.get(index);\n\n        // Try adding it to each of the 4 sides (if possible)\n        for(int i = 0; i < 4; i++) {\n            if (this.sums[i] + element <= this.possibleSquareSide) {\n                this.sums[i] += element;\n                if (this.dfs(index + 1)) {\n                    return true;\n                }\n                this.sums[i] -= element;\n            }\n        }\n\n        return false;\n    }\n\n    public boolean makesquare(int[] nums) {\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        this.possibleSquareSide =  perimeter / 4;\n        if (this.possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n\n        // Convert the array of primitive int to ArrayList (for sorting).\n        this.nums = Arrays.stream(nums).boxed().collect(Collectors.toList());\n        Collections.sort(this.nums, Collections.reverseOrder());\n        return this.dfs(0);\n    }\n}",
        "import java.util.HashMap;\n\nclass Solution {\n\n    // The memoization cache to be used during recursion.\n    public HashMap<Pair<Integer, Integer>, Boolean> memo;\n\n    // Array containing our matchsticks.\n    public int[] nums;\n\n    // Possible side of our square depending on the total sum of all the matchsticks.\n    public int possibleSquareSide;\n\n    // Default constructor to initialise our memo cache.\n    public Solution() {\n        this.memo = new HashMap<Pair<Integer, Integer>, Boolean>();\n    }\n\n    // Main DP function.\n    public boolean recurse(Integer mask, Integer sidesDone) {\n        int total = 0;\n        int L = this.nums.length;\n\n        // The memo key for this recursion\n        Pair<Integer, Integer> memoKey = new Pair(mask, sidesDone);\n\n        // Find out the sum of matchsticks used till now.\n        for(int i = L - 1; i >= 0; i--) {\n            if ((mask&(1 << i)) == 0) {\n                total += this.nums[L - 1 - i];\n            }\n        }\n\n        // If the sum if divisible by our square's side, then we increment our number of complete sides formed variable.\n        if (total > 0 && total % this.possibleSquareSide == 0) {\n            sidesDone++;\n        }\n\n        // Base case.\n        if (sidesDone == 3) {\n            return true;\n        }\n\n\n        // Return precomputed results\n        if (this.memo.containsKey(memoKey)) {\n            return this.memo.get(memoKey);\n        }\n\n        boolean ans = false;\n        int c = total / this.possibleSquareSide;\n\n        // Remaining vlength in the current partially formed side.\n        int rem = this.possibleSquareSide * (c + 1) - total;\n\n        // Try out all remaining options (that are valid)\n        for(int i = L - 1; i >= 0; i--) {\n            if (this.nums[L - 1 - i] <= rem && (mask&(1 << i)) > 0) {\n                if (this.recurse(mask ^ (1 << i), sidesDone)) {\n                    ans = true;\n                    break;\n                }\n            }\n        }\n\n        // Cache the computed results.\n        this.memo.put(memoKey, ans);\n        return ans;\n    }\n\n    public boolean makesquare(int[] nums) {\n\n        // Empty matchsticks.\n        if (nums == null || nums.length == 0) {\n            return false;\n        }\n\n        // Find the perimeter of the square (if at all possible)\n        int L = nums.length;\n        int perimeter = 0;\n        for(int i = 0; i < L; i++) {\n            perimeter += nums[i];\n        }\n\n        int possibleSquareSide =  perimeter / 4;\n        if (possibleSquareSide * 4 != perimeter) {\n            return false;\n        }\n\n        this.nums = nums;\n        this.possibleSquareSide = possibleSquareSide;\n        return this.recurse((1 << L) - 1, 0);\n    }\n}"
      ]
    },
    {
      "number": 66,
      "question": "Can you solve this real interview question? License Key Formatting - You are given a license key represented as a string s that consists of only alphanumeric characters and dashes. The string is separated into n + 1 groups by n dashes. You are also given an integer k.\n\nWe want to reformat the string s such that each group contains exactly k characters, except for the first group, which could be shorter than k but still must contain at least one character. Furthermore, there must be a dash inserted between two groups, and you should convert all lowercase letters to uppercase.\n\nReturn the reformatted license key.\n\n \n\nExample 1:\n\n\nInput: s = \"5F3Z-2e-9-w\", k = 4\nOutput: \"5F3Z-2E9W\"\nExplanation: The string s has been split into two parts, each part has 4 characters.\nNote that the two extra dashes are not needed and can be removed.\n\n\nExample 2:\n\n\nInput: s = \"2-5g-3-J\", k = 2\nOutput: \"2-5G-3J\"\nExplanation: The string s has been split into three parts, each part has 2 characters except the first part as it could be shorter as mentioned above.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s consists of English letters, digits, and dashes '-'.\n * 1 <= k <= 104",
      "code": "class Solution {\npublic:\n    string licenseKeyFormatting(string s, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    string licenseKeyFormatting(string s, int k) {\n        int count = 0;\n        int n = s.length();\n        string ans = \"\";\n        for (int i = n - 1; i >= 0; i--) {\n            if (s[i] != '-') {\n                ans.push_back(toupper(s[i]));\n                count++;\n                if (count == k) {\n                    ans.push_back('-');\n                    count = 0;\n                }\n            }\n        }\n        if (ans.size() > 0 && ans.back() == '-') {\n           ans.pop_back();\n        }\n        reverse(ans.begin(), ans.end());\n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    string licenseKeyFormatting(string s, int k) {\n        int totalChars = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (s[i] != '-') {\n                totalChars++;\n            }\n        }\n        int sizeOfFirstGroup = (totalChars % k);\n        if (sizeOfFirstGroup == 0) {\n            sizeOfFirstGroup = k;\n        }\n        string ans = \"\";\n        int i = 0;\n        int count = 0;\n        \n        while (i < s.length()) {\n            if (count == sizeOfFirstGroup) {\n                count = 0;\n                break;\n            }\n            if (s[i] != '-') {\n                count++;\n                ans.push_back(toupper(s[i]));\n            }\n            i++;\n        }\n        /* This case will only appear if the value of k is greater than the total number \n           of alphanumeric characters in string s */\n        if (i >= s.length()) {\n            return ans;\n        }\n        \n        ans.push_back('-');\n        \n        while (i < s.length()) {\n            if (s[i] != '-') {\n                /* Whenever count is equal to k, we put a '-' after each group*/\n                if (count == k) {\n                    ans.push_back('-');\n                    count = 0;\n                }\n                ans.push_back(toupper(s[i]));\n                count++;\n            }\n            i++;\n        }\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 67,
      "question": "Can you solve this real interview question? Target Sum - You are given an integer array nums and an integer target.\n\nYou want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer in nums and then concatenate all the integers.\n\n * For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the expression \"+2-1\".\n\nReturn the number of different expressions that you can build, which evaluates to target.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n\n\nExample 2:\n\n\nInput: nums = [1], target = 1\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 20\n * 0 <= nums[i] <= 1000\n * 0 <= sum(nums[i]) <= 1000\n * -1000 <= target <= 1000",
      "code": "class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    int count = 0;\n    \n    public int findTargetSumWays(int[] nums, int S) {\n        calculate(nums, 0, 0, S);\n        return count;\n    }\n    \n    public void calculate(int[] nums, int i, int sum, int S) {\n        if (i == nums.length) {\n            if (sum == S) {\n                count++;\n            }\n        } else {\n            calculate(nums, i + 1, sum + nums[i], S);\n            calculate(nums, i + 1, sum - nums[i], S);\n        }\n    }\n}",
        "public class Solution {\n    int total;\n    \n    public int findTargetSumWays(int[] nums, int S) {\n        total = Arrays.stream(nums).sum();\n        \n        int[][] memo = new int[nums.length][2 * total + 1];\n        for (int[] row : memo) {\n            Arrays.fill(row, Integer.MIN_VALUE);\n        }\n        return calculate(nums, 0, 0, S, memo);\n    }\n    \n    public int calculate(int[] nums, int i, int sum, int S, int[][] memo) {\n        if (i == nums.length) {\n            if (sum == S) {\n                return 1;\n            } else {\n                return 0;\n            }\n        } else {\n            if (memo[i][sum + total] != Integer.MIN_VALUE) {\n                return memo[i][sum + total];\n            }\n            int add = calculate(nums, i + 1, sum + nums[i], S, memo);\n            int subtract = calculate(nums, i + 1, sum - nums[i], S, memo);\n            memo[i][sum + total] = add + subtract;\n            return memo[i][sum + total];\n        }\n    }\n}",
        "public class Solution {\n    public int findTargetSumWays(int[] nums, int S) {\n        int total = Arrays.stream(nums).sum();\n        int[][] dp = new int[nums.length][2 * total + 1];\n        dp[0][nums[0] + total] = 1;\n        dp[0][-nums[0] + total] += 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            for (int sum = -total; sum <= total; sum++) {\n                if (dp[i - 1][sum + total] > 0) {\n                    dp[i][sum + nums[i] + total] += dp[i - 1][sum + total];\n                    dp[i][sum - nums[i] + total] += dp[i - 1][sum + total];\n                }\n            }\n        }\n        \n        return Math.abs(S) > total ? 0 : dp[nums.length - 1][S + total];\n    }\n}",
        "public class Solution {\n    public int findTargetSumWays(int[] nums, int S) {\n        int total = Arrays.stream(nums).sum();\n        int[] dp = new int[2 * total + 1];\n        dp[nums[0] + total] = 1;\n        dp[-nums[0] + total] += 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            int[] next = new int[2 * total + 1];\n            for (int sum = -total; sum <= total; sum++) {\n                if (dp[sum + total] > 0) {\n                    next[sum + nums[i] + total] += dp[sum + total];\n                    next[sum - nums[i] + total] += dp[sum + total];\n                }\n            }\n            dp = next;\n        }\n        \n        return Math.abs(S) > total ? 0 : dp[S + total];\n    }\n}"
      ]
    },
    {
      "number": 68,
      "question": "Can you solve this real interview question? Teemo Attacking - Our hero Teemo is attacking an enemy Ashe with poison attacks! When Teemo attacks Ashe, Ashe gets poisoned for a exactly duration seconds. More formally, an attack at second t will mean Ashe is poisoned during the inclusive time interval [t, t + duration - 1]. If Teemo attacks again before the poison effect ends, the timer for it is reset, and the poison effect will end duration seconds after the new attack.\n\nYou are given a non-decreasing integer array timeSeries, where timeSeries[i] denotes that Teemo attacks Ashe at second timeSeries[i], and an integer duration.\n\nReturn the total number of seconds that Ashe is poisoned.\n\n \n\nExample 1:\n\n\nInput: timeSeries = [1,4], duration = 2\nOutput: 4\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 4, Teemo attacks, and Ashe is poisoned for seconds 4 and 5.\nAshe is poisoned for seconds 1, 2, 4, and 5, which is 4 seconds in total.\n\n\nExample 2:\n\n\nInput: timeSeries = [1,2], duration = 2\nOutput: 3\nExplanation: Teemo's attacks on Ashe go as follows:\n- At second 1, Teemo attacks, and Ashe is poisoned for seconds 1 and 2.\n- At second 2 however, Teemo attacks again and resets the poison timer. Ashe is poisoned for seconds 2 and 3.\nAshe is poisoned for seconds 1, 2, and 3, which is 3 seconds in total.\n\n \n\nConstraints:\n\n * 1 <= timeSeries.length <= 104\n * 0 <= timeSeries[i], duration <= 107\n * timeSeries is sorted in non-decreasing order.",
      "code": "class Solution {\npublic:\n    int findPoisonedDuration(vector<int>& timeSeries, int \nduration) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n  public int findPoisonedDuration(int[] timeSeries, int duration) {\n    int n = timeSeries.length;\n    if (n == 0) return 0;\n\n    int total = 0;\n    for(int i = 0; i < n - 1; ++i)\n      total += Math.min(timeSeries[i + 1] - timeSeries[i], duration);\n    return total + duration;\n  }\n}"
      ]
    },
    {
      "number": 69,
      "question": "Can you solve this real interview question? Diagonal Traverse - Given an m x n matrix mat, return an array of all the elements of the array in a diagonal order.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/04/10/diag1-grid.jpg]\n\n\nInput: mat = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,4,7,5,3,6,8,9]\n\n\nExample 2:\n\n\nInput: mat = [[1,2],[3,4]]\nOutput: [1,2,3,4]\n\n\n \n\nConstraints:\n\n * m == mat.length\n * n == mat[i].length\n * 1 <= m, n <= 104\n * 1 <= m * n <= 104\n * -105 <= mat[i][j] <= 105",
      "code": "class Solution {\npublic:\n    vector<int> findDiagonalOrder(vector<vector<int>>& mat) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        \n        // Check for empty matrices\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        \n        // Variables to track the size of the matrix\n        int N = matrix.length;\n        int M = matrix[0].length;\n        \n        // The two arrays as explained in the algorithm\n        int[] result = new int[N*M];\n        int k = 0;\n        ArrayList<Integer> intermediate = new ArrayList<Integer>();\n        \n        // We have to go over all the elements in the first\n        // row and the last column to cover all possible diagonals\n        for (int d = 0; d < N + M - 1; d++) {\n            \n            // Clear the intermediate array every time we start\n            // to process another diagonal\n            intermediate.clear();\n            \n            // We need to figure out the \"head\" of this diagonal\n            // The elements in the first row and the last column\n            // are the respective heads.\n            int r = d < M ? 0 : d - M + 1;\n            int c = d < M ? d : M - 1;\n            \n            // Iterate until one of the indices goes out of scope\n            // Take note of the index math to go down the diagonal\n            while (r < N && c > -1) {\n                \n                intermediate.add(matrix[r][c]);\n                ++r;\n                --c;\n            }\n                \n            // Reverse even numbered diagonals. The\n            // article says we have to reverse odd \n            // numbered articles but here, the numbering\n            // is starting from 0 :P\n            if (d % 2 == 0) {\n                Collections.reverse(intermediate);\n            }\n            \n            for (int i = 0; i < intermediate.size(); i++) {\n                result[k++] = intermediate.get(i);\n            }\n        }\n        return result;\n    }\n}",
        "class Solution {\n    public int[] findDiagonalOrder(int[][] matrix) {\n        \n        // Check for empty matrices\n        if (matrix == null || matrix.length == 0) {\n            return new int[0];\n        }\n        \n        // Variables to track the size of the matrix\n        int N = matrix.length;\n        int M = matrix[0].length;\n        \n        // Incides that will help us progress through \n        // the matrix, one element at a time.\n        int row = 0, column = 0;\n        \n        // As explained in the article, this is the variable\n        // that helps us keep track of what direction we are\n        // processing the current diaonal\n        int direction = 1;\n        \n         // The final result array\n        int[] result = new int[N*M];\n        int r = 0;\n        \n        // The uber while loop which will help us iterate over all\n        // the elements in the array.\n        while (row < N && column < M) {\n            \n            // First and foremost, add the current element to \n            // the result matrix. \n            result[r++] = matrix[row][column];\n            \n            // Move along in the current diagonal depending upon\n            // the current direction.[i, j] -> [i - 1, j + 1] if \n            // going up and [i, j] -> [i + 1][j - 1] if going down.\n            int new_row = row + (direction == 1 ? -1 : 1);\n            int new_column = column + (direction == 1 ? 1 : -1);\n            \n            // Checking if the next element in the diagonal is within the\n            // bounds of the matrix or not. If it's not within the bounds,\n            // we have to find the next head. \n            if (new_row < 0 || new_row == N || new_column < 0 || new_column == M) {\n                \n                // If the current diagonal was going in the upwards\n                // direction.\n                if (direction == 1) {\n                    \n                    // For an upwards going diagonal having [i, j] as its tail\n                    // If [i, j + 1] is within bounds, then it becomes\n                    // the next head. Otherwise, the element directly below\n                    // i.e. the element [i + 1, j] becomes the next head\n                    row += (column == M - 1 ? 1 : 0) ;\n                    column += (column < M - 1 ? 1 : 0);\n                        \n                } else {\n                    \n                    // For a downwards going diagonal having [i, j] as its tail\n                    // if [i + 1, j] is within bounds, then it becomes\n                    // the next head. Otherwise, the element directly below\n                    // i.e. the element [i, j + 1] becomes the next head\n                    column += (row == N - 1 ? 1 : 0);\n                    row += (row < N - 1 ? 1 : 0);\n                }\n                    \n                // Flip the direction\n                direction = 1 - direction;        \n                        \n            } else {\n                \n                row = new_row;\n                column = new_column;\n            }\n        }\n        return result;      \n    }\n}"
      ]
    },
    {
      "number": 70,
      "question": "Can you solve this real interview question? Find Mode in Binary Search Tree - Given the root of a binary search tree (BST) with duplicates, return all the mode(s) [https://en.wikipedia.org/wiki/Mode_(statistics)] (i.e., the most frequently occurred element) in it.\n\nIf the tree has more than one mode, return them in any order.\n\nAssume a BST is defined as follows:\n\n * The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n * The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n * Both the left and right subtrees must also be binary search trees.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg]\n\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\n\nExample 2:\n\n\nInput: root = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * -105 <= Node.val <= 105\n\n \n\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        dfs(root, counter);\n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, unordered_map<int, int>& counter) {\n        if (node == nullptr) {\n            return;\n        }\n\n        counter[node->val]++;\n        dfs(node->left, counter);\n        dfs(node->right, counter);\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        vector<TreeNode*> stack;\n        stack.push_back(root);\n        \n        while (!stack.empty()) {\n            TreeNode* node = stack.back();\n            stack.pop_back();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                stack.push_back(node->left);\n            }\n            if (node->right != nullptr) {\n                stack.push_back(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        queue<TreeNode*> queue;\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            TreeNode* node = queue.front();\n            queue.pop();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                queue.push(node->left);\n            }\n            if (node->right != nullptr) {\n                queue.push(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        vector<int> values;\n        dfs(root, values);\n        \n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        vector<int> ans;\n        \n        for (int num : values) {\n            if (num == currNum) {\n                currStreak++;\n            } else {\n                currStreak = 1;\n                currNum = num;\n            }\n            \n            if (currStreak > maxStreak) {\n                ans = {};\n                maxStreak = currStreak;\n            }\n            \n            if (currStreak == maxStreak) {\n                ans.push_back(num);\n            }\n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, vector<int>& values) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        // Inorder traversal visits nodes in sorted order\n        dfs(node->left, values);\n        values.push_back(node->val);\n        dfs(node->right, values);\n    }\n};",
        "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n    \n    vector<int> findMode(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n    \n    void dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n\n        dfs(node->left);\n        \n        int num = node->val;\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n\n        \n        dfs(node->right);\n    }\n};",
        "class Solution {\npublic:   \n    vector<int> findMode(TreeNode* root) {\n        vector<int> ans;\n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        \n        TreeNode* curr = root;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                // Find the friend\n                TreeNode* friendNode = curr->left;\n                while (friendNode->right != nullptr) {\n                    friendNode = friendNode->right;\n                }\n                \n                friendNode->right = curr;\n                \n                // Delete the edge after using it\n                TreeNode* left = curr->left;\n                curr->left = nullptr;\n                curr = left;\n            } else {\n                // Handle the current node\n                int num = curr->val;\n                if (num == currNum) {\n                    currStreak++;\n                } else {\n                    currStreak = 1;\n                    currNum = num;\n                }\n\n                if (currStreak > maxStreak) {\n                    ans = {};\n                    maxStreak = currStreak;\n                }\n\n                if (currStreak == maxStreak) {\n                    ans.push_back(num);\n                }\n                \n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n\n    void add(int num) {\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n    }\n    \n    vector<int> findMode(TreeNode* root) {\n        TreeNode* curr = root;\n        TreeNode* friendNode;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                friendNode = curr->left;\n                while (friendNode->right != nullptr && friendNode->right != curr) {\n                    friendNode = friendNode->right;\n                }\n                \n                if (friendNode->right == nullptr) {\n                    friendNode->right = curr;\n                    curr = curr->left;\n                } else {\n                    friendNode->right = nullptr;\n                    add(curr->val);\n                    curr = curr->right;\n                }\n            } else {\n                add(curr->val);\n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 71,
      "question": "Can you solve this real interview question? Next Greater Element II - Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\n\nThe next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn't exist, return -1 for this number.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1's next greater number is 2; \nThe number 2 can't find next greater number. \nThe second 1's next greater number needs to search circularly, which is also 2.\n\n\nExample 2:\n\n\nInput: nums = [1,2,3,4,3]\nOutput: [2,3,4,-1,4]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * -109 <= nums[i] <= 109",
      "code": "class Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        " public class Solution {\n\n    public int[] nextGreaterElements(int[] nums) {\n        int[] res = new int[nums.length];\n        int[] doublenums = new int[nums.length * 2];\n        System.arraycopy(nums, 0, doublenums, 0, nums.length);\n        System.arraycopy(nums, 0, doublenums, nums.length, nums.length);\n        for (int i = 0; i < nums.length; i++) {\n            res[i]=-1;\n            for (int j = i + 1; j < doublenums.length; j++) {\n                if (doublenums[j] > doublenums[i]) {\n                    res[i] = doublenums[j];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}",
        " public class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int[] res = new int[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            res[i] = -1;\n            for (int j = 1; j < nums.length; j++) {\n                if (nums[(i + j) % nums.length] > nums[i]) {\n                    res[i] = nums[(i + j) % nums.length];\n                    break;\n                }\n            }\n        }\n        return res;\n    }\n}",
        "public class Solution {\n\n    public int[] nextGreaterElements(int[] nums) {\n        int[] res = new int[nums.length];\n        Stack<Integer> stack = new Stack<>();\n        for (int i = 2 * nums.length - 1; i >= 0; --i) {\n            while (!stack.empty() && nums[stack.peek()] <= nums[i % nums.length]) {\n                stack.pop();\n            }\n            res[i % nums.length] = stack.empty() ? -1 : nums[stack.peek()];\n            stack.push(i % nums.length);\n        }\n        return res;\n    }\n}"
      ]
    },
    {
      "number": 72,
      "question": "Can you solve this real interview question? Perfect Number - A perfect number [https://en.wikipedia.org/wiki/Perfect_number] is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.\n\nGiven an integer n, return true if n is a perfect number, otherwise return false.\n\n \n\nExample 1:\n\n\nInput: num = 28\nOutput: true\nExplanation: 28 = 1 + 2 + 4 + 7 + 14\n1, 2, 4, 7, and 14 are all divisors of 28.\n\n\nExample 2:\n\n\nInput: num = 7\nOutput: false\n\n\n \n\nConstraints:\n\n * 1 <= num <= 108",
      "code": "class Solution {\npublic:\n    bool checkPerfectNumber(int num) {\n        \n    }\n};",
      "solution": [
        "\npublic class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i < num; i++) {\n            if (num % i == 0) {\n                sum += i;\n            }\n\n        }\n        return sum == num;\n    }\n}\n",
        "\npublic class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i < num; i++) {\n            if (num % i == 0) {\n                sum += i;\n            }\n            if(sum>num) {\n                return false;\n            }\n        }\n        return sum == num;\n    }\n}\n",
        "\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 0) {\n            return false;\n        }\n        int sum = 0;\n        for (int i = 1; i * i <= num; i++) {\n            if (num % i == 0) {\n                sum += i;\n                if (i * i != num) {\n                    sum += num / i;\n                }\n\n            }\n        }\n        return sum - num == num;\n    }\n}\n",
        "public class Solution {\n    public int pn(int p) {\n        return (1 << (p - 1)) * ((1 << p) - 1);\n    }\n    public boolean checkPerfectNumber(int num) {\n        int[] primes=new int[]{2,3,5,7,13,17,19,31};\n        for (int prime: primes) {\n            if (pn(prime) == num)\n                return true;\n        }\n        return false;\n    }\n}\n"
      ]
    },
    {
      "number": 73,
      "question": "Can you solve this real interview question? Most Frequent Subtree Sum - Given the root of a binary tree, return the most frequent subtree sum. If there is a tie, return all the values with the highest frequency in any order.\n\nThe subtree sum of a node is defined as the sum of all the node values formed by the subtree rooted at that node (including the node itself).\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/04/24/freq1-tree.jpg]\n\n\nInput: root = [5,2,-3]\nOutput: [2,-3,4]\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/04/24/freq2-tree.jpg]\n\n\nInput: root = [5,2,-5]\nOutput: [2]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * -105 <= Node.val <= 105",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findFrequentTreeSum(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int findTreeSum(TreeNode* root) {\n        if (!root) {\n            return 0;\n        }\n        // Current root's tree's sum.\n        return root -> val + findTreeSum(root -> left) + findTreeSum(root -> right);\n    }\n    \n    void preOrderTraversal(TreeNode* root, unordered_map<int, int>& sumFreq, int& maxFreq) {\n        if (!root) {\n            return;\n        }\n        \n        // Find current node's tree's sum.\n        int currSum = findTreeSum(root);\n        sumFreq[currSum]++;\n        maxFreq = max(maxFreq, sumFreq[currSum]);\n        \n        // Iterate on left and right subtrees and find their sums.\n        preOrderTraversal(root -> left, sumFreq, maxFreq);\n        preOrderTraversal(root -> right, sumFreq, maxFreq);\n    }\n    \n    vector<int> findFrequentTreeSum(TreeNode* root) {\n        unordered_map<int, int> sumFreq;\n        int maxFreq = 0;\n        \n        // Traverse on all nodes one by one, and find it's tree's sum.\n        preOrderTraversal(root, sumFreq, maxFreq);\n        \n        vector<int> maxFreqSums;\n        for(auto& it : sumFreq) {\n            if (it.second == maxFreq) {\n                maxFreqSums.push_back(it.first);\n            }\n        }\n        \n        return maxFreqSums;\n    }\n};",
        "class Solution {\npublic:\n    int subtreeSum(TreeNode* root, unordered_map<int, int>& sumFreq, int& maxFreq) {\n        if (!root) {\n            return 0;\n        }\n        \n        // Get left and right subtree's sum.\n        int leftSubtreeSum = subtreeSum(root -> left, sumFreq, maxFreq);\n        int rightSubtreeSum = subtreeSum(root -> right, sumFreq, maxFreq);\n        \n        // Use the sum of subtrees to get the sum of the current tree.\n        int currSum = root -> val + leftSubtreeSum + rightSubtreeSum;\n        \n        sumFreq[currSum]++;\n        maxFreq = max(maxFreq, sumFreq[currSum]);\n        return currSum;\n    }\n    \n    vector<int> findFrequentTreeSum(TreeNode* root) {\n        unordered_map<int, int> sumFreq;\n        int maxFreq = 0;\n        \n        // Traverse on all nodes one by one, and find it's tree's sum.\n        subtreeSum(root, sumFreq, maxFreq);\n        \n        vector<int> maxFreqSums;\n        for(auto& it : sumFreq) {\n            if (it.second == maxFreq) {\n                maxFreqSums.push_back(it.first);\n            }\n        }\n        \n        return maxFreqSums;\n    }\n};"
      ]
    },
    {
      "number": 74,
      "question": "Can you solve this real interview question? Find Largest Value in Each Tree Row - Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/08/21/largest_e1.jpg]\n\n\nInput: root = [1,3,2,5,3,null,9]\nOutput: [1,3,9]\n\n\nExample 2:\n\n\nInput: root = [1,2,3]\nOutput: [1,3]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree will be in the range [0, 104].\n * -231 <= Node.val <= 231 - 1",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> largestValues(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> largestValues(TreeNode* root) {\n        if (root == nullptr) {\n            return vector<int>{};\n        }\n        \n        vector<int> ans;\n        queue<TreeNode*> queue;\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            int currentLength = queue.size();\n            int currMax = INT_MIN;\n            \n            for (int i = 0; i < currentLength; i++) {\n                TreeNode* node = queue.front();\n                queue.pop();\n                currMax = max(currMax, node->val);\n                \n                if (node->left) {\n                    queue.push(node->left);\n                }\n                \n                if (node->right) {\n                    queue.push(node->right);\n                }\n            }\n            \n            ans.push_back(currMax);\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> ans;\n    \n    vector<int> largestValues(TreeNode* root) {\n        dfs(root, 0);\n        return ans;\n    }\n    \n    void dfs(TreeNode* node, int depth) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        if (depth == ans.size()) {\n            ans.push_back(node->val);\n        } else {\n            ans[depth] = max(ans[depth], node->val);\n        }\n        \n        dfs(node->left, depth + 1);\n        dfs(node->right, depth + 1);\n    }\n};",
        "class Solution {\npublic:\n    vector<int> largestValues(TreeNode* root) {\n        if (root == nullptr) {\n            return vector<int>{};\n        }\n        \n        vector<int> ans;\n        stack<pair<TreeNode*, int>> stack;\n        stack.push(make_pair(root, 0));\n        \n        while (!stack.empty()) {\n            pair<TreeNode*, int> pair = stack.top();\n            stack.pop();\n            TreeNode* node = pair.first;\n            int depth = pair.second;\n            \n            if (depth == ans.size()) {\n                ans.push_back(node->val);\n            } else {\n                ans[depth] = max(ans[depth], node->val);\n            }\n            \n            if (node->left) {\n                stack.push(make_pair(node->left, depth + 1));\n            }\n            \n            if (node->right) {\n                stack.push(make_pair(node->right, depth + 1));\n            }\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 75,
      "question": "Can you solve this real interview question? Random Flip Matrix - There is an m x n binary grid matrix with all the values set 0 initially. Design an algorithm to randomly pick an index (i, j) where matrix[i][j] == 0 and flips it to 1. All the indices (i, j) where matrix[i][j] == 0 should be equally likely to be returned.\n\nOptimize your algorithm to minimize the number of calls made to the built-in random function of your language and optimize the time and space complexity.\n\nImplement the Solution class:\n\n * Solution(int m, int n) Initializes the object with the size of the binary matrix m and n.\n * int[] flip() Returns a random index [i, j] of the matrix where matrix[i][j] == 0 and flips it to 1.\n * void reset() Resets all the values of the matrix to be 0.\n\n \n\nExample 1:\n\n\nInput\n[\"Solution\", \"flip\", \"flip\", \"flip\", \"reset\", \"flip\"]\n[[3, 1], [], [], [], [], []]\nOutput\n[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]\n\nExplanation\nSolution solution = new Solution(3, 1);\nsolution.flip();  // return [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\nsolution.flip();  // return [2, 0], Since [1,0] was returned, [2,0] and [0,0]\nsolution.flip();  // return [0, 0], Based on the previously returned indices, only [0,0] can be returned.\nsolution.reset(); // All the values are reset to 0 and can be returned.\nsolution.flip();  // return [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.\n\n\n \n\nConstraints:\n\n * 1 <= m, n <= 104\n * There will be at least one free cell for each call to flip.\n * At most 1000 calls will be made to flip and reset.",
      "code": "class Solution {\npublic:\n    Solution(int m, int n) {\n        \n    }\n    \n    vector<int> flip() {\n        \n    }\n    \n    void reset() {\n        \n    }\n};\n\n/**\n * Your Solution object will be instantiated and called as \nsuch:\n * Solution* obj = new Solution(m, n);\n * vector<int> param_1 = obj->flip();\n * obj->reset();\n */",
      "solution": [
        "class Solution {\npublic:\n\n    unordered_map<int,int> V;\n    int nr, nc, rem;\n\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    //uniform random integer in [0, bound]\n    int randint(int bound) {\n        uniform_int_distribution<int> uni(0, bound);\n        return uni(rng);\n    }\n\n    Solution(int n_rows, int n_cols) {\n        nr = n_rows, nc = n_cols, rem = nr * nc;\n    }\n\n    vector<int> flip() {\n        int r = randint(--rem);\n        int x = V.count(r) ? V[r] : V[r] = r;\n        V[r] = V.count(rem) ? V[rem] : V[rem] = rem;\n        return {x / nc, x % nc};\n    }\n\n    void reset() {\n        V.clear();\n        rem = nr*nc;\n    }\n};",
        "class Solution {\npublic:\n\n    int nr, nc, rem, b_size;\n    vector<unordered_set<int>> buckets;\n\n    //c++11 random integer generation\n    mt19937 rng{random_device{}()};\n    //uniform random integer in [0, bound)\n    int randint(int bound) {\n        uniform_int_distribution<int> uni(0, bound - 1);\n        return uni(rng);\n    }\n\n    Solution(int n_rows, int n_cols) {\n        nr = n_rows, nc = n_cols, rem = nr * nc;\n        b_size = sqrt(nr * nc);\n        for (int i = 0; i < nr * nc; i += b_size)\n            buckets.push_back({});\n    }\n\n    vector<int> flip() {\n        int c = 0;\n        int c0 = 0;\n        int k = randint(rem);\n        for (auto& b1 : buckets) {\n            if (c0 + b_size - b1.size() > k) {\n                while (true) {\n                    if (!b1.count(c)) {\n                        if (c0 == k) {\n                            b1.insert(c);\n                            rem--;\n                            return {c / nc, c % nc};\n                        }\n                        c0++;\n                    }\n                    c++;\n                }\n            }\n            c += b_size;\n            c0 += b_size - b1.size();\n        }\n    }\n\n    void reset() {\n        for (auto& b1 : buckets)\n            b1.clear();\n        rem = nr * nc;\n    }\n};"
      ]
    },
    {
      "number": 76,
      "question": "Can you solve this real interview question? Longest Uncommon Subsequence I - Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.\n\nAn uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\n\nA subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n\n * For example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).\n\n \n\nExample 1:\n\n\nInput: a = \"aba\", b = \"cdc\"\nOutput: 3\nExplanation: One longest uncommon subsequence is \"aba\" because \"aba\" is a subsequence of \"aba\" but not \"cdc\".\nNote that \"cdc\" is also a longest uncommon subsequence.\n\n\nExample 2:\n\n\nInput: a = \"aaa\", b = \"bbb\"\nOutput: 3\nExplanation: The longest uncommon subsequences are \"aaa\" and \"bbb\".\n\n\nExample 3:\n\n\nInput: a = \"aaa\", b = \"aaa\"\nOutput: -1\nExplanation: Every subsequence of string a is also a subsequence of string b. Similarly, every subsequence of string b is also a subsequence of string a.\n\n\n \n\nConstraints:\n\n * 1 <= a.length, b.length <= 100\n * a and b consist of lower-case English letters.",
      "code": "class Solution {\npublic:\n    int findLUSlength(string a, string b) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public int findLUSlength(String a, String b) {\n        HashMap < String, Integer > map = new HashMap < > ();\n        for (String s: new String[] {a, b}) {\n            for (int i = 0; i < (1 << s.length()); i++) {\n                String t = \"\";\n                for (int j = 0; j < s.length(); j++) {\n                    if (((i >> j) & 1) != 0)\n                        t += s.charAt(j);\n                }\n                if (map.containsKey(t))\n                    map.put(t, map.get(t) + 1);\n                else\n                    map.put(t, 1);\n            }\n        }\n        int res = -1;\n        for (String s: map.keySet()) {\n            if (map.get(s) == 1)\n                res = Math.max(res, s.length());\n        }\n        return res;\n    }\n}\n",
        "public class Solution {\n    public int findLUSlength(String a, String b) {\n        if (a.equals(b))\n            return -1;\n        return Math.max(a.length(), b.length());\n    }\n}"
      ]
    },
    {
      "number": 77,
      "question": "Can you solve this real interview question? Continuous Subarray Sum - Given an integer array nums and an integer k, return true if nums has a good subarray or false otherwise.\n\nA good subarray is a subarray where:\n\n * its length is at least two, and\n * the sum of the elements of the subarray is a multiple of k.\n\nNote that:\n\n * A subarray is a contiguous part of the array.\n * An integer x is a multiple of k if there exists an integer n such that x = n * k. 0 is always a multiple of k.\n\n \n\nExample 1:\n\n\nInput: nums = [23,2,4,6,7], k = 6\nOutput: true\nExplanation: [2, 4] is a continuous subarray of size 2 whose elements sum up to 6.\n\n\nExample 2:\n\n\nInput: nums = [23,2,6,4,7], k = 6\nOutput: true\nExplanation: [23, 2, 6, 4, 7] is an continuous subarray of size 5 whose elements sum up to 42.\n42 is a multiple of 6 because 42 = 7 * 6 and 7 is an integer.\n\n\nExample 3:\n\n\nInput: nums = [23,2,6,4,7], k = 13\nOutput: false\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 0 <= nums[i] <= 109\n * 0 <= sum(nums[i]) <= 231 - 1\n * 1 <= k <= 231 - 1",
      "code": "class Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool checkSubarraySum(vector<int>& nums, int k) {\n    \t// initialize the hash map with index 0 for sum 0\n        unordered_map<int, int> hashMap{{0, 0}};\n        int sum = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            sum += nums[i];\n            // if the remainder sum % k occurs for the first time\n            if (!hashMap.count(sum % k))\n                hashMap[sum % k] = i + 1;\n            // if the subarray size is at least two\n            else if (hashMap[sum % k] < i)\n                return true;\n        }\n        return false;\n    }\n};"
      ]
    },
    {
      "number": 78,
      "question": "Can you solve this real interview question? Longest Word in Dictionary through Deleting - Given a string s and a string array dictionary, return the longest string in the dictionary that can be formed by deleting some of the given string characters. If there is more than one possible result, return the longest word with the smallest lexicographical order. If there is no possible result, return the empty string.\n\n \n\nExample 1:\n\n\nInput: s = \"abpcplea\", dictionary = [\"ale\",\"apple\",\"monkey\",\"plea\"]\nOutput: \"apple\"\n\n\nExample 2:\n\n\nInput: s = \"abpcplea\", dictionary = [\"a\",\"b\",\"c\"]\nOutput: \"a\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * 1 <= dictionary.length <= 1000\n * 1 <= dictionary[i].length <= 1000\n * s and dictionary[i] consist of lowercase English letters.",
      "code": "class Solution {\npublic:\n    string findLongestWord(string s, vector<string>& \ndictionary) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public String findLongestWord(String s, List < String > d) {\n        HashSet < String > set = new HashSet < > (d);\n        List < String > l = new ArrayList < > ();\n        generate(s, \"\", 0, l);\n        String max_str = \"\";\n        for (String str: l) {\n            if (set.contains(str))\n                if (str.length() > max_str.length() || (str.length() == max_str.length() && str.compareTo(max_str) < 0))\n                    max_str = str;\n        }\n        return max_str;\n    }\n    public void generate(String s, String str, int i, List < String > l) {\n        if (i == s.length())\n            l.add(str);\n        else {\n            generate(s, str + s.charAt(i), i + 1, l);\n            generate(s, str, i + 1, l);\n        }\n    }\n}",
        "public class Solution {\n    public String findLongestWord(String s, List < String > d) {\n        HashSet < String > set = new HashSet < > (d);\n        List < String > l = new ArrayList < > ();\n        for (int i = 0; i < (1 << s.length()); i++) {\n            String t = \"\";\n            for (int j = 0; j < s.length(); j++) {\n                if (((i >> j) & 1) != 0)\n                    t += s.charAt(j);\n            }\n            l.add(t);\n        }\n        String max_str = \"\";\n        for (String str: l) {\n            if (set.contains(str))\n                if (str.length() > max_str.length() || (str.length() == max_str.length() && str.compareTo(max_str) < 0))\n                    max_str = str;\n        }\n        return max_str;\n    }\n}",
        "public class Solution {\n    public boolean isSubsequence(String x, String y) {\n        int j = 0;\n        for (int i = 0; i < y.length() && j < x.length(); i++)\n            if (x.charAt(j) == y.charAt(i))\n                j++;\n        return j == x.length();\n    }\n    public String findLongestWord(String s, List < String > d) {\n        Collections.sort(d, new Comparator < String > () {\n            public int compare(String s1, String s2) {\n                return s2.length() != s1.length() ? s2.length() - s1.length() : s1.compareTo(s2);\n            }\n        });\n        for (String str: d) {\n            if (isSubsequence(str, s))\n                return str;\n        }\n        return \"\";\n    }\n}",
        "public class Solution {\n    public boolean isSubsequence(String x, String y) {\n        int j = 0;\n        for (int i = 0; i < y.length() && j < x.length(); i++)\n            if (x.charAt(j) == y.charAt(i))\n                j++;\n        return j == x.length();\n    }\n    public String findLongestWord(String s, List < String > d) {\n        String max_str = \"\";\n        for (String str: d) {\n            if (isSubsequence(str, s)) {\n                if (str.length() > max_str.length() || (str.length() == max_str.length() && str.compareTo(max_str) < 0))\n                    max_str = str;\n            }\n        }\n        return max_str;\n    }\n}"
      ]
    },
    {
      "number": 79,
      "question": "Can you solve this real interview question? Contiguous Array - Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.\n\n \n\nExample 1:\n\n\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n\n\nExample 2:\n\n\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * nums[i] is either 0 or 1.",
      "code": "class Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "\npublic class Solution {\n\n    public int findMaxLength(int[] nums) {\n        int maxlen = 0;\n        for (int start = 0; start < nums.length; start++) {\n            int zeroes = 0, ones = 0;\n            for (int end = start; end < nums.length; end++) {\n                if (nums[end] == 0) {\n                    zeroes++;\n                } else {\n                    ones++;\n                }\n                if (zeroes == ones) {\n                    maxlen = Math.max(maxlen, end - start + 1);\n                }\n            }\n        }\n        return maxlen;\n    }\n}\n",
        "\npublic class Solution {\n\n    public int findMaxLength(int[] nums) {\n        int[] arr = new int[2 * nums.length + 1];\n        Arrays.fill(arr, -2);\n        arr[nums.length] = -1;\n        int maxlen = 0, count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            count = count + (nums[i] == 0 ? -1 : 1);\n            if (arr[count + nums.length] >= -1) {\n                maxlen = Math.max(maxlen, i - arr[count + nums.length]);\n            } else {\n                arr[count + nums.length] = i;\n            }\n\n        }\n        return maxlen;\n    }\n}\n",
        "public class Solution {\n\n    public int findMaxLength(int[] nums) {\n        Map<Integer, Integer> map = new HashMap<>();\n        map.put(0, -1);\n        int maxlen = 0, count = 0;\n        for (int i = 0; i < nums.length; i++) {\n            count = count + (nums[i] == 1 ? 1 : -1);\n            if (map.containsKey(count)) {\n                maxlen = Math.max(maxlen, i - map.get(count));\n            } else {\n                map.put(count, i);\n            }\n        }\n        return maxlen;\n    }\n}\n"
      ]
    },
    {
      "number": 80,
      "question": "Can you solve this real interview question? Beautiful Arrangement - Suppose you have n integers labeled 1 through n. A permutation of those n integers perm (1-indexed) is considered a beautiful arrangement if for every i (1 <= i <= n), either of the following is true:\n\n * perm[i] is divisible by i.\n * i is divisible by perm[i].\n\nGiven an integer n, return the number of the beautiful arrangements that you can construct.\n\n \n\nExample 1:\n\n\nInput: n = 2\nOutput: 2\nExplanation: \nThe first beautiful arrangement is [1,2]:\n    - perm[1] = 1 is divisible by i = 1\n    - perm[2] = 2 is divisible by i = 2\nThe second beautiful arrangement is [2,1]:\n    - perm[1] = 2 is divisible by i = 1\n    - i = 2 is divisible by perm[2] = 1\n\n\nExample 2:\n\n\nInput: n = 1\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= n <= 15",
      "code": "class Solution {\npublic:\n    int countArrangement(int n) {\n        \n    }\n};",
      "solution": [
        "\npublic class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        int[] nums = new int[N];\n        for (int i = 1; i <= N; i++)\n            nums[i - 1] = i;\n        permute(nums, 0);\n        return count;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length - 1) {\n            int i;\n            for (i = 1; i <= nums.length; i++) {\n                if (nums[i - 1] % i != 0 && i % nums[i - 1] != 0)\n                    break;\n            }\n            if (i == nums.length + 1) {\n                count++;\n            }\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}\n",
        "\npublic class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        int[] nums = new int[N];\n        for (int i = 1; i <= N; i++)\n            nums[i - 1] = i;\n        permute(nums, 0);\n        return count;\n    }\n    public void permute(int[] nums, int l) {\n        if (l == nums.length) {\n            count++;\n        }\n        for (int i = l; i < nums.length; i++) {\n            swap(nums, i, l);\n            if (nums[l] % (l + 1) == 0 || (l + 1) % nums[l] == 0)\n                permute(nums, l + 1);\n            swap(nums, i, l);\n        }\n    }\n    public void swap(int[] nums, int x, int y) {\n        int temp = nums[x];\n        nums[x] = nums[y];\n        nums[y] = temp;\n    }\n}",
        "public class Solution {\n    int count = 0;\n    public int countArrangement(int N) {\n        boolean[] visited = new boolean[N + 1];\n        calculate(N, 1, visited);\n        return count;\n    }\n    public void calculate(int N, int pos, boolean[] visited) {\n        if (pos > N)\n            count++;\n        for (int i = 1; i <= N; i++) {\n            if (!visited[i] && (pos % i == 0 || i % pos == 0)) {\n                visited[i] = true;\n                calculate(N, pos + 1, visited);\n                visited[i] = false;\n            }\n        }\n    }\n}"
      ]
    },
    {
      "number": 81,
      "question": "Can you solve this real interview question? Complex Number Multiplication - A complex number [https://en.wikipedia.org/wiki/Complex_number] can be represented as a string on the form \"real+imaginaryi\" where:\n\n * real is the real part and is an integer in the range [-100, 100].\n * imaginary is the imaginary part and is an integer in the range [-100, 100].\n * i2 == -1.\n\nGiven two complex numbers num1 and num2 as strings, return a string of the complex number that represents their multiplications.\n\n \n\nExample 1:\n\n\nInput: num1 = \"1+1i\", num2 = \"1+1i\"\nOutput: \"0+2i\"\nExplanation: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i, and you need convert it to the form of 0+2i.\n\n\nExample 2:\n\n\nInput: num1 = \"1+-1i\", num2 = \"1+-1i\"\nOutput: \"0+-2i\"\nExplanation: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i, and you need convert it to the form of 0+-2i.\n\n\n \n\nConstraints:\n\n * num1 and num2 are valid complex numbers.",
      "code": "class Solution {\npublic:\n    string complexNumberMultiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "\npublic class Solution {\n\n    public String complexNumberMultiply(String a, String b) {\n        String x[] = a.split(\"\\\\+|i\");\n        String y[] = b.split(\"\\\\+|i\");\n        int a_real = Integer.parseInt(x[0]);\n        int a_img = Integer.parseInt(x[1]);\n        int b_real = Integer.parseInt(y[0]);\n        int b_img = Integer.parseInt(y[1]);\n        return (a_real * b_real - a_img * b_img) + \"+\" + (a_real * b_img + a_img * b_real) + \"i\";\n\n    }\n}\n"
      ]
    },
    {
      "number": 82,
      "question": "Can you solve this real interview question? Reverse String II - Given a string s and an integer k, reverse the first k characters for every 2k characters counting from the start of the string.\n\nIf there are fewer than k characters left, reverse all of them. If there are less than 2k but greater than or equal to k characters, then reverse the first k characters and leave the other as original.\n\n \n\nExample 1:\n\nInput: s = \"abcdefg\", k = 2\nOutput: \"bacdfeg\"\n\n\nExample 2:\n\nInput: s = \"abcd\", k = 2\nOutput: \"bacd\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 104\n * s consists of only lowercase English letters.\n * 1 <= k <= 104",
      "code": "class Solution {\npublic:\n    string reverseStr(string s, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String reverseStr(String s, int k) {\n        char[] a = s.toCharArray();\n        for (int start = 0; start < a.length; start += 2 * k) {\n            int i = start, j = Math.min(start + k - 1, a.length - 1);\n            while (i < j) {\n                char tmp = a[i];\n                a[i++] = a[j];\n                a[j--] = tmp;\n            }\n        }\n        return new String(a);\n    }\n}"
      ]
    },
    {
      "number": 83,
      "question": "Can you solve this real interview question? Number of Provinces - There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.\n\nA province is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.\n\nReturn the total number of provinces.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/12/24/graph1.jpg]\n\n\nInput: isConnected = [[1,1,0],[1,1,0],[0,0,1]]\nOutput: 2\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/12/24/graph2.jpg]\n\n\nInput: isConnected = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\n\n\n \n\nConstraints:\n\n * 1 <= n <= 200\n * n == isConnected.length\n * n == isConnected[i].length\n * isConnected[i][j] is 1 or 0.\n * isConnected[i][i] == 1\n * isConnected[i][j] == isConnected[j][i]",
      "code": "class Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    void dfs(int node, vector<vector<int>>& isConnected, vector<bool>& visit) {\n        visit[node] = true;\n        for (int i = 0; i < isConnected.size(); i++) {\n            if (isConnected[node][i] && !visit[i]) {\n                dfs(i, isConnected, visit);\n            }\n        }\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        int numberOfComponents = 0;\n        vector<bool> visit(n);\n\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                numberOfComponents++;\n                dfs(i, isConnected, visit);\n            }\n        }\n\n        return numberOfComponents;\n    }\n};",
        "class Solution {\npublic:\n    void bfs(int node, vector<vector<int>>& isConnected, vector<bool>& visit) {\n        queue<int> q;\n        q.push(node);\n        visit[node] = true;\n\n        while (!q.empty()) {\n            node = q.front();\n            q.pop();\n\n            for (int i = 0; i < isConnected.size(); i++) {\n                if (isConnected[node][i] && !visit[i]) {\n                    q.push(i);\n                    visit[i] = true;\n                }\n            }\n        }\n    }\n\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        int numberOfComponents = 0;\n        vector<bool> visit(n);\n\n        for (int i = 0; i < n; i++) {\n            if (!visit[i]) {\n                numberOfComponents++;\n                bfs(i, isConnected, visit);\n            }\n        }\n\n        return numberOfComponents;\n    }\n};",
        "class UnionFind {\nprivate:\n    vector<int> parent, rank;\n    int count;\n\npublic:\n    UnionFind(int size) {\n        parent.resize(size);\n        rank.resize(size, 0);\n        count = size;\n        for (int i = 0; i < size; i++) {\n            parent[i] = i;\n        }\n    }\n    int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    void union_set(int x, int y) {\n        int xset = find(x), yset = find(y);\n        if (rank[xset] < rank[yset]) {\n            parent[xset] = yset;\n        } else if (rank[xset] > rank[yset]) {\n            parent[yset] = xset;\n        } else {\n            parent[yset] = xset;\n            rank[xset]++;\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int findCircleNum(vector<vector<int>>& isConnected) {\n        int n = isConnected.size();\n        UnionFind dsu(n);\n        int numberOfComponents = n;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (isConnected[i][j] && dsu.find(i) != dsu.find(j)) {\n                    numberOfComponents--;\n                    dsu.union_set(i, j);\n                }\n            }\n        }\n\n        return numberOfComponents;\n    }\n};"
      ]
    },
    {
      "number": 84,
      "question": "Can you solve this real interview question? Human Traffic of Stadium - Table: Stadium\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| visit_date    | date    |\n| people        | int     |\n+---------------+---------+\nvisit_date is the column with unique values for this table.\nEach row of this table contains the visit date and visit id to the stadium with the number of people during the visit.\nAs the id increases, the date increases as well.\n\n\n \n\nWrite a solution to display the records with three or more rows with consecutive id's, and the number of people is greater than or equal to 100 for each.\n\nReturn the result table ordered by visit_date in ascending order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nStadium table:\n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 1    | 2017-01-01 | 10        |\n| 2    | 2017-01-02 | 109       |\n| 3    | 2017-01-03 | 150       |\n| 4    | 2017-01-04 | 99        |\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\nOutput: \n+------+------------+-----------+\n| id   | visit_date | people    |\n+------+------------+-----------+\n| 5    | 2017-01-05 | 145       |\n| 6    | 2017-01-06 | 1455      |\n| 7    | 2017-01-07 | 199       |\n| 8    | 2017-01-09 | 188       |\n+------+------------+-----------+\nExplanation: \nThe four rows with ids 5, 6, 7, and 8 have consecutive ids and each of them has >= 100 people attended. Note that row 8 was included even though the visit_date was not the next day after row 7.\nThe rows with ids 2 and 3 are not included because we need at least three consecutive ids.\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\n\n    df = stadium[stadium['people'] >= 100]\n    \n    df['flag'] = ((df['id'].diff() == 1) & (df['id'].diff().shift(1) == 1))\n    \n    df = df[(df['flag'] == True)| (df['flag'].shift(-1) == True) | (df['flag'].shift(-2) == True)]\n    \n    rreturn df.loc[:, df.columns != 'flag'].sort_values(by='visit_date')",
        "def human_traffic(stadium: pd.DataFrame) -> pd.DataFrame:\n\n    stadium = stadium[stadium['people'] >= 100]\n\n    stadium['rnk'] = range(len(stadium))\n\n    stadium['island'] = stadium.id - stadium.rnk\n\n    stadium['island_cnt'] = stadium.groupby(['island'], as_index=False).id.transform('count')\n\n    return stadium[stadium['island_cnt'] >= 3][['id', 'visit_date', 'people']].sort_values(by='visit_date')"
      ]
    },
    {
      "number": 85,
      "question": "Can you solve this real interview question? Can Place Flowers - You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\n\nGiven an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return true if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule and false otherwise.\n\n \n\nExample 1:\n\nInput: flowerbed = [1,0,0,0,1], n = 1\nOutput: true\n\n\nExample 2:\n\nInput: flowerbed = [1,0,0,0,1], n = 2\nOutput: false\n\n\n \n\nConstraints:\n\n * 1 <= flowerbed.length <= 2 * 104\n * flowerbed[i] is 0 or 1.\n * There are no two adjacent flowers in flowerbed.\n * 0 <= n <= flowerbed.length",
      "code": "class Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int count = 0;\n        for (int i = 0; i < flowerbed.size(); i++) {\n            // Check if the current plot is empty.\n            if (flowerbed[i] == 0) {\n                // Check if the left and right plots are empty.\n                bool emptyLeftPlot = (i == 0) || (flowerbed[i - 1] == 0);\n                bool emptyRightPlot = (i == flowerbed.size() - 1) || (flowerbed[i + 1] == 0);\n                \n                // If both plots are empty, we can plant a flower here.\n                if (emptyLeftPlot && emptyRightPlot) {\n                    flowerbed[i] = 1;\n                    count++;\n                }\n            }\n        }\n        return count >= n;\n    }\n};",
        "class Solution {\npublic:\n    bool canPlaceFlowers(vector<int>& flowerbed, int n) {\n        int count = 0;\n        for (int i = 0; i < flowerbed.size(); i++) {\n            // Check if the current plot is empty.\n            if (flowerbed[i] == 0) {\n                // Check if the left and right plots are empty.\n                bool emptyLeftPlot = (i == 0) || (flowerbed[i - 1] == 0);\n                bool emptyRightPlot = (i == flowerbed.size() - 1) || (flowerbed[i + 1] == 0);\n                \n                // If both plots are empty, we can plant a flower here.\n                if (emptyLeftPlot && emptyRightPlot) {\n                    flowerbed[i] = 1;\n                    count++;\n                    if (count >= n) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return count >= n;\n    }\n};"
      ]
    },
    {
      "number": 86,
      "question": "Can you solve this real interview question? Find Duplicate File in System - Given a list paths of directory info, including the directory path, and all the files with contents in this directory, return all the duplicate files in the file system in terms of their paths. You may return the answer in any order.\n\nA group of duplicate files consists of at least two files that have the same content.\n\nA single directory info string in the input list has the following format:\n\n * \"root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_content)\"\n\nIt means there are n files (f1.txt, f2.txt ... fn.txt) with content (f1_content, f2_content ... fn_content) respectively in the directory \"root/d1/d2/.../dm\". Note that n >= 1 and m >= 0. If m = 0, it means the directory is just the root directory.\n\nThe output is a list of groups of duplicate file paths. For each group, it contains all the file paths of the files that have the same content. A file path is a string that has the following format:\n\n * \"directory_path/file_name.txt\"\n\n \n\nExample 1:\n\nInput: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\",\"root 4.txt(efgh)\"]\nOutput: [[\"root/a/2.txt\",\"root/c/d/4.txt\",\"root/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n\n\nExample 2:\n\nInput: paths = [\"root/a 1.txt(abcd) 2.txt(efgh)\",\"root/c 3.txt(abcd)\",\"root/c/d 4.txt(efgh)\"]\nOutput: [[\"root/a/2.txt\",\"root/c/d/4.txt\"],[\"root/a/1.txt\",\"root/c/3.txt\"]]\n\n\n \n\nConstraints:\n\n * 1 <= paths.length <= 2 * 104\n * 1 <= paths[i].length <= 3000\n * 1 <= sum(paths[i].length) <= 5 * 105\n * paths[i] consist of English letters, digits, '/', '.', '(', ')', and ' '.\n * You may assume no files or directories share the same name in the same directory.\n * You may assume each given directory info represents a unique directory. A single blank space separates the directory path and file info.\n\n \n\nFollow up:\n\n * Imagine you are given a real file system, how will you search files? DFS or BFS?\n * If the file content is very large (GB level), how will you modify your solution?\n * If you can only read the file by 1kb each time, how will you modify your solution?\n * What is the time complexity of your modified solution? What is the most time-consuming part and memory-consuming part of it? How to optimize?\n * How to make sure the duplicated files you find are not false positive?",
      "code": "class Solution {\npublic:\n    vector<vector<string>> findDuplicate(vector<string>& \npaths) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public List < List < String >> findDuplicate(String[] paths) {\n        List < String[] > list = new ArrayList < > ();\n        for (String path: paths) {\n            String[] values = path.split(\" \");\n            for (int i = 1; i < values.length; i++) {\n                String[] name_cont = values[i].split(\"\\\\(\");\n                name_cont[1] = name_cont[1].replace(\")\", \"\");\n                list.add(new String[] {\n                    values[0] + \"/\" + name_cont[0], name_cont[1]\n                });\n            }\n        }\n        boolean[] visited = new boolean[list.size()];\n        List < List < String >> res = new ArrayList < > ();\n        for (int i = 0; i < list.size() - 1; i++) {\n            if (visited[i])\n                continue;\n            List < String > l = new ArrayList < > ();\n            for (int j = i + 1; j < list.size(); j++) {\n                if (list.get(i)[1].equals(list.get(j)[1])) {\n                    l.add(list.get(j)[0]);\n                    visited[j] = true;\n                }\n            }\n            if (l.size() > 0) {\n                l.add(list.get(i)[0]);\n                res.add(l);\n            }\n        }\n        return res;\n    }\n}\n",
        "\npublic class Solution {\n    public List < List < String >> findDuplicate(String[] paths) {\n        HashMap < String, List < String >> map = new HashMap < > ();\n        for (String path: paths) {\n            String[] values = path.split(\" \");\n            for (int i = 1; i < values.length; i++) {\n                String[] name_cont = values[i].split(\"\\\\(\");\n                name_cont[1] = name_cont[1].replace(\")\", \"\");\n                List < String > list = map.getOrDefault(name_cont[1], new ArrayList < String > ());\n                list.add(values[0] + \"/\" + name_cont[0]);\n                map.put(name_cont[1], list);\n            }\n        }\n        List < List < String >> res = new ArrayList < > ();\n        for (String key: map.keySet()) {\n            if (map.get(key).size() > 1)\n                res.add(map.get(key));\n        }\n        return res;\n    }\n}"
      ]
    },
    {
      "number": 87,
      "question": "Can you solve this real interview question? Valid Triangle Number - Given an integer array nums, return the number of triplets chosen from the array that can make triangles if we take them as side lengths of a triangle.\n\n \n\nExample 1:\n\n\nInput: nums = [2,2,3,4]\nOutput: 3\nExplanation: Valid combinations are: \n2,3,4 (using the first 2)\n2,3,4 (using the second 2)\n2,2,3\n\n\nExample 2:\n\n\nInput: nums = [4,2,3,4]\nOutput: 4\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 1000\n * 0 <= nums[i] <= 1000",
      "code": "class Solution {\npublic:\n    int triangleNumber(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        for (int i = 0; i < nums.length - 2; i++) {\n            for (int j = i + 1; j < nums.length - 1; j++) {\n                for (int k = j + 1; k < nums.length; k++) {\n                    if (nums[i] + nums[j] > nums[k] && \n                        nums[i] + nums[k] > nums[j] && \n                        nums[j] + nums[k] > nums[i]) {\n                        count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n}",
        "public class Solution {\n    int binarySearch(int nums[], int l, int r, int x) {\n        while (r >= l && r < nums.length) {\n            int mid = (l + r) / 2;\n            if (nums[mid] >= x)\n                r = mid - 1;\n            else\n                l = mid + 1;\n        }\n        return l;\n    }\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            int k = i + 2;\n            for (int j = i + 1; j < nums.length - 1 && nums[i] != 0; j++) {\n                k = binarySearch(nums, k, nums.length - 1, nums[i] + nums[j]);\n                count += k - j - 1;\n            }\n        }\n        return count;\n    }\n}",
        "public class Solution {\n    public int triangleNumber(int[] nums) {\n        int count = 0;\n        Arrays.sort(nums);\n        for (int i = 0; i < nums.length - 2; i++) {\n            int k = i + 2;\n            for (int j = i + 1; j < nums.length - 1 && nums[i] != 0; j++) {\n                while (k < nums.length && nums[i] + nums[j] > nums[k])\n                    k++;\n                count += k - j - 1;\n            }\n        }\n        return count;\n    }\n}"
      ]
    },
    {
      "number": 88,
      "question": "Can you solve this real interview question? Merge Two Binary Trees - You are given two binary trees root1 and root2.\n\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\n\nReturn the merged tree.\n\nNote: The merging process must start from the root nodes of both trees.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/02/05/merge.jpg]\n\n\nInput: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]\n\n\nExample 2:\n\n\nInput: root1 = [1], root2 = [1,2]\nOutput: [2,2]\n\n\n \n\nConstraints:\n\n * The number of nodes in both trees is in the range [0, 2000].\n * -104 <= Node.val <= 104",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        \n    }\n};",
      "solution": [
        "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        if (t2 == null)\n            return t1;\n        t1.val += t2.val;\n        t1.left = mergeTrees(t1.left, t2.left);\n        t1.right = mergeTrees(t1.right, t2.right);\n        return t1;\n    }\n}\n",
        "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\npublic class Solution {\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null)\n            return t2;\n        Stack < TreeNode[] > stack = new Stack < > ();\n        stack.push(new TreeNode[] {t1, t2});\n        while (!stack.isEmpty()) {\n            TreeNode[] t = stack.pop();\n            if (t[0] == null || t[1] == null) {\n                continue;\n            }\n            t[0].val += t[1].val;\n            if (t[0].left == null) {\n                t[0].left = t[1].left;\n            } else {\n                stack.push(new TreeNode[] {t[0].left, t[1].left});\n            }\n            if (t[0].right == null) {\n                t[0].right = t[1].right;\n            } else {\n                stack.push(new TreeNode[] {t[0].right, t[1].right});\n            }\n        }\n        return t1;\n    }\n}\n"
      ]
    },
    {
      "number": 89,
      "question": "Can you solve this real interview question? Smallest Range Covering Elements from K Lists - You have k lists of sorted integers in non-decreasing order. Find the smallest range that includes at least one number from each of the k lists.\n\nWe define the range [a, b] is smaller than range [c, d] if b - a < d - c or a < c if b - a == d - c.\n\n \n\nExample 1:\n\n\nInput: nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\nOutput: [20,24]\nExplanation: \nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\n\n\nExample 2:\n\n\nInput: nums = [[1,2,3],[1,2,3],[1,2,3]]\nOutput: [1,1]\n\n\n \n\nConstraints:\n\n * nums.length == k\n * 1 <= k <= 3500\n * 1 <= nums[i].length <= 50\n * -105 <= nums[i][j] <= 105\n * nums[i] is sorted in non-decreasing order.",
      "code": "class Solution {\npublic:\n    vector<int> smallestRange(vector<vector<int>>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int minx = 0, miny = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                for (int k = i; k < nums.size(); k++) {\n                    for (int l = (k == i ? j : 0); l < nums.get(k).size(); l++) {\n                        int min = Math.min(nums.get(i).get(j), nums.get(k).get(l));\n                        int max = Math.max(nums.get(i).get(j), nums.get(k).get(l));\n                        int n, m;\n                        for (m = 0; m < nums.size(); m++) {\n                            for (n = 0; n < nums.get(m).size(); n++) {\n                                if (nums.get(m).get(n) >= min && nums.get(m).get(n) <= max)\n                                    break;\n                            }\n                            if (n == nums.get(m).size())\n                                break;\n                        }\n                        if (m == nums.size()) {\n                            if (miny - minx > max - min || (miny - minx == max - min && minx > min)) {\n                                miny = max;\n                                minx = min;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return new int[] {minx, miny};\n    }\n}\n",
        "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int minx = 0;\n        int miny = Integer.MAX_VALUE;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = 0; j < nums.get(i).size(); j++) {\n                for (int k = i; k < nums.size(); k++) {\n                    for (int l = (k == i ? j : 0); l < nums.get(k).size(); l++) {\n                        int min = Math.min(nums.get(i).get(j), nums.get(k).get(l));\n                        int max = Math.max(nums.get(i).get(j), nums.get(k).get(l));\n                        int n, m;\n                        for (m = 0; m < nums.size(); m++) {\n                            n = Collections.binarySearch(nums.get(m), min);\n                            if (n < 0)\n                                n = -1 - n;\n                            if (n == nums.get(m).size() || nums.get(m).get(n) < min || nums.get(m).get(n) > max)\n                                break;\n                        }\n                        if (m == nums.size()) {\n                            if (miny - minx > max - min || (miny - minx == max - min && minx > min)) {\n                                miny = max;\n                                minx = min;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return new int[] {minx, miny};\n    }\n}",
        "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int minx = 0;\n        int miny = Integer.MAX_VALUE;\n        int[] next = new int[nums.size()];\n        boolean flag = true;\n        for (int i = 0; i < nums.size() && flag; i++) {\n            for (int j = 0; j < nums.get(i).size() && flag; j++) {\n                int min_i = 0, max_i = 0;\n                for (int k = 0; k < nums.size(); k++) {\n                    if (nums.get(min_i).get(next[min_i]) > nums.get(k).get(next[k]))\n                        min_i = k;\n                    if (nums.get(max_i).get(next[max_i]) < nums.get(k).get(next[k]))\n                        max_i = k;\n                }\n                if (miny - minx > nums.get(max_i).get(next[max_i]) - nums.get(min_i).get(next[min_i])) {\n                    miny = nums.get(max_i).get(next[max_i]);\n                    minx = nums.get(min_i).get(next[min_i]);\n                }\n                next[min_i]++;\n                if (next[min_i] == nums.get(min_i).size()) {\n                    flag = false;\n                }\n            }\n        }\n        return new int[] {minx, miny};\n    }\n}",
        "class Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        int minx = 0;\n        int miny = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n        int[] next = new int[nums.size()];\n        boolean flag = true;\n        \n        PriorityQueue <Integer> min_queue = new PriorityQueue <Integer> ((i, j) -> nums.get(i).get(next[i]) - nums.get(j).get(next[j]));\n        for (int i = 0; i < nums.size(); i++) {\n            min_queue.offer(i);\n            max = Math.max(max, nums.get(i).get(0));\n        }\n        for (int i = 0; i < nums.size() && flag; i++) {\n            for (int j = 0; j < nums.get(i).size() && flag; j++) {\n                int min_i = min_queue.poll();\n                if (miny - minx > max - nums.get(min_i).get(next[min_i])) {\n                    minx = nums.get(min_i).get(next[min_i]);\n                    miny = max;\n                }\n                next[min_i]++;\n                if (next[min_i] == nums.get(min_i).size()) {\n                    flag = false;\n                    break;\n                }\n                min_queue.offer(min_i);\n                max = Math.max(max, nums.get(min_i).get(next[min_i]));\n            }\n        }\n        return new int[] { minx, miny};\n    }\n}"
      ]
    },
    {
      "number": 90,
      "question": "Can you solve this real interview question? Sum of Square Numbers - Given a non-negative integer c, decide whether there're two integers a and b such that a2 + b2 = c.\n\n \n\nExample 1:\n\n\nInput: c = 5\nOutput: true\nExplanation: 1 * 1 + 2 * 2 = 5\n\n\nExample 2:\n\n\nInput: c = 3\nOutput: false\n\n\n \n\nConstraints:\n\n * 0 <= c <= 231 - 1",
      "code": "class Solution {\npublic:\n    bool judgeSquareSum(int c) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            for (long b = 0; b * b <= c; b++) {\n                if (a * a + b * b == c)\n                    return true;\n            }\n        }\n        return false;\n    }\n}",
        "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            int b =  c - (int)(a * a);\n            int i = 1, sum = 0;\n            while (sum < b) {\n                sum += i;\n                i += 2;\n            }\n            if (sum == b)\n                return true;\n        }\n        return false;\n    }\n}",
        "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            double b = Math.sqrt(c - a * a);\n            if (b == (int) b)\n                return true;\n        }\n        return false;\n    }\n}",
        "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (long a = 0; a * a <= c; a++) {\n            int b = c - (int)(a * a);\n            if (binary_search(0, b, b))\n                return true;\n        }\n        return false;\n    }\n    public boolean binary_search(long s, long e, int n) {\n        if (s > e)\n            return false;\n        long mid = s + (e - s) / 2;\n        if (mid * mid == n)\n            return true;\n        if (mid * mid > n)\n            return binary_search(s, mid - 1, n);\n        return binary_search(mid + 1, e, n);\n    }\n}",
        "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        for (int i = 2; i * i <= c; i++) {\n            int count = 0;\n            if (c % i == 0) {\n                while (c % i == 0) {\n                    count++;\n                    c /= i;\n                }\n                if (i % 4 == 3 && count % 2 != 0)\n                    return false;\n            }\n        }\n        return c % 4 != 3;\n    }\n}"
      ]
    },
    {
      "number": 91,
      "question": "Can you solve this real interview question? Shopping Offers - In LeetCode Store, there are n items to sell. Each item has a price. However, there are some special offers, and a special offer consists of one or more different kinds of items with a sale price.\n\nYou are given an integer array price where price[i] is the price of the ith item, and an integer array needs where needs[i] is the number of pieces of the ith item you want to buy.\n\nYou are also given an array special where special[i] is of size n + 1 where special[i][j] is the number of pieces of the jth item in the ith offer and special[i][n] (i.e., the last integer in the array) is the price of the ith offer.\n\nReturn the lowest price you have to pay for exactly certain items as given, where you could make optimal use of the special offers. You are not allowed to buy more items than you want, even if that would lower the overall price. You could use any of the special offers as many times as you want.\n\n \n\nExample 1:\n\n\nInput: price = [2,5], special = [[3,0,5],[1,2,10]], needs = [3,2]\nOutput: 14\nExplanation: There are two kinds of items, A and B. Their prices are $2 and $5 respectively. \nIn special offer 1, you can pay $5 for 3A and 0B\nIn special offer 2, you can pay $10 for 1A and 2B. \nYou need to buy 3A and 2B, so you may pay $10 for 1A and 2B (special offer #2), and $4 for 2A.\n\n\nExample 2:\n\n\nInput: price = [2,3,4], special = [[1,1,0,4],[2,2,1,9]], needs = [1,2,1]\nOutput: 11\nExplanation: The price of A is $2, and $3 for B, $4 for C. \nYou may pay $4 for 1A and 1B, and $9 for 2A ,2B and 1C. \nYou need to buy 1A ,2B and 1C, so you may pay $4 for 1A and 1B (special offer #1), and $3 for 1B, $4 for 1C. \nYou cannot add more items, though only $9 for 2A ,2B and 1C.\n\n\n \n\nConstraints:\n\n * n == price.length == needs.length\n * 1 <= n <= 6\n * 0 <= price[i], needs[i] <= 10\n * 1 <= special.length <= 100\n * special[i].length == n + 1\n * 0 <= special[i][j] <= 50",
      "code": "class Solution {\npublic:\n    int shoppingOffers(vector<int>& price, \nvector<vector<int>>& special, vector<int>& needs) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        return shopping(price, special, needs);\n    }\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        int j = 0, res = dot(needs, price);\n        for (List < Integer > s: special) {\n            ArrayList < Integer > clone = new ArrayList < > (needs);\n            for (j = 0; j < needs.size(); j++) {\n                int diff = clone.get(j) - s.get(j);\n                if (diff < 0)\n                    break;\n                clone.set(j, diff);\n            }\n            if (j == needs.size())\n                res = Math.min(res, s.get(j) + shopping(price, special, clone));\n        }\n        return res;\n    }\n    public int dot(List < Integer > a, List < Integer > b) {\n        int sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            sum += a.get(i) * b.get(i);\n        }\n        return sum;\n    }\n\n}",
        "public class Solution {\n    public int shoppingOffers(List < Integer > price, List < List < Integer >> special, List < Integer > needs) {\n        Map < List < Integer > , Integer > map = new HashMap();\n        return shopping(price, special, needs, map);\n    }\n    public int shopping(List < Integer > price, List < List < Integer >> special, List < Integer > needs, Map < List < Integer > , Integer > map) {\n        if (map.containsKey(needs))\n            return map.get(needs);\n        int j = 0, res = dot(needs, price);\n        for (List < Integer > s: special) {\n            ArrayList < Integer > clone = new ArrayList < > (needs);\n            for (j = 0; j < needs.size(); j++) {\n                int diff = clone.get(j) - s.get(j);\n                if (diff < 0)\n                    break;\n                clone.set(j, diff);\n            }\n            if (j == needs.size())\n                res = Math.min(res, s.get(j) + shopping(price, special, clone, map));\n        }\n        map.put(needs, res);\n        return res;\n    }\n    public int dot(List < Integer > a, List < Integer > b) {\n        int sum = 0;\n        for (int i = 0; i < a.size(); i++) {\n            sum += a.get(i) * b.get(i);\n        }\n        return sum;\n    }\n\n}"
      ]
    },
    {
      "number": 92,
      "question": "Can you solve this real interview question? Decode Ways II - A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n\n\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\n * \"AAJF\" with the grouping (1 1 10 6)\n * \"KJF\" with the grouping (11 10 6)\n\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n\nIn addition to the mapping above, an encoded message may contain the '*' character, which can represent any digit from '1' to '9' ('0' is excluded). For example, the encoded message \"1*\" may represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\". Decoding \"1*\" is equivalent to decoding any of the encoded messages it can represent.\n\nGiven a string s consisting of digits and '*' characters, return the number of ways to decode it.\n\nSince the answer may be very large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: s = \"*\"\nOutput: 9\nExplanation: The encoded message can represent any of the encoded messages \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", or \"9\".\nEach of these can be decoded to the strings \"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", and \"I\" respectively.\nHence, there are a total of 9 ways to decode \"*\".\n\n\nExample 2:\n\n\nInput: s = \"1*\"\nOutput: 18\nExplanation: The encoded message can represent any of the encoded messages \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", or \"19\".\nEach of these encoded messages have 2 ways to be decoded (e.g. \"11\" can be decoded to \"AA\" or \"K\").\nHence, there are a total of 9 * 2 = 18 ways to decode \"1*\".\n\n\nExample 3:\n\n\nInput: s = \"2*\"\nOutput: 15\nExplanation: The encoded message can represent any of the encoded messages \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", or \"29\".\n\"21\", \"22\", \"23\", \"24\", \"25\", and \"26\" have 2 ways of being decoded, but \"27\", \"28\", and \"29\" only have 1 way.\nHence, there are a total of (6 * 2) + (3 * 1) = 12 + 3 = 15 ways to decode \"2*\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s[i] is a digit or '*'.",
      "code": "class Solution {\npublic:\n    int numDecodings(string s) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    int M = 1000000007;\n    public int numDecodings(String s) {\n        Long[] memo = new Long[s.length()];\n        return (int) ways(s, s.length() - 1, memo);\n    }\n    public long ways(String s, int i, Long[] memo) {\n        if (i < 0)\n            return 1;\n        if (memo[i] != null)\n            return memo[i];\n        if (s.charAt(i) == '*') {\n            long res = 9 * ways(s, i - 1, memo) % M;\n            if (i > 0 && s.charAt(i - 1) == '1')\n                res = (res + 9 * ways(s, i - 2, memo)) % M;\n            else if (i > 0 && s.charAt(i - 1) == '2')\n                res = (res + 6 * ways(s, i - 2, memo)) % M;\n            else if (i > 0 && s.charAt(i - 1) == '*')\n                res = (res + 15 * ways(s, i - 2, memo)) % M;\n            memo[i] = res;\n            return memo[i];\n        }\n        long res = s.charAt(i) != '0' ? ways(s, i - 1, memo) : 0;\n        if (i > 0 && s.charAt(i - 1) == '1')\n            res = (res + ways(s, i - 2, memo)) % M;\n        else if (i > 0 && s.charAt(i - 1) == '2' && s.charAt(i) <= '6')\n            res = (res + ways(s, i - 2, memo)) % M;\n        else if (i > 0 && s.charAt(i - 1) == '*')\n            res = (res + (s.charAt(i) <= '6' ? 2 : 1) * ways(s, i - 2, memo)) % M;\n        memo[i] = res;\n        return memo[i];\n    }\n}",
        "public class Solution {\n    int M = 1000000007;\n    public int numDecodings(String s) {\n        long[] dp = new long[s.length() + 1];\n        dp[0] = 1;\n        dp[1] = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;\n        for (int i = 1; i < s.length(); i++) {\n            if (s.charAt(i) == '*') {\n                dp[i + 1] = 9 * dp[i] % M;\n                if (s.charAt(i - 1) == '1')\n                    dp[i + 1] = (dp[i + 1] + 9 * dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '2')\n                    dp[i + 1] = (dp[i + 1] + 6 * dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '*')\n                    dp[i + 1] = (dp[i + 1] + 15 * dp[i - 1]) % M;\n            } else {\n                dp[i + 1] = s.charAt(i) != '0' ? dp[i] : 0;\n                if (s.charAt(i - 1) == '1')\n                    dp[i + 1] = (dp[i + 1] + dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '2' && s.charAt(i) <= '6')\n                    dp[i + 1] = (dp[i + 1] + dp[i - 1]) % M;\n                else if (s.charAt(i - 1) == '*')\n                    dp[i + 1] = (dp[i + 1] + (s.charAt(i) <= '6' ? 2 : 1) * dp[i - 1]) % M;\n            }\n        }\n        return (int) dp[s.length()];\n    }\n}",
        "public class Solution {\n    int M = 1000000007;\n    public int numDecodings(String s) {\n        long first = 1, second = s.charAt(0) == '*' ? 9 : s.charAt(0) == '0' ? 0 : 1;\n        for (int i = 1; i < s.length(); i++) {\n            long temp = second;\n            if (s.charAt(i) == '*') {\n                second = 9 * second % M;\n                if (s.charAt(i - 1) == '1')\n                    second = (second + 9 * first) % M;\n                else if (s.charAt(i - 1) == '2')\n                    second = (second + 6 * first) % M;\n                else if (s.charAt(i - 1) == '*')\n                    second = (second + 15 * first) % M;\n            } else {\n                second = s.charAt(i) != '0' ? second : 0;\n                if (s.charAt(i - 1) == '1')\n                    second = (second + first) % M;\n                else if (s.charAt(i - 1) == '2' && s.charAt(i) <= '6')\n                    second = (second + first) % M;\n                else if (s.charAt(i - 1) == '*')\n                    second = (second + (s.charAt(i) <= '6' ? 2 : 1) * first) % M;\n            }\n            first = temp;\n        }\n        return (int) second;\n    }\n}"
      ]
    },
    {
      "number": 93,
      "question": "Can you solve this real interview question? Solve the Equation - Solve a given equation and return the value of 'x' in the form of a string \"x=#value\". The equation contains only '+', '-' operation, the variable 'x' and its coefficient. You should return \"No solution\" if there is no solution for the equation, or \"Infinite solutions\" if there are infinite solutions for the equation.\n\nIf there is exactly one solution for the equation, we ensure that the value of 'x' is an integer.\n\n \n\nExample 1:\n\n\nInput: equation = \"x+5-3+x=6+x-2\"\nOutput: \"x=2\"\n\n\nExample 2:\n\n\nInput: equation = \"x=x\"\nOutput: \"Infinite solutions\"\n\n\nExample 3:\n\n\nInput: equation = \"2x=x\"\nOutput: \"x=0\"\n\n\n \n\nConstraints:\n\n * 3 <= equation.length <= 1000\n * equation has exactly one '='.\n * equation consists of integers with an absolute value in the range [0, 100] without any leading zeros, and the variable 'x'.",
      "code": "class Solution {\npublic:\n    string solveEquation(string equation) {\n        \n    }\n};",
      "solution": [
        "\npublic class Solution {\n    public String coeff(String x) {\n        if (x.length() > 1 && x.charAt(x.length() - 2) >= '0' && x.charAt(x.length() - 2) <= '9')\n            return x.replace(\"x\", \"\");\n        return x.replace(\"x\", \"1\");\n    }\n    public String solveEquation(String equation) {\n        String[] lr = equation.split(\"=\");\n        int lhs = 0, rhs = 0;\n        for (String x: breakIt(lr[0])) {\n            if (x.indexOf(\"x\") >= 0) {\n                lhs += Integer.parseInt(coeff(x));\n            } else\n                rhs -= Integer.parseInt(x);\n        }\n        for (String x: breakIt(lr[1])) {\n            if (x.indexOf(\"x\") >= 0)\n                lhs -= Integer.parseInt(coeff(x));\n            else\n                rhs += Integer.parseInt(x);\n        }\n        if (lhs == 0) {\n            if (rhs == 0)\n                return \"Infinite solutions\";\n            else\n                return \"No solution\";\n        }\n        return \"x=\" + rhs / lhs;\n    }\n    public List < String > breakIt(String s) {\n        List < String > res = new ArrayList < > ();\n        String r = \"\";\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) == '+' || s.charAt(i) == '-') {\n                if (r.length() > 0)\n                    res.add(r);\n                r = \"\" + s.charAt(i);\n            } else\n                r += s.charAt(i);\n        }\n        res.add(r);\n        return res;\n    }\n}\n",
        "\npublic class Solution {\n    public String coeff(String x) {\n        if (x.length() > 1 && x.charAt(x.length() - 2) >= '0' && x.charAt(x.length() - 2) <= '9')\n            return x.replace(\"x\", \"\");\n        return x.replace(\"x\", \"1\");\n    }\n    public String solveEquation(String equation) {\n        String[] lr = equation.split(\"=\");\n        int lhs = 0, rhs = 0;\n        for (String x: lr[0].split(\"(?=\\\\+)|(?=-)\")) {\n            if (x.indexOf(\"x\") >= 0) {\n\n                lhs += Integer.parseInt(coeff(x));\n            } else\n                rhs -= Integer.parseInt(x);\n        }\n        for (String x: lr[1].split(\"(?=\\\\+)|(?=-)\")) {\n            if (x.indexOf(\"x\") >= 0)\n                lhs -= Integer.parseInt(coeff(x));\n            else\n                rhs += Integer.parseInt(x);\n        }\n        if (lhs == 0) {\n            if (rhs == 0)\n                return \"Infinite solutions\";\n            else\n                return \"No solution\";\n        } else\n            return \"x=\" + rhs / lhs;\n    }\n}\n\n"
      ]
    },
    {
      "number": 94,
      "question": "Can you solve this real interview question? Replace Words - In English, we have a concept called root, which can be followed by some other word to form another longer word - let's call this word successor. For example, when the root \"an\" is followed by the successor word \"other\", we can form a new word \"another\".\n\nGiven a dictionary consisting of many roots and a sentence consisting of words separated by spaces, replace all the successors in the sentence with the root forming it. If a successor can be replaced by more than one root, replace it with the root that has the shortest length.\n\nReturn the sentence after the replacement.\n\n \n\nExample 1:\n\n\nInput: dictionary = [\"cat\",\"bat\",\"rat\"], sentence = \"the cattle was rattled by the battery\"\nOutput: \"the cat was rat by the bat\"\n\n\nExample 2:\n\n\nInput: dictionary = [\"a\",\"b\",\"c\"], sentence = \"aadsfasf absbs bbab cadsfafs\"\nOutput: \"a a b c\"\n\n\n \n\nConstraints:\n\n * 1 <= dictionary.length <= 1000\n * 1 <= dictionary[i].length <= 100\n * dictionary[i] consists of only lower-case letters.\n * 1 <= sentence.length <= 106\n * sentence consists of only lower-case letters and spaces.\n * The number of words in sentence is in the range [1, 1000]\n * The length of each word in sentence is in the range [1, 1000]\n * Every two consecutive words in sentence will be separated by exactly one space.\n * sentence does not have leading or trailing spaces.",
      "code": "class Solution {\npublic:\n    string replaceWords(vector<string>& dictionary, string \nsentence) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String replaceWords(List<String> roots, String sentence) {\n        Set<String> rootset = new HashSet();\n        for (String root: roots) rootset.add(root);\n\n        StringBuilder ans = new StringBuilder();\n        for (String word: sentence.split(\"\\\\s+\")) {\n            String prefix = \"\";\n            for (int i = 1; i <= word.length(); ++i) {\n                prefix = word.substring(0, i);\n                if (rootset.contains(prefix)) break;\n            }\n            if (ans.length() > 0) ans.append(\" \");\n            ans.append(prefix);\n        }\n        return ans.toString();\n    }\n}",
        "class Solution {\n    public String replaceWords(List<String> roots, String sentence) {\n        TrieNode trie = new TrieNode();\n        for (String root: roots) {\n            TrieNode cur = trie;\n            for (char letter: root.toCharArray()) {\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n            }\n            cur.word = root;\n        }\n\n        StringBuilder ans = new StringBuilder();\n\n        for (String word: sentence.split(\"\\\\s+\")) {\n            if (ans.length() > 0)\n                ans.append(\" \");\n\n            TrieNode cur = trie;\n            for (char letter: word.toCharArray()) {\n                if (cur.children[letter - 'a'] == null || cur.word != null)\n                    break;\n                cur = cur.children[letter - 'a'];\n            }\n            ans.append(cur.word != null ? cur.word : word);\n        }\n        return ans.toString();\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    String word;\n    TrieNode() {\n        children = new TrieNode[26];\n    }\n}"
      ]
    },
    {
      "number": 95,
      "question": "Can you solve this real interview question? 2 Keys Keyboard - There is only one character 'A' on the screen of a notepad. You can perform one of two operations on this notepad for each step:\n\n * Copy All: You can copy all the characters present on the screen (a partial copy is not allowed).\n * Paste: You can paste the characters which are copied last time.\n\nGiven an integer n, return the minimum number of operations to get the character 'A' exactly n times on the screen.\n\n \n\nExample 1:\n\n\nInput: n = 3\nOutput: 3\nExplanation: Initially, we have one character 'A'.\nIn step 1, we use Copy All operation.\nIn step 2, we use Paste operation to get 'AA'.\nIn step 3, we use Paste operation to get 'AAA'.\n\n\nExample 2:\n\n\nInput: n = 1\nOutput: 0\n\n\n \n\nConstraints:\n\n * 1 <= n <= 1000",
      "code": "class Solution {\npublic:\n    int minSteps(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minSteps(int n) {\n        int ans = 0, d = 2;\n        while (n > 1) {\n            while (n % d == 0) {\n                ans += d;\n                n /= d;\n            }\n            d++;\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 96,
      "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
      "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
      ]
    },
    {
      "number": 97,
      "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
      "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 98,
      "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
      ]
    },
    {
      "number": 99,
      "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
      ]
    },
    {
      "number": 100,
      "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
      "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
      ]
    },
    {
      "number": 101,
      "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
      "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
      ]
    },
    {
      "number": 102,
      "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
      "solution": [
        "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
        "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
      ]
    },
    {
      "number": 103,
      "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
        "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
      ]
    },
    {
      "number": 104,
      "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
      ]
    },
    {
      "number": 105,
      "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
      "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
      ]
    },
    {
      "number": 106,
      "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
      ]
    },
    {
      "number": 107,
      "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
      "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
        "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 108,
      "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
      "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
      ]
    },
    {
      "number": 109,
      "question": "Can you solve this real interview question? Kth Largest Element in a Stream - Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\n\nImplement KthLargest class:\n\n * KthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\n * int add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.\n\n \n\nExample 1:\n\n\nInput\n[\"KthLargest\", \"add\", \"add\", \"add\", \"add\", \"add\"]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n\n\n \n\nConstraints:\n\n * 1 <= k <= 104\n * 0 <= nums.length <= 104\n * -104 <= nums[i] <= 104\n * -104 <= val <= 104\n * At most 104 calls will be made to add.\n * It is guaranteed that there will be at least k elements in the array when you search for the kth element.",
      "code": "class KthLargest {\npublic:\n    KthLargest(int k, vector<int>& nums) {\n        \n    }\n    \n    int add(int val) {\n        \n    }\n};\n\n/**\n * Your KthLargest object will be instantiated and called \nas such:\n * KthLargest* obj = new KthLargest(k, nums);\n * int param_1 = obj->add(val);\n */",
      "solution": [
        "class KthLargest {\n    private static int k;\n    private PriorityQueue<Integer> heap;\n    \n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        heap = new PriorityQueue<>();\n        \n        for (int num: nums) {\n            heap.offer(num);\n        }\n        \n        while (heap.size() > k) {\n            heap.poll();\n        }\n    }\n    \n    public int add(int val) {\n        heap.offer(val);\n        if (heap.size() > k) {\n            heap.poll();\n        }\n\n        return heap.peek();\n    }\n}"
      ]
    },
    {
      "number": 110,
      "question": "Can you solve this real interview question? Binary Search - Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\n\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n\n\nExample 2:\n\n\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * -104 < nums[i], target < 104\n * All the integers in nums are unique.\n * nums is sorted in ascending order.",
      "code": "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Set the left and right boundaries\n        int left = 0, right = int(nums.size()) - 1;\n        \n        // Under this condition\n        while (left <= right) {\n            // Get the middle index and the middle value.\n            int mid = left + (right - left) / 2;\n            \n            // Case 1, return the middle index.\n            if (nums[mid] == target) {\n                return mid;\n            } \n            // Case 2, discard the smaller half.\n            else if (nums[mid] < target) {\n                left = mid + 1;   \n            } \n            // Case 3, discard the larger half.\n            else {\n                right = mid - 1;\n            }\n        }\n        \n        // If we finish the search without finding target, return -1.\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Set the left and right boundaries\n        int left = 0, right = int(nums.size());\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        \n        if (left > 0 and nums[left - 1] == target) {\n            return left - 1;\n        } else {\n            return -1;\n        }\n    }\n};",
        "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Set the left and right boundaries\n        int left = 0, right = int(nums.size());\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] >= target) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        if (left < nums.size() and nums[left] == target) {\n            return left;\n        } else {\n            return -1;\n        }\n    }\n};",
        "class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // Find the insertion position `idx`.\n        int idx = upper_bound(nums.begin(), nums.end(), target) - nums.begin();\n\n        if (idx > 0 && nums[idx - 1] == target) {\n            return idx - 1;\n        } else {\n            return -1;\n        }    \n    }\n};"
      ]
    },
    {
      "number": 111,
      "question": "Can you solve this real interview question? Find K-th Smallest Pair Distance - The distance of a pair of integers a and b is defined as the absolute difference between a and b.\n\nGiven an integer array nums and an integer k, return the kth smallest distance among all the pairs nums[i] and nums[j] where 0 <= i < j < nums.length.\n\n \n\nExample 1:\n\n\nInput: nums = [1,3,1], k = 1\nOutput: 0\nExplanation: Here are all the pairs:\n(1,3) -> 2\n(1,1) -> 0\n(3,1) -> 2\nThen the 1st smallest distance pair is (1,1), and its distance is 0.\n\n\nExample 2:\n\n\nInput: nums = [1,1,1], k = 2\nOutput: 0\n\n\nExample 3:\n\n\nInput: nums = [1,6,1], k = 3\nOutput: 5\n\n\n \n\nConstraints:\n\n * n == nums.length\n * 2 <= n <= 104\n * 0 <= nums[i] <= 106\n * 1 <= k <= n * (n - 1) / 2",
      "code": "class Solution {\npublic:\n    int smallestDistancePair(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        PriorityQueue<Node> heap = new PriorityQueue<Node>(nums.length,\n            Comparator.<Node> comparingInt(node -> nums[node.nei] - nums[node.root]));\n        for (int i = 0; i + 1 < nums.length; ++i) {\n            heap.offer(new Node(i, i+1));\n        }\n\n        Node node = null;\n        for (; k > 0; --k) {\n            node = heap.poll();\n            if (node.nei + 1 < nums.length) {\n                heap.offer(new Node(node.root, node.nei + 1));\n            }\n        }\n        return nums[node.nei] - nums[node.root];\n    }\n}\nclass Node {\n    int root;\n    int nei;\n    Node(int r, int n) {\n        root = r;\n        nei = n;\n    }\n}",
        "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int WIDTH = 2 * nums[nums.length - 1];\n\n        //multiplicity[i] = number of nums[j] == nums[i] (j < i)\n        int[] multiplicity = new int[nums.length];\n        for (int i = 1; i < nums.length; ++i) {\n            if (nums[i] == nums[i-1]) {\n                multiplicity[i] = 1 + multiplicity[i - 1];\n            }\n        }\n\n        //prefix[v] = number of values <= v\n        int[] prefix = new int[WIDTH];\n        int left = 0;\n        for (int i = 0; i < WIDTH; ++i) {\n            while (left < nums.length && nums[left] == i) left++;\n            prefix[i] = left;\n        }\n\n        int lo = 0;\n        int hi = nums[nums.length - 1] - nums[0];\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            int count = 0;\n            for (int i = 0; i < nums.length; ++i) {\n                count += prefix[nums[i] + mi] - prefix[nums[i]] + multiplicity[i];\n            }\n            //count = number of pairs with distance <= mi\n            if (count >= k) hi = mi;\n            else lo = mi + 1;\n        }\n        return lo;\n    }\n}",
        "class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n\n        int lo = 0;\n        int hi = nums[nums.length - 1] - nums[0];\n        while (lo < hi) {\n            int mi = (lo + hi) / 2;\n            int count = 0, left = 0;\n            for (int right = 0; right < nums.length; ++right) {\n                while (nums[right] - nums[left] > mi) left++;\n                count += right - left;\n            }\n            //count = number of pairs with distance <= mi\n            if (count >= k) hi = mi;\n            else lo = mi + 1;\n        }\n        return lo;\n    }\n}"
      ]
    },
    {
      "number": 112,
      "question": "Can you solve this real interview question? Accounts Merge - Given a list of accounts where each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.\n\nNow, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some common email to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.\n\nAfter merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any order.\n\n \n\nExample 1:\n\n\nInput: accounts = [[\"John\",\"johnsmith@mail.com\",\"john_newyork@mail.com\"],[\"John\",\"johnsmith@mail.com\",\"john00@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\nOutput: [[\"John\",\"john00@mail.com\",\"john_newyork@mail.com\",\"johnsmith@mail.com\"],[\"Mary\",\"mary@mail.com\"],[\"John\",\"johnnybravo@mail.com\"]]\nExplanation:\nThe first and second John's are the same person as they have the common email \"johnsmith@mail.com\".\nThe third John and Mary are different people as none of their email addresses are used by other accounts.\nWe could return these lists in any order, for example the answer [['Mary', 'mary@mail.com'], ['John', 'johnnybravo@mail.com'], \n['John', 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com']] would still be accepted.\n\n\nExample 2:\n\n\nInput: accounts = [[\"Gabe\",\"Gabe0@m.co\",\"Gabe3@m.co\",\"Gabe1@m.co\"],[\"Kevin\",\"Kevin3@m.co\",\"Kevin5@m.co\",\"Kevin0@m.co\"],[\"Ethan\",\"Ethan5@m.co\",\"Ethan4@m.co\",\"Ethan0@m.co\"],[\"Hanzo\",\"Hanzo3@m.co\",\"Hanzo1@m.co\",\"Hanzo0@m.co\"],[\"Fern\",\"Fern5@m.co\",\"Fern1@m.co\",\"Fern0@m.co\"]]\nOutput: [[\"Ethan\",\"Ethan0@m.co\",\"Ethan4@m.co\",\"Ethan5@m.co\"],[\"Gabe\",\"Gabe0@m.co\",\"Gabe1@m.co\",\"Gabe3@m.co\"],[\"Hanzo\",\"Hanzo0@m.co\",\"Hanzo1@m.co\",\"Hanzo3@m.co\"],[\"Kevin\",\"Kevin0@m.co\",\"Kevin3@m.co\",\"Kevin5@m.co\"],[\"Fern\",\"Fern0@m.co\",\"Fern1@m.co\",\"Fern5@m.co\"]]\n\n\n \n\nConstraints:\n\n * 1 <= accounts.length <= 1000\n * 2 <= accounts[i].length <= 10\n * 1 <= accounts[i][j].length <= 30\n * accounts[i][0] consists of English letters.\n * accounts[i][j] (for j > 0) is a valid email.",
      "code": "class Solution {\npublic:\n    vector<vector<string>> accountsMerge\n(vector<vector<string>>& accounts) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    unordered_set<string> visited;\n    unordered_map<string, vector<string>> adjacent;\n    \n    void DFS(vector<string>& mergedAccount, string& email) {\n        visited.insert(email);\n        // Add the email vector that contains the current component's emails\n        mergedAccount.push_back(email);\n        \n        for (string& neighbor : adjacent[email]) {\n            if (visited.find(neighbor) == visited.end()) {\n                DFS(mergedAccount, neighbor);\n            }\n        }\n    }\n    \n    vector<vector<string>> accountsMerge(vector<vector<string>>& accountList) {\n        int accountListSize = accountList.size();\n        \n         for (vector<string>& account : accountList) {\n            int accountSize = account.size();\n            \n            // Building adjacency list\n            // Adding edge between first email to all other emails in the account\n            string accountFirstEmail = account[1];\n            for (int j = 2; j < accountSize; j++) {\n                string email = account[j];\n                adjacent[accountFirstEmail].push_back(email);\n                adjacent[email].push_back(accountFirstEmail);\n            }\n        }\n        \n        // Traverse over all th accounts to store components\n        vector<vector<string>> mergedAccounts;\n        for (vector<string>& account : accountList) {\n            string accountName = account[0];\n            string accountFirstEmail = account[1];\n            \n            // If email is visited, then it's a part of different component\n            // Hence perform DFS only if email is not visited yet\n            if (visited.find(accountFirstEmail) == visited.end()) {\n                vector<string> mergedAccount;\n                // Adding account name at the 0th index\n                mergedAccount.push_back(accountName);\n                DFS(mergedAccount, accountFirstEmail);\n                // Skip the first element (name)\n                // Name should be the first element, we only need to sort the emails\n                sort(mergedAccount.begin() + 1, mergedAccount.end());\n                mergedAccounts.push_back(mergedAccount);\n            }\n        }\n        \n        return mergedAccounts;\n    }\n};",
        "class DSU {\npublic:\n    vector<int> representative;\n    vector<int> size;\n    \n    DSU(int sz) : representative(sz), size(sz) {\n        for (int i = 0; i < sz; ++i) {\n            // Initially each group is its own representative\n            representative[i] = i;\n            // Intialize the size of all groups to 1\n            size[i] = 1;\n        }\n    }\n    \n    // Finds the representative of group x\n    int findRepresentative(int x) {\n        if (x == representative[x]) {\n            return x;\n        }\n        \n        // This is path compression\n        return representative[x] = findRepresentative(representative[x]);\n    }\n    \n    // Unite the group that contains \"a\" with the group that contains \"b\"\n    void unionBySize(int a, int b) {\n        int representativeA = findRepresentative(a);\n        int representativeB = findRepresentative(b);\n        \n        // If nodes a and b already belong to the same group, do nothing.\n        if (representativeA == representativeB) {\n            return;\n        }\n        \n        // Union by size: point the representative of the smaller\n        // group to the representative of the larger group.\n        if (size[representativeA] >= size[representativeB]) {\n            size[representativeA] += size[representativeB];\n            representative[representativeB] = representativeA;\n        } else {\n            size[representativeB] += size[representativeA];\n            representative[representativeA] = representativeB;\n        }\n    }\n};\n\nclass Solution {\npublic:\n    vector<vector<string>> accountsMerge(vector<vector<string>>& accountList) {\n        int accountListSize = accountList.size();\n        DSU dsu(accountListSize);\n        \n        // Maps email to their component index\n        unordered_map<string, int> emailGroup;\n        \n        for (int i = 0; i < accountListSize; i++) {\n            int accountSize = accountList[i].size();\n\n            for (int j = 1; j < accountSize; j++) {\n                string email = accountList[i][j];\n                string accountName = accountList[i][0];\n                \n                // If this is the first time seeing this email then\n                // assign component group as the account index\n                if (emailGroup.find(email) == emailGroup.end()) {\n                    emailGroup[email] = i;\n                } else {\n                    // If we have seen this email before then union this\n                    // group with the previous group of the email\n                    dsu.unionBySize(i, emailGroup[email]);\n                }\n            }\n        }\n    \n        // Store emails corresponding to the component's representative\n        unordered_map<int, vector<string>> components;\n        for (auto emailIterator : emailGroup) {\n            string email = emailIterator.first;\n            int group = emailIterator.second;\n            components[dsu.findRepresentative(group)].push_back(email);\n        }\n\n        // Sort the components and add the account name\n        vector<vector<string>> mergedAccounts;\n        for (auto componentIterator : components) {\n            int group = componentIterator.first;\n            vector<string> component = {accountList[group][0]};\n            component.insert(component.end(), componentIterator.second.begin(), \n                             componentIterator.second.end());\n            sort(component.begin() + 1, component.end());\n            mergedAccounts.push_back(component);\n        }\n        \n        return mergedAccounts;\n    }\n};"
      ]
    },
    {
      "number": 113,
      "question": "Can you solve this real interview question? Split Linked List in Parts - Given the head of a singly linked list and an integer k, split the linked list into k consecutive linked list parts.\n\nThe length of each part should be as equal as possible: no two parts should have a size differing by more than one. This may lead to some parts being null.\n\nThe parts should be in the order of occurrence in the input list, and parts occurring earlier should always have a size greater than or equal to parts occurring later.\n\nReturn an array of the k parts.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/06/13/split1-lc.jpg]\n\n\nInput: head = [1,2,3], k = 5\nOutput: [[1],[2],[3],[],[]]\nExplanation:\nThe first element output[0] has output[0].val = 1, output[0].next = null.\nThe last element output[4] is null, but its string representation as a ListNode is [].\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/06/13/split2-lc.jpg]\n\n\nInput: head = [1,2,3,4,5,6,7,8,9,10], k = 3\nOutput: [[1,2,3,4],[5,6,7],[8,9,10]]\nExplanation:\nThe input has been split into consecutive parts with size difference at most 1, and earlier parts are a larger size than the later parts.\n\n\n \n\nConstraints:\n\n * The number of nodes in the list is in the range [0, 1000].\n * 0 <= Node.val <= 1000\n * 1 <= k <= 50",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    vector<ListNode*> splitListToParts(ListNode* head, int \nk) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public ListNode[] splitListToParts(ListNode root, int k) {\n        ListNode cur = root;\n        int N = 0;\n        while (cur != null) {\n            cur = cur.next;\n            N++;\n        }\n\n        int width = N / k, rem = N % k;\n\n        ListNode[] ans = new ListNode[k];\n        cur = root;\n        for (int i = 0; i < k; ++i) {\n            ListNode head = new ListNode(0), write = head;\n            for (int j = 0; j < width + (i < rem ? 1 : 0); ++j) {\n                write = write.next = new ListNode(cur.val);\n                if (cur != null) cur = cur.next;\n            }\n            ans[i] = head.next;\n        }\n        return ans;\n    }\n}",
        "class Solution {\n    public ListNode[] splitListToParts(ListNode root, int k) {\n        ListNode cur = root;\n        int N = 0;\n        while (cur != null) {\n            cur = cur.next;\n            N++;\n        }\n\n        int width = N / k, rem = N % k;\n\n        ListNode[] ans = new ListNode[k];\n        cur = root;\n        for (int i = 0; i < k; ++i) {\n            ListNode head = cur;\n            for (int j = 0; j < width + (i < rem ? 1 : 0) - 1; ++j) {\n                if (cur != null) cur = cur.next;\n            }\n            if (cur != null) {\n                ListNode prev = cur;\n                cur = cur.next;\n                prev.next = null;\n            }\n            ans[i] = head;\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 114,
      "question": "Can you solve this real interview question? Number of Atoms - Given a string formula representing a chemical formula, return the count of each atom.\n\nThe atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.\n\nOne or more digits representing that element's count may follow if the count is greater than 1. If the count is 1, no digits will follow.\n\n * For example, \"H2O\" and \"H2O2\" are possible, but \"H1O2\" is impossible.\n\nTwo formulas are concatenated together to produce another formula.\n\n * For example, \"H2O2He3Mg4\" is also a formula.\n\nA formula placed in parentheses, and a count (optionally added) is also a formula.\n\n * For example, \"(H2O2)\" and \"(H2O2)3\" are formulas.\n\nReturn the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.\n\nThe test cases are generated so that all the values in the output fit in a 32-bit integer.\n\n \n\nExample 1:\n\n\nInput: formula = \"H2O\"\nOutput: \"H2O\"\nExplanation: The count of elements are {'H': 2, 'O': 1}.\n\n\nExample 2:\n\n\nInput: formula = \"Mg(OH)2\"\nOutput: \"H2MgO2\"\nExplanation: The count of elements are {'H': 2, 'Mg': 1, 'O': 2}.\n\n\nExample 3:\n\n\nInput: formula = \"K4(ON(SO3)2)2\"\nOutput: \"K4N2O14S4\"\nExplanation: The count of elements are {'K': 4, 'N': 2, 'O': 14, 'S': 4}.\n\n\n \n\nConstraints:\n\n * 1 <= formula.length <= 1000\n * formula consists of English letters, digits, '(', and ')'.\n * formula is always valid.",
      "code": "class Solution {\npublic:\n    string countOfAtoms(string formula) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    int i;\n    public String countOfAtoms(String formula) {\n        StringBuilder ans = new StringBuilder();\n        i = 0;\n        Map<String, Integer> count = parse(formula);\n        for (String name: count.keySet()) {\n            ans.append(name);\n            int multiplicity = count.get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n\n    public Map<String, Integer> parse(String formula) {\n        int N = formula.length();\n        Map<String, Integer> count = new TreeMap();\n        while (i < N && formula.charAt(i) != ')') {\n            if (formula.charAt(i) == '(') {\n                i++;\n                for (Map.Entry<String, Integer> entry: parse(formula).entrySet()) {\n                    count.put(entry.getKey(), count.getOrDefault(entry.getKey(), 0) + entry.getValue());\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = iStart < i ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                count.put(name, count.getOrDefault(name, 0) + multiplicity);\n            }\n        }\n        int iStart = ++i;\n        while (i < N && Character.isDigit(formula.charAt(i))) i++;\n        if (iStart < i) {\n            int multiplicity = Integer.parseInt(formula.substring(iStart, i));\n            for (String key: count.keySet()) {\n                count.put(key, count.get(key) * multiplicity);\n            }\n        }\n        return count;\n    }\n}",
        "class Solution {\n    public String countOfAtoms(String formula) {\n        int N = formula.length();\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n\n        for (int i = 0; i < N;) {\n            if (formula.charAt(i) == '(') {\n                stack.push(new TreeMap());\n                i++;\n            } else if (formula.charAt(i) == ')') {\n                Map<String, Integer> top = stack.pop();\n                int iStart = ++i, multiplicity = 1;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                if (i > iStart) multiplicity = Integer.parseInt(formula.substring(iStart, i));\n                for (String c: top.keySet()) {\n                    int v = top.get(c);\n                    stack.peek().put(c, stack.peek().getOrDefault(c, 0) + v * multiplicity);\n                }\n            } else {\n                int iStart = i++;\n                while (i < N && Character.isLowerCase(formula.charAt(i))) i++;\n                String name = formula.substring(iStart, i);\n                iStart = i;\n                while (i < N && Character.isDigit(formula.charAt(i))) i++;\n                int multiplicity = i > iStart ? Integer.parseInt(formula.substring(iStart, i)) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            int multiplicity = stack.peek().get(name);\n            if (multiplicity > 1) ans.append(\"\" + multiplicity);\n        }\n        return new String(ans);\n    }\n}",
        "import java.util.regex.*;\n\nclass Solution {\n    public String countOfAtoms(String formula) {\n        Matcher matcher = Pattern.compile(\"([A-Z][a-z]*)(\\\\d*)|(\\\\()|(\\\\))(\\\\d*)\").matcher(formula);\n        Stack<Map<String, Integer>> stack = new Stack();\n        stack.push(new TreeMap());\n\n        while (matcher.find()) {\n            String match = matcher.group();\n            if (match.equals(\"(\")) {\n                stack.push(new TreeMap());\n            } else if (match.startsWith(\")\")) {\n                Map<String, Integer> top = stack.pop();\n                int multiplicity = match.length() > 1 ? Integer.parseInt(match.substring(1, match.length())) : 1;\n                for (String name: top.keySet()) {\n                    stack.peek().put(name, stack.peek().getOrDefault(name, 0) + top.get(name) * multiplicity);\n                }\n            } else {\n                int i = 1;\n                while (i < match.length() && Character.isLowerCase(match.charAt(i))) {\n                    i++;\n                }\n                String name = match.substring(0, i);\n                int multiplicity = i < match.length() ? Integer.parseInt(match.substring(i, match.length())) : 1;\n                stack.peek().put(name, stack.peek().getOrDefault(name, 0) + multiplicity);\n            }\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (String name: stack.peek().keySet()) {\n            ans.append(name);\n            final int count = stack.peek().get(name);\n            if (count > 1) ans.append(String.valueOf(count));\n        }\n        return ans.toString();\n    }\n}"
      ]
    },
    {
      "number": 115,
      "question": "Can you solve this real interview question? Self Dividing Numbers - A self-dividing number is a number that is divisible by every digit it contains.\n\n * For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n\nA self-dividing number is not allowed to contain the digit zero.\n\nGiven two integers left and right, return a list of all the self-dividing numbers in the range [left, right].\n\n \n\nExample 1:\n\nInput: left = 1, right = 22\nOutput: [1,2,3,4,5,6,7,8,9,11,12,15,22]\n\n\nExample 2:\n\nInput: left = 47, right = 85\nOutput: [48,55,66,77]\n\n\n \n\nConstraints:\n\n * 1 <= left <= right <= 104",
      "code": "class Solution {\npublic:\n    vector<int> selfDividingNumbers(int left, int right) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> ans = new ArrayList();\n        for (int n = left; n <= right; ++n) {\n            if (selfDividing(n)) ans.add(n);\n        }\n        return ans;\n    }\n    public boolean selfDividing(int n) {\n        for (char c: String.valueOf(n).toCharArray()) {\n            if (c == '0' || (n % (c - '0') > 0))\n                return false;\n        }\n        return true;\n    }\n    /*\n    Alternate implementation of selfDividing:\n    public boolean selfDividing(int n) {\n        int x = n;\n        while (x > 0) {\n            int d = x % 10;\n            x /= 10;\n            if (d == 0 || (n % d) > 0) return false;\n        }\n        return true;\n    */\n}"
      ]
    },
    {
      "number": 116,
      "question": "Can you solve this real interview question? My Calendar I - You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a double booking.\n\nA double booking happens when two events have some non-empty intersection (i.e., some moment is common to both events.).\n\nThe event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.\n\nImplement the MyCalendar class:\n\n * MyCalendar() Initializes the calendar object.\n * boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a double booking. Otherwise, return false and do not add the event to the calendar.\n\n \n\nExample 1:\n\n\nInput\n[\"MyCalendar\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [15, 25], [20, 30]]\nOutput\n[null, true, false, true]\n\nExplanation\nMyCalendar myCalendar = new MyCalendar();\nmyCalendar.book(10, 20); // return True\nmyCalendar.book(15, 25); // return False, It can not be booked because time 15 is already booked by another event.\nmyCalendar.book(20, 30); // return True, The event can be booked, as the first event takes every time less than 20, but not including 20.\n\n \n\nConstraints:\n\n * 0 <= start < end <= 109\n * At most 1000 calls will be made to book.",
      "code": "class MyCalendar {\npublic:\n    MyCalendar() {\n        \n    }\n    \n    bool book(int start, int end) {\n        \n    }\n};\n\n/**\n * Your MyCalendar object will be instantiated and called \nas such:\n * MyCalendar* obj = new MyCalendar();\n * bool param_1 = obj->book(start,end);\n */",
      "solution": [
        "class MyCalendar {\nprivate:\n    vector<pair<int, int>> calendar;\n\npublic:\n    bool book(int start, int end) {\n        for (const auto [s, e] : calendar) {\n            if (start < e && s < end) return false;\n        }\n        calendar.emplace_back(start, end);\n        return true;\n    }\n};",
        "class MyCalendar {\nprivate:\n    set<pair<int, int>> calendar;\n\npublic:\n    bool book(int start, int end) {\n        const pair<int, int> event{start, end};\n        const auto nextEvent = calendar.lower_bound(event);\n        if (nextEvent != calendar.end() && nextEvent->first < end) {\n            return false;\n        }\n\n        if (nextEvent != calendar.begin()) {\n            const auto prevEvent = prev(nextEvent);\n            if (prevEvent->second > start) {\n                return false;\n            }\n        }\n\n        calendar.insert(event);\n        return true;\n    }\n};"
      ]
    },
    {
      "number": 117,
      "question": "Can you solve this real interview question? My Calendar II - You are implementing a program to use as your calendar. We can add a new event if adding the event will not cause a triple booking.\n\nA triple booking happens when three events have some non-empty intersection (i.e., some moment is common to all the three events.).\n\nThe event can be represented as a pair of integers start and end that represents a booking on the half-open interval [start, end), the range of real numbers x such that start <= x < end.\n\nImplement the MyCalendarTwo class:\n\n * MyCalendarTwo() Initializes the calendar object.\n * boolean book(int start, int end) Returns true if the event can be added to the calendar successfully without causing a triple booking. Otherwise, return false and do not add the event to the calendar.\n\n \n\nExample 1:\n\n\nInput\n[\"MyCalendarTwo\", \"book\", \"book\", \"book\", \"book\", \"book\", \"book\"]\n[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]\nOutput\n[null, true, true, true, false, true, true]\n\nExplanation\nMyCalendarTwo myCalendarTwo = new MyCalendarTwo();\nmyCalendarTwo.book(10, 20); // return True, The event can be booked. \nmyCalendarTwo.book(50, 60); // return True, The event can be booked. \nmyCalendarTwo.book(10, 40); // return True, The event can be double booked. \nmyCalendarTwo.book(5, 15);  // return False, The event cannot be booked, because it would result in a triple booking.\nmyCalendarTwo.book(5, 10); // return True, The event can be booked, as it does not use time 10 which is already double booked.\nmyCalendarTwo.book(25, 55); // return True, The event can be booked, as the time in [25, 40) will be double booked with the third event, the time [40, 50) will be single booked, and the time [50, 55) will be double booked with the second event.\n\n\n \n\nConstraints:\n\n * 0 <= start < end <= 109\n * At most 1000 calls will be made to book.",
      "code": "class MyCalendarTwo {\npublic:\n    MyCalendarTwo() {\n        \n    }\n    \n    bool book(int start, int end) {\n        \n    }\n};\n\n/**\n * Your MyCalendarTwo object will be instantiated and \ncalled as such:\n * MyCalendarTwo* obj = new MyCalendarTwo();\n * bool param_1 = obj->book(start,end);\n */",
      "solution": [
        "public class MyCalendarTwo {\n    List<int[]> calendar;\n    List<int[]> overlaps;\n\n    MyCalendarTwo() {\n        overlaps = new ArrayList();\n        calendar = new ArrayList();\n    }\n\n    public boolean book(int start, int end) {\n        for (int[] iv: overlaps) {\n            if (iv[0] < end && start < iv[1]) return false;\n        }\n        for (int[] iv: calendar) {\n            if (iv[0] < end && start < iv[1])\n                overlaps.add(new int[]{Math.max(start, iv[0]), Math.min(end, iv[1])});\n        }\n        calendar.add(new int[]{start, end});\n        return true;\n    }\n}",
        "class MyCalendarTwo {\n    TreeMap<Integer, Integer> delta;\n\n    public MyCalendarTwo() {\n        delta = new TreeMap();\n    }\n\n    public boolean book(int start, int end) {\n        delta.put(start, delta.getOrDefault(start, 0) + 1);\n        delta.put(end, delta.getOrDefault(end, 0) - 1);\n\n        int active = 0;\n        for (int d: delta.values()) {\n            active += d;\n            if (active >= 3) {\n                delta.put(start, delta.get(start) - 1);\n                delta.put(end, delta.get(end) + 1);\n                if (delta.get(start) == 0)\n                    delta.remove(start);\n                return false;\n            }\n        }\n        return true;\n    }\n}"
      ]
    },
    {
      "number": 118,
      "question": "Can you solve this real interview question? Flood Fill - An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\n\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\n\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\n\nReturn the modified image after performing the flood fill.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/06/01/flood1-grid.jpg]\n\n\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2\nOutput: [[2,2,2],[2,2,0],[2,0,1]]\nExplanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color.\nNote the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel.\n\n\nExample 2:\n\n\nInput: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0\nOutput: [[0,0,0],[0,0,0]]\nExplanation: The starting pixel is already colored 0, so no changes are made to the image.\n\n\n \n\nConstraints:\n\n * m == image.length\n * n == image[i].length\n * 1 <= m, n <= 50\n * 0 <= image[i][j], color < 216\n * 0 <= sr < m\n * 0 <= sc < n",
      "code": "class Solution {\npublic:\n    vector<vector<int>> floodFill(vector<vector<int>>& \nimage, int sr, int sc, int color) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int color = image[sr][sc];\n        if (color != newColor) dfs(image, sr, sc, color, newColor);\n        return image;\n    }\n    public void dfs(int[][] image, int r, int c, int color, int newColor) {\n        if (image[r][c] == color) {\n            image[r][c] = newColor;\n            if (r >= 1) dfs(image, r-1, c, color, newColor);\n            if (c >= 1) dfs(image, r, c-1, color, newColor);\n            if (r+1 < image.length) dfs(image, r+1, c, color, newColor);\n            if (c+1 < image[0].length) dfs(image, r, c+1, color, newColor);\n        }\n    }\n}"
      ]
    },
    {
      "number": 119,
      "question": "Can you solve this real interview question? Cherry Pickup - You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.\n\n * 0 means the cell is empty, so you can pass through,\n * 1 means the cell contains a cherry that you can pick up and pass through, or\n * -1 means the cell contains a thorn that blocks your way.\n\nReturn the maximum number of cherries you can collect by following the rules below:\n\n * Starting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1).\n * After reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells.\n * When passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\n * If there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/12/14/grid.jpg]\n\n\nInput: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\nOutput: 5\nExplanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n\nExample 2:\n\n\nInput: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\nOutput: 0\n\n\n \n\nConstraints:\n\n * n == grid.length\n * n == grid[i].length\n * 1 <= n <= 50\n * grid[i][j] is -1, 0, or 1.\n * grid[0][0] != -1\n * grid[n - 1][n - 1] != -1",
      "code": "class Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int ans = 0;\n        int[][] path = bestPath(grid);\n        if (path == null) return 0;\n        for (int[] step: path) {\n            ans += grid[step[0]][step[1]];\n            grid[step[0]][step[1]] = 0;\n        }\n\n        for (int[] step: bestPath(grid))\n            ans += grid[step[0]][step[1]];\n\n        return ans;\n    }\n\n    public int[][] bestPath(int[][] grid) {\n        int N = grid.length;\n        int[][] dp = new int[N][N];\n        for (int[] row: dp) Arrays.fill(row, Integer.MIN_VALUE);\n        dp[N-1][N-1] = grid[N-1][N-1];\n        for (int i = N-1; i >= 0; --i) {\n            for (int j = N-1; j >= 0; --j) {\n                if (grid[i][j] >= 0 && (i != N-1 || j != N-1)) {\n                    dp[i][j] = Math.max(i+1 < N ? dp[i+1][j] : Integer.MIN_VALUE,\n                                        j+1 < N ? dp[i][j+1] : Integer.MIN_VALUE);\n                    dp[i][j] += grid[i][j];\n                }\n            }\n        }\n        if (dp[0][0] < 0) return null;\n        int[][] ans = new int[2*N - 1][2];\n        int i = 0, j = 0, t = 0;\n        while (i != N-1 || j != N-1) {\n            if (j+1 == N || i+1 < N && dp[i+1][j] >= dp[i][j+1]) i++;\n            else j++;\n\n            ans[t][0] = i;\n            ans[t][1] = j;\n            t++;\n        }\n        return ans;\n    }\n}",
        "class Solution {\n    int[][][] memo;\n    int[][] grid;\n    int N;\n    public int cherryPickup(int[][] grid) {\n        this.grid = grid;\n        N = grid.length;\n        memo = new int[N][N][N];\n        for (int[][] layer: memo)\n            for (int[] row: layer)\n                Arrays.fill(row, Integer.MIN_VALUE);\n        return Math.max(0, dp(0, 0, 0));\n    }\n    public int dp(int r1, int c1, int c2) {\n        int r2 = r1 + c1 - c2;\n        if (N == r1 || N == r2 || N == c1 || N == c2 ||\n                grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n            return -999999;        \n        } else if (r1 == N-1 && c1 == N-1) {\n            return grid[r1][c1];\n        } else if (memo[r1][c1][c2] != Integer.MIN_VALUE) {\n            return memo[r1][c1][c2];\n        } else {\n            int ans = grid[r1][c1];\n            if (c1 != c2) ans += grid[r2][c2];\n            ans += Math.max(Math.max(dp(r1, c1+1, c2+1), dp(r1+1, c1, c2+1)),\n                            Math.max(dp(r1, c1+1, c2), dp(r1+1, c1, c2)));\n            memo[r1][c1][c2] = ans;\n            return ans;\n        }\n    }\n}",
        "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int N = grid.length;\n        int[][] dp = new int[N][N];\n        for (int[] row: dp) Arrays.fill(row, Integer.MIN_VALUE);\n        dp[0][0] = grid[0][0];\n\n        for (int t = 1; t <= 2*N - 2; ++t) {\n            int[][] dp2 = new int[N][N];\n            for (int[] row: dp2) Arrays.fill(row, Integer.MIN_VALUE);\n\n            for (int i = Math.max(0, t-(N-1)); i <= Math.min(N-1, t); ++i) {\n                for (int j = Math.max(0, t-(N-1)); j <= Math.min(N-1, t); ++j) {\n                    if (grid[i][t-i] == -1 || grid[j][t-j] == -1) continue;\n                    int val = grid[i][t-i];\n                    if (i != j) val += grid[j][t-j];\n                    for (int pi = i-1; pi <= i; ++pi)\n                        for (int pj = j-1; pj <= j; ++pj)\n                            if (pi >= 0 && pj >= 0)\n                                dp2[i][j] = Math.max(dp2[i][j], dp[pi][pj] + val);\n                }\n            }\n            dp = dp2;\n        }\n        return Math.max(0, dp[N-1][N-1]);\n    }\n}"
      ]
    },
    {
      "number": 120,
      "question": "Can you solve this real interview question? Prefix and Suffix Search - Design a special dictionary that searches the words in it by a prefix and a suffix.\n\nImplement the WordFilter class:\n\n * WordFilter(string[] words) Initializes the object with the words in the dictionary.\n * f(string pref, string suff) Returns the index of the word in the dictionary, which has the prefix pref and the suffix suff. If there is more than one valid index, return the largest of them. If there is no such word in the dictionary, return -1.\n\n \n\nExample 1:\n\n\nInput\n[\"WordFilter\", \"f\"]\n[[[\"apple\"]], [\"a\", \"e\"]]\nOutput\n[null, 0]\nExplanation\nWordFilter wordFilter = new WordFilter([\"apple\"]);\nwordFilter.f(\"a\", \"e\"); // return 0, because the word at index 0 has prefix = \"a\" and suffix = \"e\".\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 104\n * 1 <= words[i].length <= 7\n * 1 <= pref.length, suff.length <= 7\n * words[i], pref and suff consist of lowercase English letters only.\n * At most 104 calls will be made to the function f.",
      "code": "class WordFilter {\npublic:\n    WordFilter(vector<string>& words) {\n        \n    }\n    \n    int f(string pref, string suff) {\n        \n    }\n};\n\n/**\n * Your WordFilter object will be instantiated and called \nas such:\n * WordFilter* obj = new WordFilter(words);\n * int param_1 = obj->f(pref,suff);\n */",
      "solution": [
        "class WordFilter {\n    TrieNode trie1, trie2;\n    public WordFilter(String[] words) {\n        trie1 = new TrieNode();\n        trie2 = new TrieNode();\n        int wt = 0;\n        for (String word: words) {\n            char[] ca = word.toCharArray();\n\n            TrieNode cur = trie1;\n            cur.weight.add(wt);\n            for (char letter: ca) {\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n                cur.weight.add(wt);\n            }\n\n            cur = trie2;\n            cur.weight.add(wt);\n            for (int j = ca.length - 1; j >= 0; --j) {\n                char letter = ca[j];\n                if (cur.children[letter - 'a'] == null)\n                    cur.children[letter - 'a'] = new TrieNode();\n                cur = cur.children[letter - 'a'];\n                cur.weight.add(wt);\n            }\n            wt++;\n        }\n    }\n\n    public int f(String prefix, String suffix) {\n        TrieNode cur1 = trie1, cur2 = trie2;\n        for (char letter: prefix.toCharArray()) {\n            if (cur1.children[letter - 'a'] == null) return -1;\n            cur1 = cur1.children[letter - 'a'];\n        }\n        char[] ca = suffix.toCharArray();\n        for (int j = ca.length - 1; j >= 0; --j) {\n            char letter = ca[j];\n            if (cur2.children[letter - 'a'] == null) return -1;\n            cur2 = cur2.children[letter - 'a'];\n        }\n\n        int ans = -1;\n        for (int w1: cur1.weight)\n            if (w1 > ans && cur2.weight.contains(w1))\n                ans = w1;\n\n        return ans;\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    Set<Integer> weight;\n    public TrieNode() {\n        children = new TrieNode[26];\n        weight = new HashSet();\n    }\n}",
        "class WordFilter {\n    TrieNode trie;\n    public WordFilter(String[] words) {\n        trie = new TrieNode();\n        int wt = 0;\n        for (String word: words) {\n            TrieNode cur = trie;\n            cur.weight = wt;\n            int L = word.length();\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < L; ++i) {\n\n                TrieNode tmp = cur;\n                for (int j = i; j < L; ++j) {\n                    int code = (chars[j] - '`') * 27;\n                    if (tmp.children.get(code) == null)\n                        tmp.children.put(code, new TrieNode());\n                    tmp = tmp.children.get(code);\n                    tmp.weight = wt;\n                }\n\n                tmp = cur;\n                for (int k = L - 1 - i; k >= 0; --k) {\n                    int code = (chars[k] - '`');\n                    if (tmp.children.get(code) == null)\n                        tmp.children.put(code, new TrieNode());\n                    tmp = tmp.children.get(code);\n                    tmp.weight = wt;\n                }\n\n                int code = (chars[i] - '`') * 27 + (chars[L - 1 - i] - '`');\n                if (cur.children.get(code) == null)\n                    cur.children.put(code, new TrieNode());\n                cur = cur.children.get(code);\n                cur.weight = wt;\n\n            }\n            wt++;\n        }\n    }\n\n    public int f(String prefix, String suffix) {\n        TrieNode cur = trie;\n        int i = 0, j = suffix.length() - 1;\n        while (i < prefix.length() || j >= 0) {\n            char c1 = i < prefix.length() ? prefix.charAt(i) : '`';\n            char c2 = j >= 0 ? suffix.charAt(j) : '`';\n            int code = (c1 - '`') * 27 + (c2 - '`');\n            cur = cur.children.get(code);\n            if (cur == null) return -1;\n            i++; j--;\n        }\n        return cur.weight;\n    }\n}\n\nclass TrieNode {\n    Map<Integer, TrieNode> children;\n    int weight;\n    public TrieNode() {\n        children = new HashMap();\n        weight = 0;\n    }\n}",
        "class WordFilter {\n    TrieNode trie;\n    public WordFilter(String[] words) {\n        trie = new TrieNode();\n        for (int weight = 0; weight < words.length; ++weight) {\n            String word = words[weight] + \"{\";\n            for (int i = 0; i < word.length(); ++i) {\n                TrieNode cur = trie;\n                cur.weight = weight;\n                for (int j = i; j < 2 * word.length() - 1; ++j) {\n                    int k = word.charAt(j % word.length()) - 'a';\n                    if (cur.children[k] == null)\n                        cur.children[k] = new TrieNode();\n                    cur = cur.children[k];\n                    cur.weight = weight;\n                }\n            }\n        }\n    }\n    public int f(String prefix, String suffix) {\n        TrieNode cur = trie;\n        for (char letter: (suffix + '{' + prefix).toCharArray()) {\n            if (cur.children[letter - 'a'] == null) return -1;\n            cur = cur.children[letter - 'a'];\n        }\n        return cur.weight;\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    int weight;\n    public TrieNode() {\n        children = new TrieNode[27];\n        weight = 0;\n    }\n}"
      ]
    },
    {
      "number": 121,
      "question": "Can you solve this real interview question? Contain Virus - A virus is spreading rapidly, and your task is to quarantine the infected area by installing walls.\n\nThe world is modeled as an m x n binary grid isInfected, where isInfected[i][j] == 0 represents uninfected cells, and isInfected[i][j] == 1 represents cells contaminated with the virus. A wall (and only one wall) can be installed between any two 4-directionally adjacent cells, on the shared boundary.\n\nEvery night, the virus spreads to all neighboring cells in all four directions unless blocked by a wall. Resources are limited. Each day, you can install walls around only one region (i.e., the affected area (continuous block of infected cells) that threatens the most uninfected cells the following night). There will never be a tie.\n\nReturn the number of walls used to quarantine all the infected regions. If the world will become fully infected, return the number of walls used.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/06/01/virus11-grid.jpg]\n\n\nInput: isInfected = [[0,1,0,0,0,0,0,1],[0,1,0,0,0,0,0,1],[0,0,0,0,0,0,0,1],[0,0,0,0,0,0,0,0]]\nOutput: 10\nExplanation: There are 2 contaminated regions.\nOn the first day, add 5 walls to quarantine the viral region on the left. The board after the virus spreads is:\n[https://assets.leetcode.com/uploads/2021/06/01/virus12edited-grid.jpg]\nOn the second day, add 5 walls to quarantine the viral region on the right. The virus is fully contained.\n[https://assets.leetcode.com/uploads/2021/06/01/virus13edited-grid.jpg]\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/06/01/virus2-grid.jpg]\n\n\nInput: isInfected = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: 4\nExplanation: Even though there is only one cell saved, there are 4 walls built.\nNotice that walls are only built on the shared boundary of two different cells.\n\n\nExample 3:\n\n\nInput: isInfected = [[1,1,1,0,0,0,0,0,0],[1,0,1,0,1,1,1,1,1],[1,1,1,0,0,0,0,0,0]]\nOutput: 13\nExplanation: The region on the left only builds two new walls.\n\n\n \n\nConstraints:\n\n * m == isInfected.length\n * n == isInfected[i].length\n * 1 <= m, n <= 50\n * isInfected[i][j] is either 0 or 1.\n * There is always a contiguous viral region throughout the described process that will infect strictly more uncontaminated squares in the next round.",
      "code": "class Solution {\npublic:\n    int containVirus(vector<vector<int>>& isInfected) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    Set<Integer> seen;\n    List<Set<Integer>> regions;\n    List<Set<Integer>> frontiers;\n    List<Integer> perimeters;\n    int[][] grid;\n    int R, C;\n    int[] dr = new int[]{-1, 1, 0, 0};\n    int[] dc = new int[]{0, 0, -1, 1};\n\n    public int containVirus(int[][] grid) {\n        this.grid = grid;\n        R = grid.length;\n        C = grid[0].length;\n\n        int ans = 0;\n        while (true) {\n            seen = new HashSet();\n            regions = new ArrayList();\n            frontiers = new ArrayList();\n            perimeters = new ArrayList();\n\n            for (int r = 0; r < R; ++r) {\n                for (int c = 0; c < C; ++c) {\n                    if (grid[r][c] == 1 && !seen.contains(r*C + c)) {\n                        regions.add(new HashSet());\n                        frontiers.add(new HashSet());\n                        perimeters.add(0);\n                        dfs(r, c);\n                    }\n                }\n            }\n\n            if (regions.isEmpty()) break;\n            int triageIndex = 0;\n            for (int i = 0; i < frontiers.size(); ++i) {\n                if (frontiers.get(triageIndex).size() < frontiers.get(i).size())\n                    triageIndex = i;\n            }\n            ans += perimeters.get(triageIndex);\n\n            for (int i = 0; i < regions.size(); ++i) {\n                if (i == triageIndex) {\n                    for (int code: regions.get(i))\n                        grid[code / C][code % C] = -1;\n                } else {\n                    for (int code: regions.get(i)) {\n                        int r = code / C, c = code % C;\n                        for (int k = 0; k < 4; ++k) {\n                            int nr = r + dr[k], nc = c + dc[k];\n                            if (nr >= 0 && nr < R && nc >= 0 && nc < C && grid[nr][nc] == 0)\n                                grid[nr][nc] = 1;\n                        }\n                    }\n                }\n            }\n        }\n        return ans;\n    }\n\n    public void dfs(int r, int c) {\n        if (!seen.contains(r*C + c)) {\n            seen.add(r*C + c);\n            int N = regions.size()\n            regions.get(N - 1).add(r*C + c);\n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dr[k], nc = c + dc[k];\n                if (nr >= 0 && nr < R && nc >= 0 && nc < C) {\n                    if (grid[nr][nc] == 1) {\n                        dfs(nr, nc);\n                    } else if (grid[nr][nc] == 0){\n                        frontiers.get(N - 1).add(nr*C + nc);\n                        perimeters.set(N - 1, perimeters.get(N - 1) + 1);\n                    }\n                }\n            }\n        }\n    }\n}"
      ]
    },
    {
      "number": 122,
      "question": "Can you solve this real interview question? Reach a Number - You are standing at position 0 on an infinite number line. There is a destination at position target.\n\nYou can make some number of moves numMoves so that:\n\n * On each move, you can either go left or right.\n * During the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\n\nGiven the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.\n\n \n\nExample 1:\n\n\nInput: target = 2\nOutput: 3\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\n\n\nExample 2:\n\n\nInput: target = 3\nOutput: 2\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n\n\n \n\nConstraints:\n\n * -109 <= target <= 109\n * target != 0",
      "code": "class Solution {\npublic:\n    int reachNumber(int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int reachNumber(int target) {\n        target = Math.abs(target);\n        int k = 0;\n        while (target > 0)\n            target -= ++k;\n        return target % 2 == 0 ? k : k + 1 + k%2;\n    }\n}"
      ]
    },
    {
      "number": 123,
      "question": "Can you solve this real interview question? Prime Number of Set Bits in Binary Representation - Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation.\n\nRecall that the number of set bits an integer has is the number of 1's present when written in binary.\n\n * For example, 21 written in binary is 10101, which has 3 set bits.\n\n \n\nExample 1:\n\n\nInput: left = 6, right = 10\nOutput: 4\nExplanation:\n6  -> 110 (2 set bits, 2 is prime)\n7  -> 111 (3 set bits, 3 is prime)\n8  -> 1000 (1 set bit, 1 is not prime)\n9  -> 1001 (2 set bits, 2 is prime)\n10 -> 1010 (2 set bits, 2 is prime)\n4 numbers have a prime number of set bits.\n\n\nExample 2:\n\n\nInput: left = 10, right = 15\nOutput: 5\nExplanation:\n10 -> 1010 (2 set bits, 2 is prime)\n11 -> 1011 (3 set bits, 3 is prime)\n12 -> 1100 (2 set bits, 2 is prime)\n13 -> 1101 (3 set bits, 3 is prime)\n14 -> 1110 (3 set bits, 3 is prime)\n15 -> 1111 (4 set bits, 4 is not prime)\n5 numbers have a prime number of set bits.\n\n\n \n\nConstraints:\n\n * 1 <= left <= right <= 106\n * 0 <= right - left <= 104",
      "code": "class Solution {\npublic:\n    int countPrimeSetBits(int left, int right) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int countPrimeSetBits(int L, int R) {\n        int ans = 0;\n        for (int x = L; x <= R; ++x)\n            if (isSmallPrime(Integer.bitCount(x)))\n                ans++;\n        return ans;\n    }\n    public boolean isSmallPrime(int x) {\n        return (x == 2 || x == 3 || x == 5 || x == 7 ||\n                x == 11 || x == 13 || x == 17 || x == 19);\n    }\n}"
      ]
    },
    {
      "number": 124,
      "question": "Can you solve this real interview question? Partition Labels - You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\n\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\n\nReturn a list of integers representing the size of these parts.\n\n \n\nExample 1:\n\n\nInput: s = \"ababcbacadefegdehijhklij\"\nOutput: [9,7,8]\nExplanation:\nThe partition is \"ababcbaca\", \"defegde\", \"hijhklij\".\nThis is a partition so that each letter appears in at most one part.\nA partition like \"ababcbacadefegde\", \"hijhklij\" is incorrect, because it splits s into less parts.\n\n\nExample 2:\n\n\nInput: s = \"eccbbbbdec\"\nOutput: [10]\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 500\n * s consists of lowercase English letters.",
      "code": "class Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<Integer> partitionLabels(String S) {\n        int[] last = new int[26];\n        for (int i = 0; i < S.length(); ++i)\n            last[S.charAt(i) - 'a'] = i;\n        \n        int j = 0, anchor = 0;\n        List<Integer> ans = new ArrayList();\n        for (int i = 0; i < S.length(); ++i) {\n            j = Math.max(j, last[S.charAt(i) - 'a']);\n            if (i == j) {\n                ans.add(i - anchor + 1);\n                anchor = i + 1;\n            }\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 125,
      "question": "Can you solve this real interview question? Largest Plus Sign - You are given an integer n. You have an n x n binary grid grid with all values initially 1's except for some indices given in the array mines. The ith element of the array mines is defined as mines[i] = [xi, yi] where grid[xi][yi] == 0.\n\nReturn the order of the largest axis-aligned plus sign of 1's contained in grid. If there is none, return 0.\n\nAn axis-aligned plus sign of 1's of order k has some center grid[r][c] == 1 along with four arms of length k - 1 going up, down, left, and right, and made of 1's. Note that there could be 0's or 1's beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1's.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/06/13/plus1-grid.jpg]\n\n\nInput: n = 5, mines = [[4,2]]\nOutput: 2\nExplanation: In the above grid, the largest plus sign can only be of order 2. One of them is shown.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/06/13/plus2-grid.jpg]\n\n\nInput: n = 1, mines = [[0,0]]\nOutput: 0\nExplanation: There is no plus sign, so return 0.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 500\n * 1 <= mines.length <= 5000\n * 0 <= xi, yi < n\n * All the pairs (xi, yi) are unique.",
      "code": "class Solution {\npublic:\n    int orderOfLargestPlusSign(int n, vector<vector<int>>& \nmines) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        Set<Integer> banned = new HashSet();\n        for (int[] mine: mines)\n            banned.add(mine[0] * N + mine[1]);\n            \n        int ans = 0;\n        for (int r = 0; r < N; ++r) for (int c = 0; c < N; ++c) {\n            int k = 0;\n            while (k <= r && r < N-k && k <= c && c < N-k &&\n                    !banned.contains((r-k)*N + c) &&\n                    !banned.contains((r+k)*N + c) &&\n                    !banned.contains(r*N + c-k) &&\n                    !banned.contains(r*N + c+k))\n                k++;\n            \n            ans = Math.max(ans, k);\n        }\n        return ans;\n    }\n}",
        "class Solution {\n    public int orderOfLargestPlusSign(int N, int[][] mines) {\n        Set<Integer> banned = new HashSet();\n        int[][] dp = new int[N][N];\n        \n        for (int[] mine: mines)\n            banned.add(mine[0] * N + mine[1]);\n        int ans = 0, count;\n        \n        for (int r = 0; r < N; ++r) {\n            count = 0;\n            for (int c = 0; c < N; ++c) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = count;\n            }\n            \n            count = 0;\n            for (int c = N-1; c >= 0; --c) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n            }\n        }\n        \n        for (int c = 0; c < N; ++c) {\n            count = 0;\n            for (int r = 0; r < N; ++r) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n            }\n            \n            count = 0;\n            for (int r = N-1; r >= 0; --r) {\n                count = banned.contains(r*N + c) ? 0 : count + 1;\n                dp[r][c] = Math.min(dp[r][c], count);\n                ans = Math.max(ans, dp[r][c]);\n            }\n        }\n        \n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 126,
      "question": "Can you solve this real interview question? K-th Symbol in Grammar - We build a table of n rows (1-indexed). We start by writing 0 in the 1st row. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.\n\n * For example, for n = 3, the 1st row is 0, the 2nd row is 01, and the 3rd row is 0110.\n\nGiven two integer n and k, return the kth (1-indexed) symbol in the nth row of a table of n rows.\n\n \n\nExample 1:\n\n\nInput: n = 1, k = 1\nOutput: 0\nExplanation: row 1: 0\n\n\nExample 2:\n\n\nInput: n = 2, k = 1\nOutput: 0\nExplanation: \nrow 1: 0\nrow 2: 01\n\n\nExample 3:\n\n\nInput: n = 2, k = 2\nOutput: 1\nExplanation: \nrow 1: 0\nrow 2: 01\n\n\n \n\nConstraints:\n\n * 1 <= n <= 30\n * 1 <= k <= 2n - 1",
      "code": "class Solution {\npublic:\n    int kthGrammar(int n, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int depthFirstSearch(int n, int k, int rootVal) {\n        if (n == 1) {\n            return rootVal;\n        }\n\n        int totalNodes = pow(2, n - 1);\n\n        // Target node will be present in the right half sub-tree of the current root node.\n        if (k > (totalNodes / 2)) {\n            int nextRootVal = (rootVal == 0) ? 1 : 0;\n            return depthFirstSearch(n - 1, k - (totalNodes / 2), nextRootVal);\n        }\n        // Otherwise, the target node is in the left sub-tree of the current root node.\n        else {\n            int nextRootVal = (rootVal == 0) ? 0 : 1;\n            return depthFirstSearch(n - 1, k, nextRootVal);\n        }\n    }\n\n    int kthGrammar(int n, int k) {\n        return depthFirstSearch(n, k, 0);\n    }\n};",
        "class Solution {\npublic:\n    int recursion(int n, int k) {\n        // First row will only have one symbol '0'.\n        if (n == 1) {\n            return 0;\n        }\n\n        int totalElements = pow(2, (n - 1));\n        int halfElements = totalElements / 2;\n\n        // If the target is present in the right half, we switch to the respective left half symbol.\n        if (k > halfElements) {\n            return 1 - kthGrammar(n, k - halfElements);\n        }\n\n        // Otherwise, we switch to the previous row.\n        return recursion(n - 1, k);\n    }\n\n    int kthGrammar(int n, int k) {\n        return recursion(n, k);\n    }\n};",
        "class Solution {\npublic:\n    int kthGrammar(int n, int k) {\n        if (n == 1) {\n            return 0;\n        }\n\n        // We assume the symbol at the target position is '1'.\n        int symbol = 1;\n\n        for (int currRow = n; currRow > 1; --currRow) {\n            int totalElements = pow(2, (currRow - 1));\n            int halfElements = totalElements / 2;\n\n            // If 'k' lies in the right half symbol, then we flip over to the respective left half symbol.\n            if (k > halfElements) {\n                // Flip the symbol.\n                symbol = 1 - symbol;\n                // Change the position after flipping.\n                k -= halfElements;\n            }\n        }\n\n        // We reached the 1st row; if the symbol is not '0', we started with the wrong symbol.\n        if (symbol != 0) {\n            // Thus, the start symbol was '0' not '1'.\n            return 0;\n        } \n\n        // Start symbol was indeed what we started with, a '1'.\n        return 1;\n    }\n};",
        "class Solution {\npublic:\n    int kthGrammar(int n, int k) {\n        int count = __builtin_popcount(k - 1);\n        return count % 2 == 0 ? 0 : 1;\n    }\n};"
      ]
    },
    {
      "number": 127,
      "question": "Can you solve this real interview question? Rotate String - Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\nA shift on s consists of moving the leftmost character of s to the rightmost position.\n\n * For example, if s = \"abcde\", then it will be \"bcdea\" after one shift.\n\n \n\nExample 1:\n\nInput: s = \"abcde\", goal = \"cdeab\"\nOutput: true\n\n\nExample 2:\n\nInput: s = \"abcde\", goal = \"abced\"\nOutput: false\n\n\n \n\nConstraints:\n\n * 1 <= s.length, goal.length <= 100\n * s and goal consist of lowercase English letters.",
      "code": "class Solution {\npublic:\n    bool rotateString(string s, string goal) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean rotateString(String A, String B) {\n        if (A.length() != B.length())\n            return false;\n        if (A.length() == 0)\n            return true;\n\n        search:\n            for (int s = 0; s < A.length(); ++s) {\n                for (int i = 0; i < A.length(); ++i) {\n                    if (A.charAt((s+i) % A.length()) != B.charAt(i))\n                        continue search;\n                }\n                return true;\n            }\n        return false;\n    }\n}",
        "class Solution {\n    public boolean rotateString(String A, String B) {\n        return A.length() == B.length() && (A + A).contains(B);\n    }\n}",
        "import java.math.BigInteger;\nclass Solution {\n    public boolean rotateString(String A, String B) {\n        if (A.equals(B)) return true;\n\n        int MOD = 1_000_000_007;\n        int P = 113;\n        int Pinv = BigInteger.valueOf(P).modInverse(BigInteger.valueOf(MOD)).intValue();\n\n        long hb = 0, power = 1;\n        for (char x: B.toCharArray()) {\n            hb = (hb + power * x) % MOD;\n            power = power * P % MOD;\n        }\n\n        long ha = 0; power = 1;\n        char[] ca = A.toCharArray();\n        for (char x: ca) {\n            ha = (ha + power * x) % MOD;\n            power = power * P % MOD;\n        }\n\n        for (int i = 0; i < ca.length; ++i) {\n            char x = ca[i];\n            ha += power * x - x;\n            ha %= MOD;\n            ha *= Pinv;\n            ha %= MOD;\n            if (ha == hb && (A.substring(i+1) + A.substring(0, i+1)).equals(B))\n                return true;\n\n        }\n        return false;\n    }\n}",
        "class Solution {\n    public boolean rotateString(String A, String B) {\n        int N = A.length();\n        if (N != B.length()) return false;\n        if (N == 0) return true;\n\n        //Compute shift table\n        int[] shifts = new int[N+1];\n        Arrays.fill(shifts, 1);\n        int left = -1;\n        for (int right = 0; right < N; ++right) {\n            while (left >= 0 && (B.charAt(left) != B.charAt(right)))\n                left -= shifts[left];\n            shifts[right + 1] = right - left++;\n        }\n\n        //Find match of B in A+A\n        int matchLen = 0;\n        for (char c: (A+A).toCharArray()) {\n            while (matchLen >= 0 && B.charAt(matchLen) != c)\n                matchLen -= shifts[matchLen];\n            if (++matchLen == N) return true;\n        }\n\n        return false;\n    }\n}"
      ]
    },
    {
      "number": 128,
      "question": "Can you solve this real interview question? Smallest Rotation with Highest Score - You are given an array nums. You can rotate it by a non-negative integer k so that the array becomes [nums[k], nums[k + 1], ... nums[nums.length - 1], nums[0], nums[1], ..., nums[k-1]]. Afterward, any entries that are less than or equal to their index are worth one point.\n\n * For example, if we have nums = [2,4,1,3,0], and we rotate by k = 2, it becomes [1,3,0,2,4]. This is worth 3 points because 1 > 0 [no points], 3 > 1 [no points], 0 <= 2 [one point], 2 <= 3 [one point], 4 <= 4 [one point].\n\nReturn the rotation index k that corresponds to the highest score we can achieve if we rotated nums by it. If there are multiple answers, return the smallest such index k.\n\n \n\nExample 1:\n\n\nInput: nums = [2,3,1,4,0]\nOutput: 3\nExplanation: Scores for each k are listed below: \nk = 0,  nums = [2,3,1,4,0],    score 2\nk = 1,  nums = [3,1,4,0,2],    score 3\nk = 2,  nums = [1,4,0,2,3],    score 3\nk = 3,  nums = [4,0,2,3,1],    score 4\nk = 4,  nums = [0,2,3,1,4],    score 3\nSo we should choose k = 3, which has the highest score.\n\n\nExample 2:\n\n\nInput: nums = [1,3,0,2,4]\nOutput: 0\nExplanation: nums will always have 3 points no matter how it shifts.\nSo we will choose the smallest k, which is 0.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 0 <= nums[i] < nums.length",
      "code": "class Solution {\npublic:\n    int bestRotation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int bestRotation(int[] A) {\n        int N = A.length;\n        int[] bad = new int[N];\n        for (int i = 0; i < N; ++i) {\n            int left = (i - A[i] + 1 + N) % N;\n            int right = (i + 1) % N;\n            bad[left]--;\n            bad[right]++;\n            if (left > right)\n                bad[0]--;\n        }\n\n        int best = -N;\n        int ans = 0, cur = 0;\n        for (int i = 0; i < N; ++i) {\n            cur += bad[i];\n            if (cur > best) {\n                best = cur;\n                ans = i;\n            }\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 129,
      "question": "Can you solve this real interview question? Champagne Tower - We stack glasses in a pyramid, where the first row has 1 glass, the second row has 2 glasses, and so on until the 100th row.  Each glass holds one cup of champagne.\n\nThen, some champagne is poured into the first glass at the top.  When the topmost glass is full, any excess liquid poured will fall equally to the glass immediately to the left and right of it.  When those glasses become full, any excess champagne will fall equally to the left and right of those glasses, and so on.  (A glass at the bottom row has its excess champagne fall on the floor.)\n\nFor example, after one cup of champagne is poured, the top most glass is full.  After two cups of champagne are poured, the two glasses on the second row are half full.  After three cups of champagne are poured, those two cups become full - there are 3 full glasses total now.  After four cups of champagne are poured, the third row has the middle glass half full, and the two outside glasses are a quarter full, as pictured below.\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/09/tower.png]\n\nNow after pouring some non-negative integer cups of champagne, return how full the jth glass in the ith row is (both i and j are 0-indexed.)\n\n \n\nExample 1:\n\n\r\nInput: poured = 1, query_row = 1, query_glass = 1\r\nOutput: 0.00000\r\nExplanation: We poured 1 cup of champange to the top glass of the tower (which is indexed as (0, 0)). There will be no excess liquid so all the glasses under the top glass will remain empty.\r\n\n\nExample 2:\n\n\r\nInput: poured = 2, query_row = 1, query_glass = 1\r\nOutput: 0.50000\r\nExplanation: We poured 2 cups of champange to the top glass of the tower (which is indexed as (0, 0)). There is one cup of excess liquid. The glass indexed as (1, 0) and the glass indexed as (1, 1) will share the excess liquid equally, and each will get half cup of champange.\r\n\n\nExample 3:\n\n\r\nInput: poured = 100000009, query_row = 33, query_glass = 17\r\nOutput: 1.00000\r\n\n\n \n\nConstraints:\n\n * 0 <= poured <= 109\n * 0 <= query_glass <= query_row < 100",
      "code": "class Solution {\npublic:\n    double champagneTower(int poured, int query_row, int \nquery_glass) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public double champagneTower(int poured, int query_row, int query_glass) {\n        double[][] A = new double[102][102];\n        A[0][0] = (double) poured;\n        for (int r = 0; r <= query_row; ++r) {\n            for (int c = 0; c <= r; ++c) {\n                double q = (A[r][c] - 1.0) / 2.0;\n                if (q > 0) {\n                    A[r+1][c] += q;\n                    A[r+1][c+1] += q;\n                }\n            }\n        }\n\n        return Math.min(1, A[query_row][query_glass]);\n    }\n}"
      ]
    },
    {
      "number": 130,
      "question": "Can you solve this real interview question? Find Eventual Safe States - There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\n\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\n\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.\n\n \n\nExample 1:\n\nIllustration of graph [https://s3-lc-upload.s3.amazonaws.com/uploads/2018/03/17/picture1.png]\n\n\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nExplanation: The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\nExample 2:\n\n\nInput: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]\nExplanation:\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n\n\n \n\nConstraints:\n\n * n == graph.length\n * 1 <= n <= 104\n * 0 <= graph[i].length <= n\n * 0 <= graph[i][j] <= n - 1\n * graph[i] is sorted in a strictly increasing order.\n * The graph may contain self-loops.\n * The number of edges in the graph will be in the range [1, 4 * 104].",
      "code": "class Solution {\npublic:\n    vector<int> eventualSafeNodes(vector<vector<int>>& \ngraph) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<int> indegree(n);\n        vector<vector<int>> adj(n);\n\n        for (int i = 0; i < n; i++) {\n            for (auto node : graph[i]) {\n                adj[node].push_back(i);\n                indegree[i]++;\n            }\n        }\n\n        queue<int> q;\n        // Push all the nodes with indegree zero in the queue.\n        for (int i = 0; i < n; i++) {\n            if (indegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        vector<bool> safe(n);\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            safe[node] = true;\n\n            for (auto& neighbor : adj[node]) {\n                // Delete the edge \"node -> neighbor\".\n                indegree[neighbor]--;\n                if (indegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        vector<int> safeNodes;\n        for(int i = 0; i < n; i++) {\n            if(safe[i]) {\n                safeNodes.push_back(i);\n            }\n        }\n        return safeNodes;\n    }\n};",
        "class Solution {\npublic:\n    bool dfs(int node, vector<vector<int>>& adj, vector<bool>& visit, vector<bool>& inStack) {\n        // If the node is already in the stack, we have a cycle.\n        if (inStack[node]) {\n            return true;\n        }\n        if (visit[node]) {\n            return false;\n        }\n        // Mark the current node as visited and part of current recursion stack.\n        visit[node] = true;\n        inStack[node] = true;\n        for (auto neighbor : adj[node]) {\n            if (dfs(neighbor, adj, visit, inStack)) {\n                return true;\n            }\n        }\n        // Remove the node from the stack.\n        inStack[node] = false;\n        return false;\n    }\n\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        int n = graph.size();\n        vector<bool> visit(n), inStack(n);\n\n        for (int i = 0; i < n; i++) {\n            dfs(i, graph, visit, inStack);\n        }\n\n        vector<int> safeNodes;\n        for (int i = 0; i < n; i++) {\n            if (!inStack[i]) {\n                safeNodes.push_back(i);\n            }\n        }\n\n        return safeNodes;\n    }\n};"
      ]
    },
    {
      "number": 131,
      "question": "Can you solve this real interview question? Bricks Falling When Hit - You are given an m x n binary grid, where each 1 represents a brick and 0 represents an empty space. A brick is stable if:\n\n * It is directly connected to the top of the grid, or\n * At least one other brick in its four adjacent cells is stable.\n\nYou are also given an array hits, which is a sequence of erasures we want to apply. Each time we want to erase the brick at the location hits[i] = (rowi, coli). The brick on that location (if it exists) will disappear. Some other bricks may no longer be stable because of that erasure and will fall. Once a brick falls, it is immediately erased from the grid (i.e., it does not land on other stable bricks).\n\nReturn an array result, where each result[i] is the number of bricks that will fall after the ith erasure is applied.\n\nNote that an erasure may refer to a location with no brick, and if it does, no bricks drop.\n\n \n\nExample 1:\n\n\nInput: grid = [[1,0,0,0],[1,1,1,0]], hits = [[1,0]]\nOutput: [2]\nExplanation: Starting with the grid:\n[[1,0,0,0],\n [1,1,1,0]]\nWe erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,1,1,0]]\nThe two underlined bricks are no longer stable as they are no longer connected to the top nor adjacent to another stable brick, so they will fall. The resulting grid is:\n[[1,0,0,0],\n [0,0,0,0]]\nHence the result is [2].\n\n\nExample 2:\n\n\nInput: grid = [[1,0,0,0],[1,1,0,0]], hits = [[1,1],[1,0]]\nOutput: [0,0]\nExplanation: Starting with the grid:\n[[1,0,0,0],\n [1,1,0,0]]\nWe erase the underlined brick at (1,1), resulting in the grid:\n[[1,0,0,0],\n [1,0,0,0]]\nAll remaining bricks are still stable, so no bricks fall. The grid remains the same:\n[[1,0,0,0],\n [1,0,0,0]]\nNext, we erase the underlined brick at (1,0), resulting in the grid:\n[[1,0,0,0],\n [0,0,0,0]]\nOnce again, all remaining bricks are still stable, so no bricks fall.\nHence the result is [0,0].\n\n\n \n\nConstraints:\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 200\n * grid[i][j] is 0 or 1.\n * 1 <= hits.length <= 4 * 104\n * hits[i].length == 2\n * 0 <= xi <= m - 1\n * 0 <= yi <= n - 1\n * All (xi, yi) are unique.",
      "code": "class Solution {\npublic:\n    vector<int> hitBricks(vector<vector<int>>& grid, \nvector<vector<int>>& hits) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] hitBricks(int[][] grid, int[][] hits) {\n        int R = grid.length, C = grid[0].length;\n        int[] dr = {1, 0, -1, 0};\n        int[] dc = {0, 1, 0, -1};\n\n        int[][] A = new int[R][C];\n        for (int r = 0; r < R; ++r)\n            A[r] = grid[r].clone();\n        for (int[] hit: hits)\n            A[hit[0]][hit[1]] = 0;\n\n        DSU dsu = new DSU(R*C + 1);\n        for (int r = 0; r < R; ++r) {\n            for (int c = 0; c < C; ++c) {\n                if (A[r][c] == 1) {\n                    int i = r * C + c;\n                    if (r == 0)\n                        dsu.union(i, R*C);\n                    if (r > 0 && A[r-1][c] == 1)\n                        dsu.union(i, (r-1) *C + c);\n                    if (c > 0 && A[r][c-1] == 1)\n                        dsu.union(i, r * C + c-1);\n                }\n            }\n        }\n        int t = hits.length;\n        int[] ans = new int[t--];\n\n        while (t >= 0) {\n            int r = hits[t][0];\n            int c = hits[t][1];\n            int preRoof = dsu.top();\n            if (grid[r][c] == 0) {\n                t--;\n            } else {\n                int i = r * C + c;\n                for (int k = 0; k < 4; ++k) {\n                    int nr = r + dr[k];\n                    int nc = c + dc[k];\n                    if (0 <= nr && nr < R && 0 <= nc && nc < C && A[nr][nc] == 1)\n                        dsu.union(i, nr * C + nc);\n                }\n                if (r == 0)\n                    dsu.union(i, R*C);\n                A[r][c] = 1;\n                ans[t--] = Math.max(0, dsu.top() - preRoof - 1);\n            }\n        }\n\n        return ans;\n    }\n}\n\nclass DSU {\n    int[] parent;\n    int[] rank;\n    int[] sz;\n\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n        rank = new int[N];\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) return;\n\n        if (rank[xr] < rank[yr]) {\n            int tmp = yr;\n            yr = xr;\n            xr = tmp;\n        }\n        if (rank[xr] == rank[yr])\n            rank[xr]++;\n\n        parent[yr] = xr;\n        sz[xr] += sz[yr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n\n    public int top() {\n        return size(sz.length - 1) - 1;\n    }\n}"
      ]
    },
    {
      "number": 132,
      "question": "Can you solve this real interview question? Unique Morse Code Words - International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows:\n\n * 'a' maps to \".-\",\n * 'b' maps to \"-...\",\n * 'c' maps to \"-.-.\", and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n\nGiven an array of strings words where each word can be written as a concatenation of the Morse code of each letter.\n\n * For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n\n \n\nExample 1:\n\n\nInput: words = [\"gin\",\"zen\",\"gig\",\"msg\"]\nOutput: 2\nExplanation: The transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\nThere are 2 different transformations: \"--...-.\" and \"--...--.\".\n\n\nExample 2:\n\n\nInput: words = [\"a\"]\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 100\n * 1 <= words[i].length <= 12\n * words[i] consists of lowercase English letters.",
      "code": "class Solution {\npublic:\n    int uniqueMorseRepresentations(vector<string>& words) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int uniqueMorseRepresentations(String[] words) {\n        String[] MORSE = new String[]{\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\n                         \"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\n                         \"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\n                         \"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n\n        Set<String> seen = new HashSet();\n        for (String word: words) {\n            StringBuilder code = new StringBuilder();\n            for (char c: word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n}"
      ]
    },
    {
      "number": 133,
      "question": "Can you solve this real interview question? Number of Lines To Write String - You are given a string s of lowercase English letters and an array widths denoting how many pixels wide each lowercase English letter is. Specifically, widths[0] is the width of 'a', widths[1] is the width of 'b', and so on.\n\nYou are trying to write s across several lines, where each line is no longer than 100 pixels. Starting at the beginning of s, write as many letters on the first line such that the total width does not exceed 100 pixels. Then, from where you stopped in s, continue writing as many letters as you can on the second line. Continue this process until you have written all of s.\n\nReturn an array result of length 2 where:\n\n * result[0] is the total number of lines.\n * result[1] is the width of the last line in pixels.\n\n \n\nExample 1:\n\n\nInput: widths = [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"abcdefghijklmnopqrstuvwxyz\"\nOutput: [3,60]\nExplanation: You can write s as follows:\nabcdefghij  // 100 pixels wide\nklmnopqrst  // 100 pixels wide\nuvwxyz      // 60 pixels wide\nThere are a total of 3 lines, and the last line is 60 pixels wide.\n\nExample 2:\n\n\nInput: widths = [4,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10], s = \"bbbcccdddaaa\"\nOutput: [2,4]\nExplanation: You can write s as follows:\nbbbcccdddaa  // 98 pixels wide\na            // 4 pixels wide\nThere are a total of 2 lines, and the last line is 4 pixels wide.\n\n \n\nConstraints:\n\n * widths.length == 26\n * 2 <= widths[i] <= 10\n * 1 <= s.length <= 1000\n * s contains only lowercase English letters.",
      "code": "class Solution {\npublic:\n    vector<int> numberOfLines(vector<int>& widths, string s) \n{\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] numberOfLines(int[] widths, String S) {\n        int lines = 1, width = 0;\n        for (char c: S.toCharArray()) {\n            int w = widths[c - 'a'];\n            width += w;\n            if (width > 100) {\n                lines++;\n                width = w;\n            }\n        }\n\n        return new int[]{lines, width};\n    }\n}"
      ]
    },
    {
      "number": 134,
      "question": "Can you solve this real interview question? Max Increase to Keep City Skyline - There is a city composed of n x n blocks, where each block contains a single building shaped like a vertical square prism. You are given a 0-indexed n x n integer matrix grid where grid[r][c] represents the height of the building located in the block at row r and column c.\n\nA city's skyline is the outer contour formed by all the building when viewing the side of the city from a distance. The skyline from each cardinal direction north, east, south, and west may be different.\n\nWe are allowed to increase the height of any number of buildings by any amount (the amount can be different per building). The height of a 0-height building can also be increased. However, increasing the height of a building should not affect the city's skyline from any cardinal direction.\n\nReturn the maximum total sum that the height of the buildings can be increased by without changing the city's skyline from any cardinal direction.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/06/21/807-ex1.png]\n\n\nInput: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]\nOutput: 35\nExplanation: The building heights are shown in the center of the above image.\nThe skylines when viewed from each cardinal direction are drawn in red.\nThe grid after increasing the height of buildings without affecting skylines is:\ngridNew = [ [8, 4, 8, 7],\n            [7, 4, 7, 7],\n            [9, 4, 8, 7],\n            [3, 3, 3, 3] ]\n\n\nExample 2:\n\n\nInput: grid = [[0,0,0],[0,0,0],[0,0,0]]\nOutput: 0\nExplanation: Increasing the height of any building will result in the skyline changing.\n\n\n \n\nConstraints:\n\n * n == grid.length\n * n == grid[r].length\n * 2 <= n <= 50\n * 0 <= grid[r][c] <= 100",
      "code": "class Solution {\npublic:\n    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) \n{\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\n        int N = grid.length;\n        int[] rowMaxes = new int[N];\n        int[] colMaxes = new int[N];\n\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c) {\n                rowMaxes[r] = Math.max(rowMaxes[r], grid[r][c]);\n                colMaxes[c] = Math.max(colMaxes[c], grid[r][c]);\n        }\n\n        int ans = 0;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                ans += Math.min(rowMaxes[r], colMaxes[c]) - grid[r][c];\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 135,
      "question": "Can you solve this real interview question? Soup Servings - There are two types of soup: type A and type B. Initially, we have n ml of each type of soup. There are four kinds of operations:\n\n 1. Serve 100 ml of soup A and 0 ml of soup B,\n 2. Serve 75 ml of soup A and 25 ml of soup B,\n 3. Serve 50 ml of soup A and 50 ml of soup B, and\n 4. Serve 25 ml of soup A and 75 ml of soup B.\n\nWhen we serve some soup, we give it to someone, and we no longer have it. Each turn, we will choose from the four operations with an equal probability 0.25. If the remaining volume of soup is not enough to complete the operation, we will serve as much as possible. We stop once we no longer have some quantity of both types of soup.\n\nNote that we do not have an operation where all 100 ml's of soup B are used first.\n\nReturn the probability that soup A will be empty first, plus half the probability that A and B become empty at the same time. Answers within 10-5 of the actual answer will be accepted.\n\n \n\nExample 1:\n\n\nInput: n = 50\nOutput: 0.62500\nExplanation: If we choose the first two operations, A will become empty first.\nFor the third operation, A and B will become empty at the same time.\nFor the fourth operation, B will become empty first.\nSo the total probability of A becoming empty first plus half the probability that A and B become empty at the same time, is 0.25 * (1 + 1 + 0.5 + 0) = 0.625.\n\n\nExample 2:\n\n\nInput: n = 100\nOutput: 0.71875\n\n\n \n\nConstraints:\n\n * 0 <= n <= 109",
      "code": "class Solution {\npublic:\n    double soupServings(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    double soupServings(int n) {\n        int m = ceil(n / 25.0);\n        unordered_map<int, unordered_map<int, double>> dp;\n\n        function<double(int, int)> calculateDP = [&](int i, int j) -> double {\n            return (dp[max(0, i - 4)][j] + dp[max(0, i - 3)][j - 1] +\n                    dp[max(0, i - 2)][max(0, j - 2)] + dp[i - 1][max(0, j - 3)]) /\n                   4;\n        };\n\n        dp[0][0] = 0.5;\n        for (int k = 1; k <= m; k++) {\n            dp[0][k] = 1;\n            dp[k][0] = 0;\n            for (int j = 1; j <= k; j++) {\n                dp[j][k] = calculateDP(j, k);\n                dp[k][j] = calculateDP(k, j);\n            }\n            if (dp[k][k] > 1 - 1e-5) {\n                return 1;\n            }\n        }\n        return dp[m][m];\n    }\n};",
        "class Solution {\npublic:\n    double soupServings(int n) {\n        int m = ceil(n / 25.0);\n        unordered_map<int, unordered_map<int, double>> dp;\n\n        function<double(int, int)> calculateDP = [&](int i, int j) -> double {\n            if (i <= 0 && j <= 0) {\n                return 0.5;\n            }\n            if (i <= 0) {\n                return 1;\n            }\n            if (j <= 0) {\n                return 0;\n            }\n            if (dp[i].count(j)) {\n                return dp[i][j];\n            }\n            return dp[i][j] = (calculateDP(i - 4, j) + calculateDP(i - 3, j - 1) +\n                               calculateDP(i - 2, j - 2) + calculateDP(i - 1, j - 3)) /\n                              4;\n        };\n\n        for (int k = 1; k <= m; k++) {\n            if (calculateDP(k, k) > 1 - 1e-5) {\n                return 1;\n            }\n        }\n        return calculateDP(m, m);\n    }\n};"
      ]
    },
    {
      "number": 136,
      "question": "Can you solve this real interview question? Chalkboard XOR Game - You are given an array of integers nums represents the numbers written on a chalkboard.\n\nAlice and Bob take turns erasing exactly one number from the chalkboard, with Alice starting first. If erasing a number causes the bitwise XOR of all the elements of the chalkboard to become 0, then that player loses. The bitwise XOR of one element is that element itself, and the bitwise XOR of no elements is 0.\n\nAlso, if any player starts their turn with the bitwise XOR of all the elements of the chalkboard equal to 0, then that player wins.\n\nReturn true if and only if Alice wins the game, assuming both players play optimally.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput: false\nExplanation: \nAlice has two choices: erase 1 or erase 2. \nIf she erases 1, the nums array becomes [1, 2]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 2 = 3. Now Bob can remove any element he wants, because Alice will be the one to erase the last element and she will lose. \nIf Alice erases 2 first, now nums become [1, 1]. The bitwise XOR of all the elements of the chalkboard is 1 XOR 1 = 0. Alice will lose.\n\n\nExample 2:\n\n\nInput: nums = [0,1]\nOutput: true\n\n\nExample 3:\n\n\nInput: nums = [1,2,3]\nOutput: true\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 1000\n * 0 <= nums[i] < 216",
      "code": "class Solution {\npublic:\n    bool xorGame(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean xorGame(int[] nums) {\n      int x = 0;\n      for (int v : nums) x ^= v;\n      return x == 0 || nums.length % 2 == 0;\n    }\n}"
      ]
    },
    {
      "number": 137,
      "question": "Can you solve this real interview question? Subdomain Visit Count - A website domain \"discuss.leetcode.com\" consists of various subdomains. At the top level, we have \"com\", at the next level, we have \"leetcode.com\" and at the lowest level, \"discuss.leetcode.com\". When we visit a domain like \"discuss.leetcode.com\", we will also visit the parent domains \"leetcode.com\" and \"com\" implicitly.\n\nA count-paired domain is a domain that has one of the two formats \"rep d1.d2.d3\" or \"rep d1.d2\" where rep is the number of visits to the domain and d1.d2.d3 is the domain itself.\n\n * For example, \"9001 discuss.leetcode.com\" is a count-paired domain that indicates that discuss.leetcode.com was visited 9001 times.\n\nGiven an array of count-paired domains cpdomains, return an array of the count-paired domains of each subdomain in the input. You may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: cpdomains = [\"9001 discuss.leetcode.com\"]\nOutput: [\"9001 leetcode.com\",\"9001 discuss.leetcode.com\",\"9001 com\"]\nExplanation: We only have one website domain: \"discuss.leetcode.com\".\nAs discussed above, the subdomain \"leetcode.com\" and \"com\" will also be visited. So they will all be visited 9001 times.\n\n\nExample 2:\n\n\nInput: cpdomains = [\"900 google.mail.com\", \"50 yahoo.com\", \"1 intel.mail.com\", \"5 wiki.org\"]\nOutput: [\"901 mail.com\",\"50 yahoo.com\",\"900 google.mail.com\",\"5 wiki.org\",\"5 org\",\"1 intel.mail.com\",\"951 com\"]\nExplanation: We will visit \"google.mail.com\" 900 times, \"yahoo.com\" 50 times, \"intel.mail.com\" once and \"wiki.org\" 5 times.\nFor the subdomains, we will visit \"mail.com\" 900 + 1 = 901 times, \"com\" 900 + 50 + 1 = 951 times, and \"org\" 5 times.\n\n\n \n\nConstraints:\n\n * 1 <= cpdomain.length <= 100\n * 1 <= cpdomain[i].length <= 100\n * cpdomain[i] follows either the \"repi d1i.d2i.d3i\" format or the \"repi d1i.d2i\" format.\n * repi is an integer in the range [1, 104].\n * d1i, d2i, and d3i consist of lowercase English letters.",
      "code": "class Solution {\npublic:\n    vector<string> subdomainVisits(vector<string>& \ncpdomains) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<String> subdomainVisits(String[] cpdomains) {\n        Map<String, Integer> counts = new HashMap();\n        for (String domain: cpdomains) {\n            String[] cpinfo = domain.split(\"\\\\s+\");\n            String[] frags = cpinfo[1].split(\"\\\\.\");\n            int count = Integer.valueOf(cpinfo[0]);\n            String cur = \"\";\n            for (int i = frags.length - 1; i >= 0; --i) {\n                cur = frags[i] + (i < frags.length - 1 ? \".\" : \"\") + cur;\n                counts.put(cur, counts.getOrDefault(cur, 0) + count);\n            }\n        }\n\n        List<String> ans = new ArrayList();\n        for (String dom: counts.keySet())\n            ans.add(\"\" + counts.get(dom) + \" \" + dom);\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 138,
      "question": "Can you solve this real interview question? Largest Sum of Averages - You are given an integer array nums and an integer k. You can partition the array into at most k non-empty adjacent subarrays. The score of a partition is the sum of the averages of each subarray.\n\nNote that the partition must use every integer in nums, and that the score is not necessarily an integer.\n\nReturn the maximum score you can achieve of all the possible partitions. Answers within 10-6 of the actual answer will be accepted.\n\n \n\nExample 1:\n\n\nInput: nums = [9,1,2,3,9], k = 3\nOutput: 20.00000\nExplanation: \nThe best choice is to partition nums into [9], [1, 2, 3], [9]. The answer is 9 + (1 + 2 + 3) / 3 + 9 = 20.\nWe could have also partitioned nums into [9, 1], [2], [3, 9], for example.\nThat partition would lead to a score of 5 + 2 + 6 = 13, which is worse.\n\n\nExample 2:\n\n\nInput: nums = [1,2,3,4,5,6,7], k = 4\nOutput: 20.50000\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 1 <= nums[i] <= 104\n * 1 <= k <= nums.length",
      "code": "class Solution {\npublic:\n    double largestSumOfAverages(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public double largestSumOfAverages(int[] A, int K) {\n        int N = A.length;\n        double[] P = new double[N+1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + A[i];\n\n        double[] dp = new double[N];\n        for (int i = 0; i < N; ++i)\n            dp[i] = (P[N] - P[i]) / (N - i);\n\n        for (int k = 0; k < K-1; ++k)\n            for (int i = 0; i < N; ++i)\n                for (int j = i+1; j < N; ++j)\n                    dp[i] = Math.max(dp[i], (P[j]-P[i]) / (j-i) + dp[j]);\n\n        return dp[0];\n    }\n}"
      ]
    },
    {
      "number": 139,
      "question": "Can you solve this real interview question? Bus Routes - You are given an array routes representing bus routes where routes[i] is a bus route that the ith bus repeats forever.\n\n * For example, if routes[0] = [1, 5, 7], this means that the 0th bus travels in the sequence 1 -> 5 -> 7 -> 1 -> 5 -> 7 -> 1 -> ... forever.\n\nYou will start at the bus stop source (You are not on any bus initially), and you want to go to the bus stop target. You can travel between bus stops by buses only.\n\nReturn the least number of buses you must take to travel from source to target. Return -1 if it is not possible.\n\n \n\nExample 1:\n\n\nInput: routes = [[1,2,7],[3,6,7]], source = 1, target = 6\nOutput: 2\nExplanation: The best strategy is take the first bus to the bus stop 7, then take the second bus to the bus stop 6.\n\n\nExample 2:\n\n\nInput: routes = [[7,12],[4,5,15],[6],[15,19],[9,12,13]], source = 15, target = 12\nOutput: -1\n\n\n \n\nConstraints:\n\n * 1 <= routes.length <= 500.\n * 1 <= routes[i].length <= 105\n * All the values of routes[i] are unique.\n * sum(routes[i].length) <= 105\n * 0 <= routes[i][j] < 106\n * 0 <= source, target < 106",
      "code": "class Solution {\npublic:\n    int numBusesToDestination(vector<vector<int>>& routes, \nint source, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {\n        if (source == target) {\n            return 0;\n        }\n\n        unordered_map<int, vector<int>> adjList;\n        // Create a map from the bus stop to all the routes that include this stop.\n        for (int route = 0; route < routes.size(); route++) {\n            for (auto stop : routes[route]) {\n                // Add all the routes that have this stop.\n                adjList[stop].push_back(route);\n            }\n        }\n\n        queue<int> q;\n        unordered_set<int> vis;\n        // Insert all the routes in the queue that have the source stop.\n        for (auto route : adjList[source]){\n            q.push(route);\n            vis.insert(route);\n        }\n\n        int busCount = 1;\n        while (q.size()) {\n            int size = q.size();\n\n            for (int i = 0; i < size; i++) {\n                int route = q.front(); q.pop();\n\n                // Iterate over the stops in the current route.\n                for (auto stop: routes[route]) {\n                    // Return the current count if the target is found.\n                    if (stop == target) {\n                        return busCount;\n                    }\n\n                    // Iterate over the next possible routes from the current stop.\n                    for (auto nextRoute : adjList[stop]) {\n                        if (!vis.count(nextRoute)) {\n                            vis.insert(nextRoute);\n                            q.push(nextRoute);\n                        }\n                    }\n                }\n            }\n            busCount++;\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> adjList[501];\n    \n    // Iterate over each pair of routes and add an edge between them if there's a common stop.\n    void createGraph(vector<vector<int>>& routes) {\n        for (int i = 0; i < routes.size(); i++) {\n            for (int j = i + 1; j < routes.size(); j++) {\n                if (haveCommonNode(routes[i], routes[j])) {\n                    adjList[i].push_back(j);\n                    adjList[j].push_back(i);\n                }\n            }\n        }\n    }\n    \n    // Returns true if the provided routes have a common stop, false otherwise.\n    bool haveCommonNode(vector<int>& route1, vector<int>& route2) {\n        int i = 0, j = 0;\n        while (i < route1.size() && j < route2.size()) {\n            if (route1[i] == route2[j]) {\n                return true;\n            }\n            \n            route1[i] < route2[j] ? i++ : j++;\n        }\n        return false;\n    }\n    \n    // Add all the routes in the queue that have the source as one of the stops.\n    void addStartingNodes(queue<int>& q, vector<vector<int>>& routes, int source) {\n        for (int i = 0; i < routes.size(); i++) {\n            if (isStopExist(routes[i], source)) {\n                q.push(i);\n            }\n        }\n    }\n\n    // Returns true if the given stop is present in the route, false otherwise.\n    bool isStopExist(vector<int>& route, int stop) {\n        for (int j = 0; j < route.size(); j++) {\n            if (route[j] == stop) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    int numBusesToDestination(vector<vector<int>>& routes, int source, int target) {\n        if (source == target) {\n            return 0;\n        }\n        \n        for (int i = 0; i < routes.size(); ++i) {\n            sort(routes[i].begin(), routes[i].end());\n        }\n        \n        createGraph(routes);\n        \n        queue<int> q;\n        addStartingNodes(q, routes, source);\n        \n        vector<int> vis(routes.size(), 0);\n        int busCount = 1;\n        while (!q.empty()) {\n            int sz = q.size();\n            \n            while (sz--) {\n                int node = q.front();\n                q.pop();\n                \n                // Return busCount, if the stop target is present in the current route.\n                if (isStopExist(routes[node], target)) {\n                    return busCount;\n                }\n                \n                // Add the adjacent routes.\n                for (int adj : adjList[node]) {\n                    if (!vis[adj]) {\n                        vis[adj] = 1;\n                        q.push(adj);\n                    }\n                }\n            }\n            \n            busCount++;\n        }\n        \n        return -1;\n    }\n};"
      ]
    },
    {
      "number": 140,
      "question": "Can you solve this real interview question? Ambiguous Coordinates - We had some 2-dimensional coordinates, like \"(1, 3)\" or \"(2, 0.5)\". Then, we removed all commas, decimal points, and spaces and ended up with the string s.\n\n * For example, \"(1, 3)\" becomes s = \"(13)\" and \"(2, 0.5)\" becomes s = \"(205)\".\n\nReturn a list of strings representing all possibilities for what our original coordinates could have been.\n\nOur original representation never had extraneous zeroes, so we never started with numbers like \"00\", \"0.0\", \"0.00\", \"1.0\", \"001\", \"00.01\", or any other number that can be represented with fewer digits. Also, a decimal point within a number never occurs without at least one digit occurring before it, so we never started with numbers like \".1\".\n\nThe final answer list can be returned in any order. All coordinates in the final answer have exactly one space between them (occurring after the comma.)\n\n \n\nExample 1:\n\n\nInput: s = \"(123)\"\nOutput: [\"(1, 2.3)\",\"(1, 23)\",\"(1.2, 3)\",\"(12, 3)\"]\n\n\nExample 2:\n\n\nInput: s = \"(0123)\"\nOutput: [\"(0, 1.23)\",\"(0, 12.3)\",\"(0, 123)\",\"(0.1, 2.3)\",\"(0.1, 23)\",\"(0.12, 3)\"]\nExplanation: 0.0, 00, 0001 or 00.01 are not allowed.\n\n\nExample 3:\n\n\nInput: s = \"(00011)\"\nOutput: [\"(0, 0.011)\",\"(0.001, 1)\"]\n\n\n \n\nConstraints:\n\n * 4 <= s.length <= 12\n * s[0] == '(' and s[s.length - 1] == ')'.\n * The rest of s are digits.",
      "code": "class Solution {\npublic:\n    vector<string> ambiguousCoordinates(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution { //aw\n    public List<String> ambiguousCoordinates(String S) {\n        List<String> ans = new ArrayList();\n        for (int i = 2; i < S.length()-1; ++i)\n            for (String left: make(S, 1, i))\n                for (String right: make(S, i, S.length()-1))\n                    ans.add(\"(\" + left + \", \" + right + \")\");\n        return ans;\n    }\n\n    public List<String> make(String S, int i, int j) {\n        // Make on S.substring(i, j)\n        List<String> ans = new ArrayList();\n        for (int d = 1; d <= j-i; ++d) {\n            String left = S.substring(i, i+d);\n            String right = S.substring(i+d, j);\n            if ((!left.startsWith(\"0\") || left.equals(\"0\"))\n                    && !right.endsWith(\"0\"))\n                ans.add(left + (d < j-i ? \".\" : \"\") + right);\n        }\n        return ans;\n    }\n}\n"
      ]
    },
    {
      "number": 141,
      "question": "Can you solve this real interview question? Race Car - Your car starts at position 0 and speed +1 on an infinite number line. Your car can go into negative positions. Your car drives automatically according to a sequence of instructions 'A' (accelerate) and 'R' (reverse):\n\n * When you get an instruction 'A', your car does the following:\n   * position += speed\n   * speed *= 2\n * When you get an instruction 'R', your car does the following:\n   * If your speed is positive then speed = -1\n   * otherwise speed = 1\n   Your position stays the same.\n\nFor example, after commands \"AAR\", your car goes to positions 0 --> 1 --> 3 --> 3, and your speed goes to 1 --> 2 --> 4 --> -1.\n\nGiven a target position target, return the length of the shortest sequence of instructions to get there.\n\n \n\nExample 1:\n\n\nInput: target = 3\nOutput: 2\nExplanation: \nThe shortest instruction sequence is \"AA\".\nYour position goes from 0 --> 1 --> 3.\n\n\nExample 2:\n\n\nInput: target = 6\nOutput: 5\nExplanation: \nThe shortest instruction sequence is \"AAARA\".\nYour position goes from 0 --> 1 --> 3 --> 7 --> 7 --> 6.\n\n\n \n\nConstraints:\n\n * 1 <= target <= 104",
      "code": "class Solution {\npublic:\n    int racecar(int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int racecar(int target) {\n        int K = 33 - Integer.numberOfLeadingZeros(target - 1);\n        int barrier = 1 << K;\n        int[] dist = new int[2 * barrier + 1];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[target] = 0;\n\n        PriorityQueue<Node> pq = new PriorityQueue<Node>(\n            (a, b) -> a.steps - b.steps);\n        pq.offer(new Node(0, target));\n\n        while (!pq.isEmpty()) {\n            Node node = pq.poll();\n            int steps = node.steps, targ1 = node.target;\n            if (dist[Math.floorMod(targ1, dist.length)] > steps) continue;\n\n            for (int k = 0; k <= K; ++k) {\n                int walk = (1 << k) - 1;\n                int targ2 = walk - targ1;\n                int steps2 = steps + k + (targ2 != 0 ? 1 : 0);\n\n                if (Math.abs(targ2) <= barrier && steps2 < dist[Math.floorMod(targ2, dist.length)]) {\n                    pq.offer(new Node(steps2, targ2));\n                    dist[Math.floorMod(targ2, dist.length)] = steps2;\n                }\n            }\n        }\n\n        return dist[0];\n    }\n}\n\nclass Node {\n    int steps, target;\n    Node(int s, int t) {\n        steps = s;\n        target = t;\n    }\n}",
        "class Solution {\n    public int racecar(int target) {\n        int[] dp = new int[target + 3];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0; dp[1] = 1; dp[2] = 4;\n\n        for (int t = 3; t <= target; ++t) {\n            int k = 32 - Integer.numberOfLeadingZeros(t);\n            if (t == (1<<k) - 1) {\n                dp[t] = k;\n                continue;\n            }\n            for (int j = 0; j < k-1; ++j)\n                dp[t] = Math.min(dp[t], dp[t - (1<<(k-1)) + (1<<j)] + k-1 + j + 2);\n            if ((1<<k) - 1 - t < t)\n                dp[t] = Math.min(dp[t], dp[(1<<k) - 1 - t] + k + 1);\n        }\n\n        return dp[target];  \n    }\n}"
      ]
    },
    {
      "number": 142,
      "question": "Can you solve this real interview question? Most Common Word - Given a string paragraph and a string array of the banned words banned, return the most frequent word that is not banned. It is guaranteed there is at least one word that is not banned, and that the answer is unique.\n\nThe words in paragraph are case-insensitive and the answer should be returned in lowercase.\n\n \n\nExample 1:\n\n\nInput: paragraph = \"Bob hit a ball, the hit BALL flew far after it was hit.\", banned = [\"hit\"]\nOutput: \"ball\"\nExplanation: \n\"hit\" occurs 3 times, but it is a banned word.\n\"ball\" occurs twice (and no other word does), so it is the most frequent non-banned word in the paragraph. \nNote that words in the paragraph are not case sensitive,\nthat punctuation is ignored (even if adjacent to words, such as \"ball,\"), \nand that \"hit\" isn't the answer even though it occurs more because it is banned.\n\n\nExample 2:\n\n\nInput: paragraph = \"a.\", banned = []\nOutput: \"a\"\n\n\n \n\nConstraints:\n\n * 1 <= paragraph.length <= 1000\n * paragraph consists of English letters, space ' ', or one of the symbols: \"!?',;.\".\n * 0 <= banned.length <= 100\n * 1 <= banned[i].length <= 10\n * banned[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string mostCommonWord(string paragraph, vector<string>& \nbanned) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n\n        // 1). replace the punctuations with spaces,\n        // and put all letters in lower case\n        String normalizedStr = paragraph.replaceAll(\"[^a-zA-Z0-9 ]\", \" \").toLowerCase();\n\n        // 2). split the string into words\n        String[] words = normalizedStr.split(\"\\\\s+\");\n\n        Set<String> bannedWords = new HashSet();\n        for (String word : banned)\n            bannedWords.add(word);\n\n        Map<String, Integer> wordCount = new HashMap();\n        // 3). count the appearance of each word, excluding the banned words\n        for (String word : words) {\n            if (!bannedWords.contains(word))\n                wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\n        }\n\n        // 4). return the word with the highest frequency\n        return Collections.max(wordCount.entrySet(), Map.Entry.comparingByValue()).getKey();\n    }\n}",
        "class Solution {\n    public String mostCommonWord(String paragraph, String[] banned) {\n\n        Set<String> bannedWords = new HashSet();\n        for (String word : banned)\n            bannedWords.add(word);\n\n        String ans = \"\";\n        int maxCount = 0;\n        Map<String, Integer> wordCount = new HashMap();\n        StringBuilder wordBuffer = new StringBuilder();\n        char[] chars = paragraph.toCharArray();\n\n        for (int p = 0; p < chars.length; ++p) {\n            char currChar = chars[p];\n\n            // 1). consume the characters in a word\n            if (Character.isLetter(currChar)) {\n                wordBuffer.append(Character.toLowerCase(currChar));\n                if (p != chars.length - 1)\n                    // skip the rest of the processing\n                    continue;\n            }\n\n            // 2). at the end of one word or at the end of paragraph\n            if (wordBuffer.length() > 0) {\n                String word = wordBuffer.toString();\n                // identify the maximum count while updating the wordCount table.\n                if (!bannedWords.contains(word)) {\n                    int newCount = wordCount.getOrDefault(word, 0) + 1;\n                    wordCount.put(word, newCount);\n                    if (newCount > maxCount) {\n                        ans = word;\n                        maxCount = newCount;\n                    }\n                }\n                // reset the buffer for the next word\n                wordBuffer = new StringBuilder();\n            }\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 143,
      "question": "Can you solve this real interview question? Short Encoding of Words - A valid encoding of an array of words is any reference string s and array of indices indices such that:\n\n * words.length == indices.length\n * The reference string s ends with the '#' character.\n * For each index indices[i], the substring of s starting from indices[i] and up to (but not including) the next '#' character is equal to words[i].\n\nGiven an array of words, return the length of the shortest reference string s possible of any valid encoding of words.\n\n \n\nExample 1:\n\n\nInput: words = [\"time\", \"me\", \"bell\"]\nOutput: 10\nExplanation: A valid encoding would be s = \"time#bell#\" and indices = [0, 2, 5].\nwords[0] = \"time\", the substring of s starting from indices[0] = 0 to the next '#' is underlined in \"time#bell#\"\nwords[1] = \"me\", the substring of s starting from indices[1] = 2 to the next '#' is underlined in \"time#bell#\"\nwords[2] = \"bell\", the substring of s starting from indices[2] = 5 to the next '#' is underlined in \"time#bell#\"\n\n\nExample 2:\n\n\nInput: words = [\"t\"]\nOutput: 2\nExplanation: A valid encoding would be s = \"t#\" and indices = [0].\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 2000\n * 1 <= words[i].length <= 7\n * words[i] consists of only lowercase letters.",
      "code": "class Solution {\npublic:\n    int minimumLengthEncoding(vector<string>& words) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minimumLengthEncoding(String[] words) {\n        Set<String> good = new HashSet(Arrays.asList(words));\n        for (String word: words) {\n            for (int k = 1; k < word.length(); ++k)\n                good.remove(word.substring(k));\n        }\n\n        int ans = 0;\n        for (String word: good)\n            ans += word.length() + 1;\n        return ans;\n    }\n}",
        "class Solution {\n    public int minimumLengthEncoding(String[] words) {\n        TrieNode trie = new TrieNode();\n        Map<TrieNode, Integer> nodes = new HashMap();\n\n        for (int i = 0; i < words.length; ++i) {\n            String word = words[i];\n            TrieNode cur = trie;\n            for (int j = word.length() - 1; j >= 0; --j)\n                cur = cur.get(word.charAt(j));\n            nodes.put(cur, i);\n        }\n\n        int ans = 0;\n        for (TrieNode node: nodes.keySet()) {\n            if (node.count == 0)\n                ans += words[nodes.get(node)].length() + 1;\n        }\n        return ans;\n\n    }\n}\n\nclass TrieNode {\n    TrieNode[] children;\n    int count;\n    TrieNode() {\n        children = new TrieNode[26];\n        count = 0;\n    }\n    public TrieNode get(char c) {\n        if (children[c-'a'] == null) {\n            children[c-'a'] = new TrieNode();\n            count++;\n        }\n        return children[c - 'a'];\n    }\n}"
      ]
    },
    {
      "number": 144,
      "question": "Can you solve this real interview question? Most Profit Assigning Work - You have n jobs and m workers. You are given three arrays: difficulty, profit, and worker where:\n\n * difficulty[i] and profit[i] are the difficulty and the profit of the ith job, and\n * worker[j] is the ability of jth worker (i.e., the jth worker can only complete a job with difficulty at most worker[j]).\n\nEvery worker can be assigned at most one job, but one job can be completed multiple times.\n\n * For example, if three workers attempt the same job that pays $1, then the total profit will be $3. If a worker cannot complete any job, their profit is $0.\n\nReturn the maximum profit we can achieve after assigning the workers to the jobs.\n\n \n\nExample 1:\n\n\nInput: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]\nOutput: 100\nExplanation: Workers are assigned jobs of difficulty [4,4,6,6] and they get a profit of [20,20,30,30] separately.\n\n\nExample 2:\n\n\nInput: difficulty = [85,47,57], profit = [24,66,99], worker = [40,25,25]\nOutput: 0\n\n\n \n\nConstraints:\n\n * n == difficulty.length\n * n == profit.length\n * m == worker.length\n * 1 <= n, m <= 104\n * 1 <= difficulty[i], profit[i], worker[i] <= 105",
      "code": "class Solution {\npublic:\n    int maxProfitAssignment(vector<int>& difficulty, \nvector<int>& profit, vector<int>& worker) {\n        \n    }\n};",
      "solution": [
        "import java.awt.Point;\n\nclass Solution {\n    public int maxProfitAssignment(int[] difficulty, int[] profit, int[] worker) {\n        int N = difficulty.length;\n        Point[] jobs = new Point[N];\n        for (int i = 0; i < N; ++i)\n            jobs[i] = new Point(difficulty[i], profit[i]);\n        Arrays.sort(jobs, (a, b) -> a.x - b.x);\n        Arrays.sort(worker);\n\n        int ans = 0, i = 0, best = 0;\n        for (int skill: worker) {\n            while (i < N && skill >= jobs[i].x)\n                best = Math.max(best, jobs[i++].y);\n            ans += best;\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 145,
      "question": "Can you solve this real interview question? Making A Large Island - You are given an n x n binary matrix grid. You are allowed to change at most one 0 to be 1.\n\nReturn the size of the largest island in grid after applying this operation.\n\nAn island is a 4-directionally connected group of 1s.\n\n \n\nExample 1:\n\n\r\nInput: grid = [[1,0],[0,1]]\r\nOutput: 3\r\nExplanation: Change one 0 to 1 and connect two 1s, then we get an island with area = 3.\r\n\n\nExample 2:\n\n\r\nInput: grid = [[1,1],[1,0]]\r\nOutput: 4\r\nExplanation: Change the 0 to 1 and make the island bigger, only one island with area = 4.\n\nExample 3:\n\n\r\nInput: grid = [[1,1],[1,1]]\r\nOutput: 4\r\nExplanation: Can't change any 0 to 1, only one island with area = 4.\r\n\n\n \n\nConstraints:\n\n * n == grid.length\n * n == grid[i].length\n * 1 <= n <= 500\n * grid[i][j] is either 0 or 1.",
      "code": "class Solution {\npublic:\n    int largestIsland(vector<vector<int>>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n\n    public int largestIsland(int[][] grid) {\n        int N = grid.length;\n\n        int ans = 0;\n        boolean hasZero = false;\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 0) {\n                    hasZero = true;\n                    grid[r][c] = 1;\n                    ans = Math.max(ans, check(grid, r, c));\n                    grid[r][c] = 0;\n                }\n\n        return hasZero ? ans : N*N;\n    }\n\n    public int check(int[][] grid, int r0, int c0) {\n        int N = grid.length;\n        Stack<Integer> stack = new Stack();\n        Set<Integer> seen = new HashSet();\n        stack.push(r0 * N + c0);\n        seen.add(r0 * N + c0);\n\n        while (!stack.isEmpty()) {\n            int code = stack.pop();\n            int r = code / N, c = code % N;\n            for (int k = 0; k < 4; ++k) {\n                int nr = r + dr[k], nc = c + dc[k];\n                if (!seen.contains(nr * N + nc) && 0 <= nr && nr < N &&\n                        0 <= nc && nc < N && grid[nr][nc] == 1) {\n                    stack.push(nr * N + nc);\n                    seen.add(nr * N + nc);\n                }\n            }\n        }\n\n        return seen.size();\n    }\n}\n",
        "class Solution {\n    int[] dr = new int[]{-1, 0, 1, 0};\n    int[] dc = new int[]{0, -1, 0, 1};\n    int[][] grid;\n    int N;\n\n    public int largestIsland(int[][] grid) {\n        this.grid = grid;\n        N = grid.length;\n\n        int index = 2;\n        int[] area = new int[N*N + 2];\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 1)\n                    area[index] = dfs(r, c, index++);\n\n        int ans = 0;\n        for (int x: area) ans = Math.max(ans, x);\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c)\n                if (grid[r][c] == 0) {\n                    Set<Integer> seen = new HashSet();\n                    for (Integer move: neighbors(r, c))\n                        if (grid[move / N][move % N] > 1)\n                            seen.add(grid[move / N][move % N]);\n\n                    int bns = 1;\n                    for (int i: seen) bns += area[i];\n                    ans = Math.max(ans, bns);\n                }\n\n        return ans;\n    }\n\n    public int dfs(int r, int c, int index) {\n        int ans = 1;\n        grid[r][c] = index;\n        for (Integer move: neighbors(r, c)) {\n            if (grid[move / N][move % N] == 1) {\n                grid[move / N][move % N] = index;\n                ans += dfs(move / N, move % N, index);\n            }\n        }\n\n        return ans;\n    }\n\n    public List<Integer> neighbors(int r, int c) {\n        List<Integer> ans = new ArrayList();\n        for (int k = 0; k < 4; ++k) {\n            int nr = r + dr[k];\n            int nc = c + dc[k];\n            if (0 <= nr && nr < N && 0 <= nc && nc < N)\n                ans.add(nr * N + nc);\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 146,
      "question": "Can you solve this real interview question? Positions of Large Groups - In a string s of lowercase letters, these letters form consecutive groups of the same character.\n\nFor example, a string like s = \"abbxxxxzyy\" has the groups \"a\", \"bb\", \"xxxx\", \"z\", and \"yy\".\n\nA group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, \"xxxx\" has the interval [3,6].\n\nA group is considered large if it has 3 or more characters.\n\nReturn the intervals of every large group sorted in increasing order by start index.\n\n \n\nExample 1:\n\n\nInput: s = \"abbxxxxzzy\"\nOutput: [[3,6]]\nExplanation: \"xxxx\" is the only large group with start index 3 and end index 6.\n\n\nExample 2:\n\n\nInput: s = \"abc\"\nOutput: []\nExplanation: We have groups \"a\", \"b\", and \"c\", none of which are large groups.\n\n\nExample 3:\n\n\nInput: s = \"abcdddeeeeaabbbcd\"\nOutput: [[3,5],[6,9],[12,14]]\nExplanation: The large groups are \"ddd\", \"eeee\", and \"bbb\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s contains lowercase English letters only.",
      "code": "class Solution {\npublic:\n    vector<vector<int>> largeGroupPositions(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> largeGroupPositions(String S) {\n        List<List<Integer>> ans = new ArrayList();\n        int i = 0, N = S.length(); // i is the start of each group\n        for (int j = 0; j < N; ++j) {\n            if (j == N-1 || S.charAt(j) != S.charAt(j+1)) {\n                // Here, [i, j] represents a group.\n                if (j-i+1 >= 3)\n                    ans.add(Arrays.asList(new Integer[]{i, j}));\n                i = j + 1;\n            }\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 147,
      "question": "Can you solve this real interview question? Flipping an Image - Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\n\nTo flip an image horizontally means that each row of the image is reversed.\n\n * For example, flipping [1,1,0] horizontally results in [0,1,1].\n\nTo invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\n\n * For example, inverting [0,1,1] results in [1,0,0].\n\n \n\nExample 1:\n\n\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\nExplanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n\n\nExample 2:\n\n\nInput: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\nOutput: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\nExplanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n\n\n \n\nConstraints:\n\n * n == image.length\n * n == image[i].length\n * 1 <= n <= 20\n * images[i][j] is either 0 or 1.",
      "code": "class Solution {\npublic:\n    vector<vector<int>> flipAndInvertImage\n(vector<vector<int>>& image) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[][] flipAndInvertImage(int[][] A) {\n        int C = A[0].length;\n        for (int[] row: A)\n            for (int i = 0; i < (C + 1) / 2; ++i) {\n                int tmp = row[i] ^ 1;\n                row[i] = row[C - 1 - i] ^ 1;\n                row[C - 1 - i] = tmp;\n            }\n\n        return A;\n    }\n}"
      ]
    },
    {
      "number": 148,
      "question": "Can you solve this real interview question? Rectangle Overlap - An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\nTwo rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\nGiven two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\n \n\nExample 1:\n\nInput: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\nOutput: true\n\n\nExample 2:\n\nInput: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\nOutput: false\n\n\nExample 3:\n\nInput: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\nOutput: false\n\n\n \n\nConstraints:\n\n * rec1.length == 4\n * rec2.length == 4\n * -109 <= rec1[i], rec2[i] <= 109\n * rec1 and rec2 represent a valid rectangle with a non-zero area.",
      "code": "class Solution {\npublic:\n    bool isRectangleOverlap(vector<int>& rec1, vector<int>& \nrec2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        // check if either rectangle is actually a line\n        if (rec1[0] == rec1[2] || rec1[1] == rec1[3] ||\n            rec2[0] == rec2[2] || rec2[1] == rec2[3]) {\n            // the line cannot have positive overlap\n            return false;\n        }\n\n        return !(rec1[2] <= rec2[0] ||   // left\n                 rec1[3] <= rec2[1] ||   // bottom\n                 rec1[0] >= rec2[2] ||   // right\n                 rec1[1] >= rec2[3]);    // top\n    }\n}",
        "class Solution {\n    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {\n        return (Math.min(rec1[2], rec2[2]) > Math.max(rec1[0], rec2[0]) && // width > 0\n                Math.min(rec1[3], rec2[3]) > Math.max(rec1[1], rec2[1]));  // height > 0\n    }\n}"
      ]
    },
    {
      "number": 149,
      "question": "Can you solve this real interview question? New 21 Game - Alice plays the following game, loosely based on the card game \"21\".\n\nAlice starts with 0 points and draws numbers while she has less than k points. During each draw, she gains an integer number of points randomly from the range [1, maxPts], where maxPts is an integer. Each draw is independent and the outcomes have equal probabilities.\n\nAlice stops drawing numbers when she gets k or more points.\n\nReturn the probability that Alice has n or fewer points.\n\nAnswers within 10-5 of the actual answer are considered accepted.\n\n \n\nExample 1:\n\n\nInput: n = 10, k = 1, maxPts = 10\nOutput: 1.00000\nExplanation: Alice gets a single card, then stops.\n\n\nExample 2:\n\n\nInput: n = 6, k = 1, maxPts = 10\nOutput: 0.60000\nExplanation: Alice gets a single card, then stops.\nIn 6 out of 10 possibilities, she is at or below 6 points.\n\n\nExample 3:\n\n\nInput: n = 21, k = 17, maxPts = 10\nOutput: 0.73278\n\n\n \n\nConstraints:\n\n * 0 <= k <= n <= 104\n * 1 <= maxPts <= 104",
      "code": "class Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        vector<double> dp(n + 1);\n        dp[0] = 1;\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= maxPts; j++) {\n                if (i - j >= 0 && i - j < k) {\n                    dp[i] += dp[i - j] / maxPts;\n                }\n            }\n        }\n        return accumulate(dp.begin() + k, dp.end(), 0.0);\n    }\n};",
        "class Solution {\npublic:\n    double new21Game(int n, int k, int maxPts) {\n        vector<double> dp(n + 1);\n        dp[0] = 1;\n        double s = k > 0 ? 1 : 0;\n        for (int i = 1; i <= n; i++) {\n            dp[i] = s / maxPts;\n            if (i < k) {\n                s += dp[i];\n            }\n            if (i - maxPts >= 0 && i - maxPts < k) {\n                s -= dp[i - maxPts];\n            }\n        }\n        return accumulate(dp.begin() + k, dp.end(), 0.0);\n    }\n};"
      ]
    },
    {
      "number": 150,
      "question": "Can you solve this real interview question? Push Dominoes - There are n dominoes in a line, and we place each domino vertically upright. In the beginning, we simultaneously push some of the dominoes either to the left or to the right.\n\nAfter each second, each domino that is falling to the left pushes the adjacent domino on the left. Similarly, the dominoes falling to the right push their adjacent dominoes standing on the right.\n\nWhen a vertical domino has dominoes falling on it from both sides, it stays still due to the balance of the forces.\n\nFor the purposes of this question, we will consider that a falling domino expends no additional force to a falling or already fallen domino.\n\nYou are given a string dominoes representing the initial state where:\n\n * dominoes[i] = 'L', if the ith domino has been pushed to the left,\n * dominoes[i] = 'R', if the ith domino has been pushed to the right, and\n * dominoes[i] = '.', if the ith domino has not been pushed.\n\nReturn a string representing the final state.\n\n \n\nExample 1:\n\n\nInput: dominoes = \"RR.L\"\nOutput: \"RR.L\"\nExplanation: The first domino expends no additional force on the second domino.\n\n\nExample 2:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/18/domino.png]\n\n\nInput: dominoes = \".L.R...LR..L..\"\nOutput: \"LL.RR.LLRRLL..\"\n\n\n \n\nConstraints:\n\n * n == dominoes.length\n * 1 <= n <= 105\n * dominoes[i] is either 'L', 'R', or '.'.",
      "code": "class Solution {\npublic:\n    string pushDominoes(string dominoes) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String pushDominoes(String dominoes) {\n        int N = dominoes.length();\n        int[] indexes = new int[N+2];\n        char[] symbols = new char[N+2];\n        int len = 1;\n        indexes[0] = -1;\n        symbols[0] = 'L';\n\n        for (int i = 0; i < N; ++i)\n            if (dominoes.charAt(i) != '.') {\n                indexes[len] = i;\n                symbols[len++] = dominoes.charAt(i);\n            }\n\n        indexes[len] = N;\n        symbols[len++] = 'R';\n\n        char[] ans = dominoes.toCharArray();\n        for (int index = 0; index < len - 1; ++index) {\n            int i = indexes[index], j = indexes[index+1];\n            char x = symbols[index], y = symbols[index+1];\n            char write;\n            if (x == y) {\n                for (int k = i+1; k < j; ++k)\n                    ans[k] = x;\n            } else if (x > y) { // RL\n                for (int k = i+1; k < j; ++k)\n                    ans[k] = k-i == j-k ? '.' : k-i < j-k ? 'R' : 'L';\n            }\n        }\n\n        return String.valueOf(ans);\n    }\n}",
        "class Solution {\n    public String pushDominoes(String S) {\n        char[] A = S.toCharArray();\n        int N = A.length;\n        int[] forces = new int[N];\n\n        // Populate forces going from left to right\n        int force = 0;\n        for (int i = 0; i < N; ++i) {\n            if (A[i] == 'R') force = N;\n            else if (A[i] == 'L') force = 0;\n            else force = Math.max(force - 1, 0);\n            forces[i] += force;\n        }\n\n        // Populate forces going from right to left\n        force = 0;\n        for (int i = N-1; i >= 0; --i) {\n            if (A[i] == 'L') force = N;\n            else if (A[i] == 'R') force = 0;\n            else force = Math.max(force - 1, 0);\n            forces[i] -= force;\n        }\n\n        StringBuilder ans = new StringBuilder();\n        for (int f: forces)\n            ans.append(f > 0 ? 'R' : f < 0 ? 'L' : '.');\n        return ans.toString();\n    }\n}"
      ]
    },
    {
      "number": 151,
      "question": "Can you solve this real interview question? Magic Squares In Grid - A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.\n\nGiven a row x col grid of integers, how many 3 x 3 \"magic square\" subgrids are there?  (Each subgrid is contiguous).\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/09/11/magic_main.jpg]\n\n\nInput: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]\nOutput: 1\nExplanation: \nThe following subgrid is a 3 x 3 magic square:\n[https://assets.leetcode.com/uploads/2020/09/11/magic_valid.jpg]\nwhile this one is not:\n[https://assets.leetcode.com/uploads/2020/09/11/magic_invalid.jpg]\nIn total, there is only one magic square inside the given grid.\n\n\nExample 2:\n\n\nInput: grid = [[8]]\nOutput: 0\n\n\n \n\nConstraints:\n\n * row == grid.length\n * col == grid[i].length\n * 1 <= row, col <= 10\n * 0 <= grid[i][j] <= 15",
      "code": "class Solution {\npublic:\n    int numMagicSquaresInside(vector<vector<int>>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        int R = grid.length, C = grid[0].length;\n        int ans = 0;\n        for (int r = 0; r < R-2; ++r)\n            for (int c = 0; c < C-2; ++c) {\n                if (grid[r+1][c+1] != 5) continue;  // optional skip\n                if (magic(grid[r][c], grid[r][c+1], grid[r][c+2],\n                          grid[r+1][c], grid[r+1][c+1], grid[r+1][c+2],\n                          grid[r+2][c], grid[r+2][c+1], grid[r+2][c+2]))\n                    ans++;\n            }\n\n        return ans;\n    }\n\n    public boolean magic(int... vals) {\n        int[] count = new int[16];\n        for (int v: vals) count[v]++;\n        for (int v = 1; v <= 9; ++v)\n            if (count[v] != 1)\n                return false;\n\n        return (vals[0] + vals[1] + vals[2] == 15 &&\n                vals[3] + vals[4] + vals[5] == 15 &&\n                vals[6] + vals[7] + vals[8] == 15 &&\n                vals[0] + vals[3] + vals[6] == 15 &&\n                vals[1] + vals[4] + vals[7] == 15 &&\n                vals[2] + vals[5] + vals[8] == 15 &&\n                vals[0] + vals[4] + vals[8] == 15 &&\n                vals[2] + vals[4] + vals[6] == 15);\n    }\n}"
      ]
    },
    {
      "number": 152,
      "question": "Can you solve this real interview question? Keys and Rooms - There are n rooms labeled from 0 to n - 1 and all the rooms are locked except for room 0. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of distinct keys in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock the other rooms.\n\nGiven an array rooms where rooms[i] is the set of keys that you can obtain if you visited room i, return true if you can visit all the rooms, or false otherwise.\n\n \n\nExample 1:\n\n\nInput: rooms = [[1],[2],[3],[]]\nOutput: true\nExplanation: \nWe visit room 0 and pick up key 1.\nWe then visit room 1 and pick up key 2.\nWe then visit room 2 and pick up key 3.\nWe then visit room 3.\nSince we were able to visit every room, we return true.\n\n\nExample 2:\n\n\nInput: rooms = [[1,3],[3,0,1],[2],[0]]\nOutput: false\nExplanation: We can not enter room number 2 since the only key that unlocks it is in that room.\n\n\n \n\nConstraints:\n\n * n == rooms.length\n * 2 <= n <= 1000\n * 0 <= rooms[i].length <= 1000\n * 1 <= sum(rooms[i].length) <= 3000\n * 0 <= rooms[i][j] < n\n * All the values of rooms[i] are unique.",
      "code": "class Solution {\npublic:\n    bool canVisitAllRooms(vector<vector<int>>& rooms) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        boolean[] seen = new boolean[rooms.size()];\n        seen[0] = true;\n        Stack<Integer> stack = new Stack();\n        stack.push(0);\n\n        //At the beginning, we have a todo list \"stack\" of keys to use.\n        //'seen' represents at some point we have entered this room.\n        while (!stack.isEmpty()) { // While we have keys...\n            int node = stack.pop(); // Get the next key 'node'\n            for (int nei: rooms.get(node)) // For every key in room # 'node'...\n                if (!seen[nei]) { // ...that hasn't been used yet\n                    seen[nei] = true; // mark that we've entered the room\n                    stack.push(nei); // add the key to the todo list\n                }\n        }\n\n        for (boolean v: seen)  // if any room hasn't been visited, return false\n            if (!v) return false;\n        return true;\n    }\n}"
      ]
    },
    {
      "number": 153,
      "question": "Can you solve this real interview question? Split Array into Fibonacci Sequence - You are given a string of digits num, such as \"123456579\". We can split it into a Fibonacci-like sequence [123, 456, 579].\n\nFormally, a Fibonacci-like sequence is a list f of non-negative integers such that:\n\n * 0 <= f[i] < 231, (that is, each integer fits in a 32-bit signed integer type),\n * f.length >= 3, and\n * f[i] + f[i + 1] == f[i + 2] for all 0 <= i < f.length - 2.\n\nNote that when splitting the string into pieces, each piece must not have extra leading zeroes, except if the piece is the number 0 itself.\n\nReturn any Fibonacci-like sequence split from num, or return [] if it cannot be done.\n\n \n\nExample 1:\n\n\nInput: num = \"1101111\"\nOutput: [11,0,11,11]\nExplanation: The output [110, 1, 111] would also be accepted.\n\n\nExample 2:\n\n\nInput: num = \"112358130\"\nOutput: []\nExplanation: The task is impossible.\n\n\nExample 3:\n\n\nInput: num = \"0123\"\nOutput: []\nExplanation: Leading zeroes are not allowed, so \"01\", \"2\", \"3\" is not valid.\n\n\n \n\nConstraints:\n\n * 1 <= num.length <= 200\n * num contains only digits.",
      "code": "class Solution {\npublic:\n    vector<int> splitIntoFibonacci(string num) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<Integer> splitIntoFibonacci(String S) {\n        int N = S.length();\n        for (int i = 0; i < Math.min(10, N); ++i) {\n            if (S.charAt(0) == '0' && i > 0) break;\n            long a = Long.valueOf(S.substring(0, i+1));\n            if (a >= Integer.MAX_VALUE) break;\n\n            search: for (int j = i+1; j < Math.min(i+10, N); ++j) {\n                if (S.charAt(i+1) == '0' && j > i+1) break;\n                long b = Long.valueOf(S.substring(i+1, j+1));\n                if (b >= Integer.MAX_VALUE) break;\n\n                List<Integer> fib = new ArrayList();\n                fib.add((int) a);\n                fib.add((int) b);\n\n                int k = j + 1;\n                while (k < N) {\n                    long nxt = fib.get(fib.size() - 2) + fib.get(fib.size() - 1);\n                    String nxtS = String.valueOf(nxt);\n\n                    if (nxt <= Integer.MAX_VALUE && S.substring(k).startsWith(nxtS)) {\n                        k += nxtS.length();\n                        fib.add((int) nxt);\n                    }\n                    else continue search;\n                }\n                if (fib.size() >= 3) return fib;\n            }\n        }\n\n        return new ArrayList<Integer>();\n    }\n}"
      ]
    },
    {
      "number": 154,
      "question": "Can you solve this real interview question? Backspace String Compare - Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\nNote that after backspacing an empty text, the text will continue empty.\n\n \n\nExample 1:\n\n\nInput: s = \"ab#c\", t = \"ad#c\"\nOutput: true\nExplanation: Both s and t become \"ac\".\n\n\nExample 2:\n\n\nInput: s = \"ab##\", t = \"c#d#\"\nOutput: true\nExplanation: Both s and t become \"\".\n\n\nExample 3:\n\n\nInput: s = \"a#c\", t = \"b\"\nOutput: false\nExplanation: s becomes \"c\" while t becomes \"b\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length, t.length <= 200\n * s and t only contain lowercase letters and '#' characters.\n\n \n\nFollow up: Can you solve it in O(n) time and O(1) space?",
      "code": "class Solution {\npublic:\n    bool backspaceCompare(string s, string t) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean backspaceCompare(String S, String T) {\n        return build(S).equals(build(T));\n    }\n\n    public String build(String S) {\n        Stack<Character> ans = new Stack();\n        for (char c: S.toCharArray()) {\n            if (c != '#')\n                ans.push(c);\n            else if (!ans.empty())\n                ans.pop();\n        }\n        return String.valueOf(ans);\n    }\n}",
        "class Solution {\n    public boolean backspaceCompare(String S, String T) {\n        int i = S.length() - 1, j = T.length() - 1;\n        int skipS = 0, skipT = 0;\n\n        while (i >= 0 || j >= 0) { // While there may be chars in build(S) or build (T)\n            while (i >= 0) { // Find position of next possible char in build(S)\n                if (S.charAt(i) == '#') {skipS++; i--;}\n                else if (skipS > 0) {skipS--; i--;}\n                else break;\n            }\n            while (j >= 0) { // Find position of next possible char in build(T)\n                if (T.charAt(j) == '#') {skipT++; j--;}\n                else if (skipT > 0) {skipT--; j--;}\n                else break;\n            }\n            // If two actual characters are different\n            if (i >= 0 && j >= 0 && S.charAt(i) != T.charAt(j))\n                return false;\n            // If expecting to compare char vs nothing\n            if ((i >= 0) != (j >= 0))\n                return false;\n            i--; j--;\n        }\n        return true;\n    }\n}"
      ]
    },
    {
      "number": 155,
      "question": "Can you solve this real interview question? Longest Mountain in Array - You may recall that an array arr is a mountain array if and only if:\n\n * arr.length >= 3\n * There exists some index i (0-indexed) with 0 < i < arr.length - 1 such that:\n   * arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n   * arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\nGiven an integer array arr, return the length of the longest subarray, which is a mountain. Return 0 if there is no mountain subarray.\n\n \n\nExample 1:\n\n\nInput: arr = [2,1,4,7,3,2,5]\nOutput: 5\nExplanation: The largest mountain is [1,4,7,3,2] which has length 5.\n\n\nExample 2:\n\n\nInput: arr = [2,2,2]\nOutput: 0\nExplanation: There is no mountain.\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 104\n * 0 <= arr[i] <= 104\n\n \n\nFollow up:\n\n * Can you solve it using only one pass?\n * Can you solve it in O(1) space?",
      "code": "class Solution {\npublic:\n    int longestMountain(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int longestMountain(int[] A) {\n        int N = A.length;\n        int ans = 0, base = 0;\n        while (base < N) {\n            int end = base;\n            // if base is a left-boundary\n            if (end + 1 < N && A[end] < A[end + 1]) {\n                // set end to the peak of this potential mountain\n                while (end + 1 < N && A[end] < A[end + 1]) end++;\n\n                // if end is really a peak..\n                if (end + 1 < N && A[end] > A[end + 1]) {\n                    // set end to the right-boundary of mountain\n                    while (end + 1 < N && A[end] > A[end + 1]) end++;\n                    // record candidate answer\n                    ans = Math.max(ans, end - base + 1);\n                }\n            }\n\n            base = Math.max(end, base + 1);\n        }\n\n        return ans;\n    }\n}\n"
      ]
    },
    {
      "number": 156,
      "question": "Can you solve this real interview question? Shifting Letters - You are given a string s of lowercase English letters and an integer array shifts of the same length.\n\nCall the shift() of a letter, the next letter in the alphabet, (wrapping around so that 'z' becomes 'a').\n\n * For example, shift('a') = 'b', shift('t') = 'u', and shift('z') = 'a'.\n\nNow for each shifts[i] = x, we want to shift the first i + 1 letters of s, x times.\n\nReturn the final string after all such shifts to s are applied.\n\n \n\nExample 1:\n\n\nInput: s = \"abc\", shifts = [3,5,9]\nOutput: \"rpl\"\nExplanation: We start with \"abc\".\nAfter shifting the first 1 letters of s by 3, we have \"dbc\".\nAfter shifting the first 2 letters of s by 5, we have \"igc\".\nAfter shifting the first 3 letters of s by 9, we have \"rpl\", the answer.\n\n\nExample 2:\n\n\nInput: s = \"aaa\", shifts = [1,2,3]\nOutput: \"gfd\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s consists of lowercase English letters.\n * shifts.length == s.length\n * 0 <= shifts[i] <= 109",
      "code": "class Solution {\npublic:\n    string shiftingLetters(string s, vector<int>& shifts) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String shiftingLetters(String S, int[] shifts) {\n        StringBuilder ans = new StringBuilder();\n        int X = 0;\n        for (int shift: shifts)\n            X = (X + shift) % 26;\n\n        for (int i = 0; i < S.length(); ++i) {\n            int index = S.charAt(i) - 'a';\n            ans.append((char) ((index + X) % 26 + 97));\n            X = Math.floorMod(X - shifts[i], 26);\n        }\n\n        return ans.toString();\n    }\n}"
      ]
    },
    {
      "number": 157,
      "question": "Can you solve this real interview question? Maximize Distance to Closest Person - You are given an array representing a row of seats where seats[i] = 1 represents a person sitting in the ith seat, and seats[i] = 0 represents that the ith seat is empty (0-indexed).\n\nThere is at least one empty seat, and at least one person sitting.\n\nAlex wants to sit in the seat such that the distance between him and the closest person to him is maximized. \n\nReturn that maximum distance to the closest person.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/09/10/distance.jpg]\n\n\nInput: seats = [1,0,0,0,1,0,1]\nOutput: 2\nExplanation: \nIf Alex sits in the second open seat (i.e. seats[2]), then the closest person has distance 2.\nIf Alex sits in any other open seat, the closest person has distance 1.\nThus, the maximum distance to the closest person is 2.\n\n\nExample 2:\n\n\nInput: seats = [1,0,0,0]\nOutput: 3\nExplanation: \nIf Alex sits in the last seat (i.e. seats[3]), the closest person is 3 seats away.\nThis is the maximum distance possible, so the answer is 3.\n\n\nExample 3:\n\n\nInput: seats = [0,1]\nOutput: 1\n\n\n \n\nConstraints:\n\n * 2 <= seats.length <= 2 * 104\n * seats[i] is 0 or 1.\n * At least one seat is empty.\n * At least one seat is occupied.",
      "code": "class Solution {\npublic:\n    int maxDistToClosest(vector<int>& seats) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int N = seats.length;\n        int[] left = new int[N], right = new int[N];\n        Arrays.fill(left, N);\n        Arrays.fill(right, N);\n\n        for (int i = 0; i < N; ++i) {\n            if (seats[i] == 1) left[i] = 0;\n            else if (i > 0) left[i] = left[i-1] + 1;\n        }\n\n        for (int i = N-1; i >= 0; --i) {\n            if (seats[i] == 1) right[i] = 0;\n            else if (i < N-1) right[i] = right[i+1] + 1;\n        }\n\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            if (seats[i] == 0)\n                ans = Math.max(ans, Math.min(left[i], right[i]));\n        return ans;\n    }\n}\n",
        "class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int N = seats.length;\n        int prev = -1, future = 0;\n        int ans = 0;\n\n        for (int i = 0; i < N; ++i) {\n            if (seats[i] == 1) {\n                prev = i;\n            } else {\n                while (future < N && seats[future] == 0 || future < i)\n                    future++;\n\n                int left = prev == -1 ? N : i - prev;\n                int right = future == N ? N : future - i;\n                ans = Math.max(ans, Math.min(left, right));\n            }\n        }\n\n        return ans;\n    }\n}",
        "class Solution {\n    public int maxDistToClosest(int[] seats) {\n        int N = seats.length;\n        int K = 0; //current longest group of empty seats\n        int ans = 0;\n\n        for (int i = 0; i < N; ++i) {\n            if (seats[i] == 1) {\n                K = 0;\n            } else {\n                K++;\n                ans = Math.max(ans, (K + 1) / 2);\n            }\n        }\n\n        for (int i = 0; i < N; ++i)  if (seats[i] == 1) {\n            ans = Math.max(ans, i);\n            break;\n        }\n\n        for (int i = N-1; i >= 0; --i)  if (seats[i] == 1) {\n            ans = Math.max(ans, N - 1 - i);\n            break;\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 158,
      "question": "Can you solve this real interview question? Rectangle Area II - You are given a 2D array of axis-aligned rectangles. Each rectangle[i] = [xi1, yi1, xi2, yi2] denotes the ith rectangle where (xi1, yi1) are the coordinates of the bottom-left corner, and (xi2, yi2) are the coordinates of the top-right corner.\n\nCalculate the total area covered by all rectangles in the plane. Any area covered by two or more rectangles should only be counted once.\n\nReturn the total area. Since the answer may be too large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/06/rectangle_area_ii_pic.png]\n\n\nInput: rectangles = [[0,0,2,2],[1,0,2,3],[1,0,3,1]]\nOutput: 6\nExplanation: A total area of 6 is covered by all three rectangles, as illustrated in the picture.\nFrom (1,1) to (2,2), the green and red rectangles overlap.\nFrom (1,0) to (2,3), all three rectangles overlap.\n\n\nExample 2:\n\n\nInput: rectangles = [[0,0,1000000000,1000000000]]\nOutput: 49\nExplanation: The answer is 1018 modulo (109 + 7), which is 49.\n\n\n \n\nConstraints:\n\n * 1 <= rectangles.length <= 200\n * rectanges[i].length == 4\n * 0 <= xi1, yi1, xi2, yi2 <= 109\n * xi1 <= xi2\n * yi1 <= yi2",
      "code": "class Solution {\npublic:\n    int rectangleArea(vector<vector<int>>& rectangles) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int N = rectangles.length;\n        Set<Integer> Xvals = new HashSet();\n        Set<Integer> Yvals = new HashSet();\n\n        for (int[] rec: rectangles) {\n            Xvals.add(rec[0]);\n            Xvals.add(rec[2]);\n            Yvals.add(rec[1]);\n            Yvals.add(rec[3]);\n        }\n\n        Integer[] imapx = Xvals.toArray(new Integer[0]);\n        Arrays.sort(imapx);\n        Integer[] imapy = Yvals.toArray(new Integer[0]);\n        Arrays.sort(imapy);\n\n        Map<Integer, Integer> mapx = new HashMap();\n        Map<Integer, Integer> mapy = new HashMap();\n        for (int i = 0; i < imapx.length; ++i)\n            mapx.put(imapx[i], i);\n        for (int i = 0; i < imapy.length; ++i)\n            mapy.put(imapy[i], i);\n\n        boolean[][] grid = new boolean[imapx.length][imapy.length];\n        for (int[] rec: rectangles)\n            for (int x = mapx.get(rec[0]); x < mapx.get(rec[2]); ++x)\n                for (int y = mapy.get(rec[1]); y < mapy.get(rec[3]); ++y)\n                    grid[x][y] = true;\n\n        long ans = 0;\n        for (int x = 0; x < grid.length; ++x)\n            for (int y = 0; y < grid[0].length; ++y)\n                if (grid[x][y])\n                    ans += (long) (imapx[x+1] - imapx[x]) * (imapy[y+1] - imapy[y]);\n\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}",
        "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int OPEN = 0, CLOSE = 1;\n        int[][] events = new int[rectangles.length * 2][];\n        int t = 0;\n        for (int[] rec: rectangles) {\n            events[t++] = new int[]{rec[1], OPEN, rec[0], rec[2]};\n            events[t++] = new int[]{rec[3], CLOSE, rec[0], rec[2]};\n        }\n\n        Arrays.sort(events, (a, b) -> Integer.compare(a[0], b[0]));\n\n        List<int[]> active = new ArrayList();\n        int cur_y = events[0][0];\n        long ans = 0;\n        for (int[] event: events) {\n            int y = event[0], typ = event[1], x1 = event[2], x2 = event[3];\n\n            // Calculate query\n            long query = 0;\n            int cur = -1;\n            for (int[] xs: active) {\n                cur = Math.max(cur, xs[0]);\n                query += Math.max(xs[1] - cur, 0);\n                cur = Math.max(cur, xs[1]);\n            }\n\n            ans += query * (y - cur_y);\n\n            if (typ == OPEN) {\n                active.add(new int[]{x1, x2});\n                Collections.sort(active, (a, b) -> Integer.compare(a[0], b[0]));\n            } else {\n                for (int i = 0; i < active.size(); ++i)\n                    if (active.get(i)[0] == x1 && active.get(i)[1] == x2) {\n                        active.remove(i);\n                        break;\n                    }\n            }\n\n            cur_y = y;\n        }\n\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}",
        "class Solution {\n    public int rectangleArea(int[][] rectangles) {\n        int OPEN = 1, CLOSE = -1;\n        int[][] events = new int[rectangles.length * 2][];\n        Set<Integer> Xvals = new HashSet();\n        int t = 0;\n        \n        for (int[] rec: rectangles) {\n            if ((rec[0] < rec[2]) && (rec[1] < rec[3])) {\n                events[t++] = new int[]{rec[1], OPEN, rec[0], rec[2]};\n                events[t++] = new int[]{rec[3], CLOSE, rec[0], rec[2]};\n                Xvals.add(rec[0]);\n                Xvals.add(rec[2]);\n            }\n        }\n\n        Arrays.sort(events, 0, t, (a, b) -> Integer.compare(a[0], b[0]));\n\n        Integer[] X = Xvals.toArray(new Integer[0]);\n        Arrays.sort(X);\n        Map<Integer, Integer> Xi = new HashMap();\n        for (int i = 0; i < X.length; ++i)\n            Xi.put(X[i], i);\n\n        Node active = new Node(0, X.length - 1, X);\n        long ans = 0;\n        long cur_x_sum = 0;\n        int cur_y = events[0][0];\n        \n        for (int[] event: events) {\n            if (event == null) break;\n            int y = event[0], typ = event[1], x1 = event[2], x2 = event[3];\n            ans += cur_x_sum * (y - cur_y);\n            cur_x_sum = active.update(Xi.get(x1), Xi.get(x2), typ);\n            cur_y = y;\n        }\n\n        ans %= 1_000_000_007;\n        return (int) ans;\n    }\n}\n\nclass Node {\n    int start, end;\n    Integer[] X;\n    Node left, right;\n    int count;\n    long total;\n\n    public Node(int start, int end, Integer[] X) {\n        this.start = start;\n        this.end = end;\n        this.X = X;\n        left = null;\n        right = null;\n        count = 0;\n        total = 0;\n    }\n\n    public int getRangeMid() {\n        return start + (end - start) / 2;\n    }\n\n    public Node getLeft() {\n        if (left == null) left = new Node(start, getRangeMid(), X);\n        return left;\n    }\n\n    public Node getRight() {\n        if (right == null) right = new Node(getRangeMid(), end, X);\n        return right;\n    }\n\n    public long update(int i, int j, int val) {\n        if (i >= j) return 0;\n        if (start == i && end == j) {\n            count += val;\n        } else {\n            getLeft().update(i, Math.min(getRangeMid(), j), val);\n            getRight().update(Math.max(getRangeMid(), i), j, val);\n        }\n\n        if (count > 0) total = X[end] - X[start];\n        else total = getLeft().total + getRight().total;\n\n        return total;\n    }\n}"
      ]
    },
    {
      "number": 159,
      "question": "Can you solve this real interview question? Loud and Rich - There is a group of n people labeled from 0 to n - 1 where each person has a different amount of money and a different level of quietness.\n\nYou are given an array richer where richer[i] = [ai, bi] indicates that ai has more money than bi and an integer array quiet where quiet[i] is the quietness of the ith person. All the given data in richer are logically correct (i.e., the data will not lead you to a situation where x is richer than y and y is richer than x at the same time).\n\nReturn an integer array answer where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]) among all people who definitely have equal to or more money than the person x.\n\n \n\nExample 1:\n\n\nInput: richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]\nOutput: [5,5,2,5,4,5,6,7]\nExplanation: \nanswer[0] = 5.\nPerson 5 has more money than 3, which has more money than 1, which has more money than 0.\nThe only person who is quieter (has lower quiet[x]) is person 7, but it is not clear if they have more money than person 0.\nanswer[7] = 7.\nAmong all people that definitely have equal to or more money than person 7 (which could be persons 3, 4, 5, 6, or 7), the person who is the quietest (has lower quiet[x]) is person 7.\nThe other answers can be filled out with similar reasoning.\n\n\nExample 2:\n\n\nInput: richer = [], quiet = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * n == quiet.length\n * 1 <= n <= 500\n * 0 <= quiet[i] < n\n * All the values of quiet are unique.\n * 0 <= richer.length <= n * (n - 1) / 2\n * 0 <= ai, bi < n\n * ai != bi\n * All the pairs of richer are unique.\n * The observations in richer are all logically consistent.",
      "code": "class Solution {\npublic:\n    vector<int> loudAndRich(vector<vector<int>>& richer, \nvector<int>& quiet) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    ArrayList<Integer>[] graph;\n    int[] answer;\n    int[] quiet;\n\n    public int[] loudAndRich(int[][] richer, int[] quiet) {\n        int N = quiet.length;\n        graph = new ArrayList[N];\n        answer = new int[N];\n        this.quiet = quiet;\n\n        for (int node = 0; node < N; ++node)\n            graph[node] = new ArrayList<Integer>();\n\n        for (int[] edge: richer)\n            graph[edge[1]].add(edge[0]);\n\n        Arrays.fill(answer, -1);\n\n        for (int node = 0; node < N; ++node)\n            dfs(node);\n        return answer;\n    }\n\n    public int dfs(int node) {\n        if (answer[node] == -1) {\n            answer[node] = node;\n            for (int child: graph[node]) {\n                int cand = dfs(child);\n                if (quiet[cand] < quiet[answer[node]])\n                    answer[node] = cand;\n            }\n        }\n        return answer[node];\n    }\n}"
      ]
    },
    {
      "number": 160,
      "question": "Can you solve this real interview question? Peak Index in a Mountain Array - An array arr is a mountain if the following properties hold:\n\n * arr.length >= 3\n * There exists some i with 0 < i < arr.length - 1 such that:\n   * arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n   * arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\nGiven a mountain array arr, return the index i such that arr[0] < arr[1] < ... < arr[i - 1] < arr[i] > arr[i + 1] > ... > arr[arr.length - 1].\n\nYou must solve it in O(log(arr.length)) time complexity.\n\n \n\nExample 1:\n\n\nInput: arr = [0,1,0]\nOutput: 1\n\n\nExample 2:\n\n\nInput: arr = [0,2,1,0]\nOutput: 1\n\n\nExample 3:\n\n\nInput: arr = [0,10,5,2]\nOutput: 1\n\n\n \n\nConstraints:\n\n * 3 <= arr.length <= 105\n * 0 <= arr[i] <= 106\n * arr is guaranteed to be a mountain array.",
      "code": "class Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n        int i = 0;\n        while (arr[i] < arr[i + 1]) {\n            i++;\n        }\n        return i;\n    }\n};",
        "class Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n        int l = 0, r = arr.size() - 1, mid;\n        while (l < r) {\n            mid = (l + r) / 2;\n            if (arr[mid] < arr[mid + 1])\n                l = mid + 1;\n            else\n                r = mid;\n        }\n        return l;\n    }\n};\n"
      ]
    },
    {
      "number": 161,
      "question": "Can you solve this real interview question? Minimum Cost to Hire K Workers - There are n workers. You are given two integer arrays quality and wage where quality[i] is the quality of the ith worker and wage[i] is the minimum wage expectation for the ith worker.\n\nWe want to hire exactly k workers to form a paid group. To hire a group of k workers, we must pay them according to the following rules:\n\n 1. Every worker in the paid group should be paid in the ratio of their quality compared to other workers in the paid group.\n 2. Every worker in the paid group must be paid at least their minimum wage expectation.\n\nGiven the integer k, return the least amount of money needed to form a paid group satisfying the above conditions. Answers within 10-5 of the actual answer will be accepted.\n\n \n\nExample 1:\n\n\nInput: quality = [10,20,5], wage = [70,50,30], k = 2\nOutput: 105.00000\nExplanation: We pay 70 to 0th worker and 35 to 2nd worker.\n\n\nExample 2:\n\n\nInput: quality = [3,1,10,10,1], wage = [4,8,2,2,7], k = 3\nOutput: 30.66667\nExplanation: We pay 4 to 0th worker, 13.33333 to 2nd and 3rd workers separately.\n\n\n \n\nConstraints:\n\n * n == quality.length == wage.length\n * 1 <= k <= n <= 104\n * 1 <= quality[i], wage[i] <= 104",
      "code": "class Solution {\npublic:\n    double mincostToHireWorkers(vector<int>& quality, \nvector<int>& wage, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n        int N = quality.length;\n        double ans = 1e9;\n\n        for (int captain = 0; captain < N; ++captain) {\n            // Must pay at least wage[captain] / quality[captain] per qual\n            double factor = (double) wage[captain] / quality[captain];\n            double prices[] = new double[N];\n            int t = 0;\n            for (int worker = 0; worker < N; ++worker) {\n                double price = factor * quality[worker];\n                if (price < wage[worker]) continue;\n                prices[t++] = price;\n            }\n\n            if (t < K) continue;\n            Arrays.sort(prices, 0, t);\n            double cand = 0;\n            for (int i = 0; i < K; ++i)\n                cand += prices[i];\n            ans = Math.min(ans, cand);\n        }\n\n        return ans;\n    }\n}",
        "class Solution {\n    public double mincostToHireWorkers(int[] quality, int[] wage, int K) {\n        int N = quality.length;\n        Worker[] workers = new Worker[N];\n        for (int i = 0; i < N; ++i)\n            workers[i] = new Worker(quality[i], wage[i]);\n        Arrays.sort(workers);\n\n        double ans = 1e9;\n        int sumq = 0;\n        PriorityQueue<Integer> pool = new PriorityQueue();\n        for (Worker worker: workers) {\n            pool.offer(-worker.quality);\n            sumq += worker.quality;\n            if (pool.size() > K)\n                sumq += pool.poll();\n            if (pool.size() == K)\n                ans = Math.min(ans, sumq * worker.ratio());\n        }\n\n        return ans;\n    }\n}\n\nclass Worker implements Comparable<Worker> {\n    public int quality, wage;\n    public Worker(int q, int w) {\n        quality = q;\n        wage = w;\n    }\n\n    public double ratio() {\n        return (double) wage / quality;\n    }\n\n    public int compareTo(Worker other) {\n        return Double.compare(ratio(), other.ratio());\n    }\n}"
      ]
    },
    {
      "number": 162,
      "question": "Can you solve this real interview question? Lemonade Change - At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to buy from you and order one at a time (in the order specified by bills). Each customer will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must provide the correct change to each customer so that the net transaction is that the customer pays $5.\n\nNote that you do not have any change in hand at first.\n\nGiven an integer array bills where bills[i] is the bill the ith customer pays, return true if you can provide every customer with the correct change, or false otherwise.\n\n \n\nExample 1:\n\n\nInput: bills = [5,5,5,10,20]\nOutput: true\nExplanation: \nFrom the first 3 customers, we collect three $5 bills in order.\nFrom the fourth customer, we collect a $10 bill and give back a $5.\nFrom the fifth customer, we give a $10 bill and a $5 bill.\nSince all customers got correct change, we output true.\n\n\nExample 2:\n\n\nInput: bills = [5,5,10,10,20]\nOutput: false\nExplanation: \nFrom the first two customers in order, we collect two $5 bills.\nFor the next two customers in order, we collect a $10 bill and give back a $5 bill.\nFor the last customer, we can not give the change of $15 back because we only have two $10 bills.\nSince not every customer received the correct change, the answer is false.\n\n\n \n\nConstraints:\n\n * 1 <= bills.length <= 105\n * bills[i] is either 5, 10, or 20.",
      "code": "class Solution {\npublic:\n    bool lemonadeChange(vector<int>& bills) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean lemonadeChange(int[] bills) {\n        int five = 0, ten = 0;\n        for (int bill: bills) {\n            if (bill == 5)\n                five++;\n            else if (bill == 10) {\n                if (five == 0) return false;\n                five--;\n                ten++;\n            } else {\n                if (five > 0 && ten > 0) {\n                    five--;\n                    ten--;\n                } else if (five >= 3) {\n                    five -= 3;\n                } else {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n}"
      ]
    },
    {
      "number": 163,
      "question": "Can you solve this real interview question? Score After Flipping Matrix - You are given an m x n binary matrix grid.\n\nA move consists of choosing any row or column and toggling each value in that row or column (i.e., changing all 0's to 1's, and all 1's to 0's).\n\nEvery row of the matrix is interpreted as a binary number, and the score of the matrix is the sum of these numbers.\n\nReturn the highest possible score after making any number of moves (including zero moves).\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/07/23/lc-toogle1.jpg]\n\n\nInput: grid = [[0,0,1,1],[1,0,1,0],[1,1,0,0]]\nOutput: 39\nExplanation: 0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39\n\n\nExample 2:\n\n\nInput: grid = [[0]]\nOutput: 1\n\n\n \n\nConstraints:\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 20\n * grid[i][j] is either 0 or 1.",
      "code": "class Solution {\npublic:\n    int matrixScore(vector<vector<int>>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int matrixScore(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[] colsums = new int[C];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c)\n                colsums[c] += A[r][c];\n\n        int ans = 0;\n        for (int state = 0; state < (1<<R); ++state) {\n            // Toggle the rows so that after, 'state' represents\n            // the toggled rows.\n            if (state > 0) {\n                int trans = state ^ (state-1);\n                for (int r = 0; r < R; ++r) {\n                    if (((trans >> r) & 1) > 0) {\n                        for (int c = 0; c < C; ++c) {\n                            colsums[c] += A[r][c] == 1 ? -1 : 1;\n                            A[r][c] ^= 1;\n                        }\n                    }\n                }\n            }\n\n            // Calculate the score with the rows toggled by 'state'\n            int score = 0;\n            for (int c = 0; c < C; ++c)\n                score += Math.max(colsums[c], R - colsums[c]) * (1 << (C-1-c));\n            ans = Math.max(ans, score);\n        }\n\n        return ans;\n    }\n}",
        "class Solution {\n    public int matrixScore(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int ans = 0;\n        for (int c = 0; c < C; ++c) {\n            int col = 0;\n            for (int r = 0; r < R; ++r)\n                col += A[r][c] ^ A[r][0];\n            ans += Math.max(col, R - col) * (1 << (C-1-c));\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 164,
      "question": "Can you solve this real interview question? Shortest Subarray with Sum at Least K - Given an integer array nums and an integer k, return the length of the shortest non-empty subarray of nums with a sum of at least k. If there is no such subarray, return -1.\n\nA subarray is a contiguous part of an array.\n\n \n\nExample 1:\n\nInput: nums = [1], k = 1\nOutput: 1\n\n\nExample 2:\n\nInput: nums = [1,2], k = 4\nOutput: -1\n\n\nExample 3:\n\nInput: nums = [2,-1,2], k = 3\nOutput: 3\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * -105 <= nums[i] <= 105\n * 1 <= k <= 109",
      "code": "class Solution {\npublic:\n    int shortestSubarray(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int shortestSubarray(int[] A, int K) {\n        int N = A.length;\n        long[] P = new long[N+1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + (long) A[i];\n\n        // Want smallest y-x with P[y] - P[x] >= K\n        int ans = N+1; // N+1 is impossible\n        Deque<Integer> monoq = new LinkedList(); //opt(y) candidates, as indices of P\n\n        for (int y = 0; y < P.length; ++y) {\n            // Want opt(y) = largest x with P[x] <= P[y] - K;\n            while (!monoq.isEmpty() && P[y] <= P[monoq.getLast()])\n                monoq.removeLast();\n            while (!monoq.isEmpty() && P[y] >= P[monoq.getFirst()] + K)\n                ans = Math.min(ans, y - monoq.removeFirst());\n\n            monoq.addLast(y);\n        }\n\n        return ans < N+1 ? ans : -1;\n    }\n}"
      ]
    },
    {
      "number": 165,
      "question": "Can you solve this real interview question? Shortest Path to Get All Keys - You are given an m x n grid grid where:\n\n * '.' is an empty cell.\n * '#' is a wall.\n * '@' is the starting point.\n * Lowercase letters represent keys.\n * Uppercase letters represent locks.\n\nYou start at the starting point and one move consists of walking one space in one of the four cardinal directions. You cannot walk outside the grid, or walk into a wall.\n\nIf you walk over a key, you can pick it up and you cannot walk over a lock unless you have its corresponding key.\n\nFor some 1 <= k <= 6, there is exactly one lowercase and one uppercase letter of the first k letters of the English alphabet in the grid. This means that there is exactly one key for each lock, and one lock for each key; and also that the letters used to represent the keys and locks were chosen in the same order as the English alphabet.\n\nReturn the lowest number of moves to acquire all keys. If it is impossible, return -1.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/07/23/lc-keys2.jpg]\n\n\nInput: grid = [\"@.a..\",\"###.#\",\"b.A.B\"]\nOutput: 8\nExplanation: Note that the goal is to obtain all the keys not to open all the locks.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/07/23/lc-key2.jpg]\n\n\nInput: grid = [\"@..aA\",\"..B#.\",\"....b\"]\nOutput: 6\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2021/07/23/lc-keys3.jpg]\n\n\nInput: grid = [\"@Aa\"]\nOutput: -1\n\n\n \n\nConstraints:\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 30\n * grid[i][j] is either an English letter, '.', '#', or '@'. \n * There is exactly one '@' in the grid.\n * The number of keys in the grid is in the range [1, 6].\n * Each key in the grid is unique.\n * Each key in the grid has a matching lock.",
      "code": "class Solution {\npublic:\n    int shortestPathAllKeys(vector<string>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int shortestPathAllKeys(String[] grid) {\n        int m = grid.length, n = grid[0].length();\n        Queue<int[]> queue = new LinkedList<>();\n        int[][] moves = new int[][] {{0, 1}, {1, 0}, {-1, 0}, {0, -1}};\n        \n        // seen['key'] is only for BFS with key state equals 'keys'\n        Map<Integer, Set<Pair<Integer, Integer>>> seen = new HashMap<>();\n        \n        Set<Character> keySet = new HashSet<>();\n        Set<Character> lockSet = new HashSet<>();\n        int allKeys = 0;\n        int startR = -1, startC = -1;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                char cell = grid[i].charAt(j);\n                if (cell >= 'a' && cell <= 'f') {\n                    allKeys += (1 << (cell - 'a'));\n                    keySet.add(cell);\n                }\n                if (cell >= 'A' && cell <= 'F') {\n                    lockSet.add(cell);\n                }\n                if (cell == '@') {\n                    startR = i;\n                    startC = j;\n                }\n            }\n        }\n\n        // [row, column, key state, distance]\n        queue.offer(new int[] {startR, startC, 0, 0});\n        seen.put(0, new HashSet<>());\n        seen.get(0).add(new Pair<>(startR, startC));    \n        \n        while (!queue.isEmpty()) {\n            int[] cur = queue.poll();\n            int curR = cur[0], curC = cur[1], keys = cur[2], dist = cur[3];\n            for (int[] move : moves) {\n                int newR = curR + move[0], newC = curC + move[1];\n                \n                // If this cell (newR, newC) is reachable.\n                if (newR >= 0 && newR < m && newC >= 0 && newC < n && grid[newR].charAt(newC) != '#') {\n                    char cell = grid[newR].charAt(newC);\n                    \n                    // If it is a key:\n                    if (keySet.contains(cell)) {\n                        // If we have collected it before, no need to revisit this cell.\n                        if (((1 << (cell - 'a')) & keys) != 0) {\n                            continue;\n                        }\n                        \n                        // Otherwise, we can walk to this cell and pick it up.\n                        int newKeys = (keys | (1 << (cell - 'a')));\n                        \n                        // If we collect all keys, return dist + 1. \n                        // Otherwise, just add this state to seen and queue.\n                        if (newKeys == allKeys) {\n                            return dist + 1;\n                        }\n                        seen.putIfAbsent(newKeys, new HashSet<>());\n                        seen.get(newKeys).add(new Pair<>(newR, newC));\n                        queue.offer(new int[] {newR, newC, newKeys, dist + 1});\n                    }\n                    \n                    // If it is a lock and we don't have its key, continue.\n                    if (lockSet.contains(cell) && ((keys & (1 << (cell - 'A'))) == 0)) {\n                        continue;\n                    }\n                        \n                    // We can walk to this cell if we haven't been here before with the same key state.\n                    else if (!seen.get(keys).contains(new Pair<>(newR, newC))) {\n                        seen.get(keys).add(new Pair<>(newR, newC));\n                        queue.offer(new int[] {newR, newC, keys, dist + 1});\n                    }\n                }\n            }\n        }\n        \n        return -1;\n    }\n}"
      ]
    },
    {
      "number": 166,
      "question": "Can you solve this real interview question? Smallest Subtree with all the Deepest Nodes - Given the root of a binary tree, the depth of each node is the shortest distance to the root.\n\nReturn the smallest subtree such that it contains all the deepest nodes in the original tree.\n\nA node is called the deepest if it has the largest depth possible among any node in the entire tree.\n\nThe subtree of a node is a tree consisting of that node, plus the set of all descendants of that node.\n\n \n\nExample 1:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/01/sketch1.png]\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4]\nOutput: [2,7,4]\nExplanation: We return the node with value 2, colored in yellow in the diagram.\nThe nodes coloured in blue are the deepest nodes of the tree.\nNotice that nodes 5, 3 and 2 contain the deepest nodes in the tree but node 2 is the smallest subtree among them, so we return it.\n\n\nExample 2:\n\n\nInput: root = [1]\nOutput: [1]\nExplanation: The root is the deepest node in the tree.\n\n\nExample 3:\n\n\nInput: root = [0,1,3,null,2]\nOutput: [2]\nExplanation: The deepest node in the tree is 2, the valid subtrees are the subtrees of nodes 2, 1 and 0 but the subtree of node 2 is the smallest.\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree will be in the range [1, 500].\n * 0 <= Node.val <= 500\n * The values of the nodes in the tree are unique.\n\n \n\nNote: This question is the same as 1123: https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/ [https://leetcode.com/problems/lowest-common-ancestor-of-deepest-leaves/]",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* subtreeWithAllDeepest(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    Map<TreeNode, Integer> depth;\n    int max_depth;\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n        depth = new HashMap();\n        depth.put(null, -1);\n        dfs(root, null);\n        max_depth = -1;\n        for (Integer d: depth.values())\n            max_depth = Math.max(max_depth, d);\n\n        return answer(root);\n    }\n\n    public void dfs(TreeNode node, TreeNode parent) {\n        if (node != null) {\n            depth.put(node, depth.get(parent) + 1);\n            dfs(node.left, node);\n            dfs(node.right, node);\n        }\n    }\n\n    public TreeNode answer(TreeNode node) {\n        if (node == null || depth.get(node) == max_depth)\n            return node;\n        TreeNode L = answer(node.left),\n                 R = answer(node.right);\n        if (L != null && R != null) return node;\n        if (L != null) return L;\n        if (R != null) return R;\n        return null;\n    }\n}",
        "class Solution {\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n        return dfs(root).node;\n    }\n\n    // Return the result of the subtree at this node.\n    public Result dfs(TreeNode node) {\n        if (node == null) return new Result(null, 0);\n        Result L = dfs(node.left),\n               R = dfs(node.right);\n        if (L.dist > R.dist) return new Result(L.node, L.dist + 1);\n        if (L.dist < R.dist) return new Result(R.node, R.dist + 1);\n        return new Result(node, L.dist + 1);\n    }\n}\n\n/**\n * The result of a subtree is:\n *       Result.node: the largest depth node that is equal to or\n *                    an ancestor of all the deepest nodes of this subtree.\n *       Result.dist: the number of nodes in the path from the root\n *                    of this subtree, to the deepest node in this subtree.\n */\nclass Result {\n    TreeNode node;\n    int dist;\n    Result(TreeNode n, int d) {\n        node = n;\n        dist = d;\n    }\n}"
      ]
    },
    {
      "number": 167,
      "question": "Can you solve this real interview question? Prime Palindrome - Given an integer n, return the smallest prime palindrome greater than or equal to n.\n\nAn integer is prime if it has exactly two divisors: 1 and itself. Note that 1 is not a prime number.\n\n * For example, 2, 3, 5, 7, 11, and 13 are all primes.\n\nAn integer is a palindrome if it reads the same from left to right as it does from right to left.\n\n * For example, 101 and 12321 are palindromes.\n\nThe test cases are generated so that the answer always exists and is in the range [2, 2 * 108].\n\n \n\nExample 1:\n\nInput: n = 6\nOutput: 7\n\n\nExample 2:\n\nInput: n = 8\nOutput: 11\n\n\nExample 3:\n\nInput: n = 13\nOutput: 101\n\n\n \n\nConstraints:\n\n * 1 <= n <= 108",
      "code": "class Solution {\npublic:\n    int primePalindrome(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int primePalindrome(int N) {\n        for (int L = 1; L <= 5; ++L) {\n            //Check for odd-length palindromes\n            for (int root = (int)Math.pow(10, L - 1); root < (int)Math.pow(10, L); ++root) {\n                StringBuilder sb = new StringBuilder(Integer.toString(root));\n                for (int k = L-2; k >= 0; --k)\n                    sb.append(sb.charAt(k));\n                int x = Integer.valueOf(sb.toString());\n                if (x >= N && isPrime(x))\n                    return x;\n                    //If we didn't check for even-length palindromes:\n                    //return N <= 11 ? min(x, 11) : x\n            }\n\n            //Check for even-length palindromes\n            for (int root = (int)Math.pow(10, L - 1); root < (int)Math.pow(10, L); ++root) {\n                StringBuilder sb = new StringBuilder(Integer.toString(root));\n                for (int k = L-1; k >= 0; --k)\n                    sb.append(sb.charAt(k));\n                int x = Integer.valueOf(sb.toString());\n                if (x >= N && isPrime(x))\n                    return x;\n            }\n        }\n\n        throw null;\n    }\n\n    public boolean isPrime(int N) {\n        if (N < 2) return false;\n        int R = (int) Math.sqrt(N);\n        for (int d = 2; d <= R; ++d)\n            if (N % d == 0) return false;\n        return true;\n    }\n}",
        "class Solution {\n    public int primePalindrome(int N) {\n        while (true) {\n            if (N == reverse(N) && isPrime(N))\n                return N;\n            N++;\n            \n            // Any even length palindrome must be divisble by 11\n            // so we will skip numbers N = [10,000,000, 99,999,999]\n            if (10_000_000 < N && N < 100_000_000)\n                N = 100_000_000;\n        }\n    }\n\n    public boolean isPrime(int N) {\n        if (N < 2) return false;\n        int R = (int) Math.sqrt(N);\n        for (int d = 2; d <= R; ++d)\n            if (N % d == 0) return false;\n        return true;\n    }\n\n    public int reverse(int N) {\n        int ans = 0;\n        while (N > 0) {\n            ans = 10 * ans + (N % 10);\n            N /= 10;\n        }\n        return ans;\n    }\n}\n"
      ]
    },
    {
      "number": 168,
      "question": "Can you solve this real interview question? Transpose Matrix - Given a 2D integer array matrix, return the transpose of matrix.\n\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.\n\n[https://assets.leetcode.com/uploads/2021/02/10/hint_transpose.png]\n\n \n\nExample 1:\n\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]\n\n\nExample 2:\n\n\nInput: matrix = [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]\n\n\n \n\nConstraints:\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 1000\n * 1 <= m * n <= 105\n * -109 <= matrix[i][j] <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& \nmatrix) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[][] transpose(int[][] A) {\n        int R = A.length, C = A[0].length;\n        int[][] ans = new int[C][R];\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                ans[c][r] = A[r][c];\n            }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 169,
      "question": "Can you solve this real interview question? Binary Gap - Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\n\nTwo 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n\n \n\nExample 1:\n\n\nInput: n = 22\nOutput: 2\nExplanation: 22 in binary is \"10110\".\nThe first adjacent pair of 1's is \"10110\" with a distance of 2.\nThe second adjacent pair of 1's is \"10110\" with a distance of 1.\nThe answer is the largest of these two distances, which is 2.\nNote that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n\n\nExample 2:\n\n\nInput: n = 8\nOutput: 0\nExplanation: 8 in binary is \"1000\".\nThere are not any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n\n\nExample 3:\n\n\nInput: n = 5\nOutput: 2\nExplanation: 5 in binary is \"101\".\n\n\n \n\nConstraints:\n\n * 1 <= n <= 109",
      "code": "class Solution {\npublic:\n    int binaryGap(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int binaryGap(int N) {\n        int[] A = new int[32];\n        int t = 0;\n        for (int i = 0; i < 32; ++i)\n            if (((N >> i) & 1) != 0)\n                A[t++] = i;\n\n        int ans = 0;\n        for (int i = 0; i < t - 1; ++i)\n            ans = Math.max(ans, A[i+1] - A[i]);\n        return ans;\n    }\n}",
        "class Solution {\n    public int binaryGap(int N) {\n        int last = -1, ans = 0;\n        for (int i = 0; i < 32; ++i)\n            if (((N >> i) & 1) > 0) {\n                if (last >= 0)\n                    ans = Math.max(ans, i - last);\n                last = i;\n            }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 170,
      "question": "Can you solve this real interview question? Advantage Shuffle - You are given two integer arrays nums1 and nums2 both of the same length. The advantage of nums1 with respect to nums2 is the number of indices i for which nums1[i] > nums2[i].\n\nReturn any permutation of nums1 that maximizes its advantage with respect to nums2.\n\n \n\nExample 1:\n\nInput: nums1 = [2,7,11,15], nums2 = [1,10,4,11]\nOutput: [2,11,7,15]\n\n\nExample 2:\n\nInput: nums1 = [12,24,8,32], nums2 = [13,25,32,11]\nOutput: [24,32,8,12]\n\n\n \n\nConstraints:\n\n * 1 <= nums1.length <= 105\n * nums2.length == nums1.length\n * 0 <= nums1[i], nums2[i] <= 109",
      "code": "class Solution {\npublic:\n    vector<int> advantageCount(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] advantageCount(int[] A, int[] B) {\n        int[] sortedA = A.clone();\n        Arrays.sort(sortedA);\n        int[] sortedB = B.clone();\n        Arrays.sort(sortedB);\n\n        // assigned[b] = list of a that are assigned to beat b\n        Map<Integer, Deque<Integer>> assigned = new HashMap();\n        for (int b: B) assigned.put(b, new LinkedList());\n\n        // remaining = list of a that are not assigned to any b\n        Deque<Integer> remaining = new LinkedList();\n\n        // populate (assigned, remaining) appropriately\n        // sortedB[j] is always the smallest unassigned element in B\n        int j = 0;\n        for (int a: sortedA) {\n            if (a > sortedB[j]) {\n                assigned.get(sortedB[j++]).add(a);\n            } else {\n                remaining.add(a);\n            }\n        }\n\n        // Reconstruct the answer from annotations (assigned, remaining)\n        int[] ans = new int[B.length];\n        for (int i = 0; i < B.length; ++i) {\n            // if there is some a assigned to b...\n            if (assigned.get(B[i]).size() > 0)\n                ans[i] = assigned.get(B[i]).pop();\n            else\n                ans[i] = remaining.pop();\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 171,
      "question": "Can you solve this real interview question? Minimum Number of Refueling Stops - A car travels from a starting position to a destination which is target miles east of the starting position.\n\nThere are gas stations along the way. The gas stations are represented as an array stations where stations[i] = [positioni, fueli] indicates that the ith gas station is positioni miles east of the starting position and has fueli liters of gas.\n\nThe car starts with an infinite tank of gas, which initially has startFuel liters of fuel in it. It uses one liter of gas per one mile that it drives. When the car reaches a gas station, it may stop and refuel, transferring all the gas from the station into the car.\n\nReturn the minimum number of refueling stops the car must make in order to reach its destination. If it cannot reach the destination, return -1.\n\nNote that if the car reaches a gas station with 0 fuel left, the car can still refuel there. If the car reaches the destination with 0 fuel left, it is still considered to have arrived.\n\n \n\nExample 1:\n\n\nInput: target = 1, startFuel = 1, stations = []\nOutput: 0\nExplanation: We can reach the target without refueling.\n\n\nExample 2:\n\n\nInput: target = 100, startFuel = 1, stations = [[10,100]]\nOutput: -1\nExplanation: We can not reach the target (or even the first gas station).\n\n\nExample 3:\n\n\nInput: target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]\nOutput: 2\nExplanation: We start with 10 liters of fuel.\nWe drive to position 10, expending 10 liters of fuel.  We refuel from 0 liters to 60 liters of gas.\nThen, we drive from position 10 to position 60 (expending 50 liters of fuel),\nand refuel from 10 liters to 50 liters of gas.  We then drive to and reach the target.\nWe made 2 refueling stops along the way, so we return 2.\n\n\n \n\nConstraints:\n\n * 1 <= target, startFuel <= 109\n * 0 <= stations.length <= 500\n * 1 <= positioni < positioni+1 < target\n * 1 <= fueli < 109",
      "code": "class Solution {\npublic:\n    int minRefuelStops(int target, int startFuel, \nvector<vector<int>>& stations) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minRefuelStops(int target, int startFuel, int[][] stations) {\n        int N = stations.length;\n        long[] dp = new long[N + 1];\n        dp[0] = startFuel;\n        for (int i = 0; i < N; ++i)\n            for (int t = i; t >= 0; --t)\n                if (dp[t] >= stations[i][0])\n                    dp[t+1] = Math.max(dp[t+1], dp[t] + (long) stations[i][1]);\n\n        for (int i = 0; i <= N; ++i)\n            if (dp[i] >= target) return i;\n        return -1;\n    }\n}",
        "class Solution {\n    public int minRefuelStops(int target, int tank, int[][] stations) {\n        // pq is a maxheap of gas station capacities\n        PriorityQueue<Integer> pq = new PriorityQueue(Collections.reverseOrder());\n        int ans = 0, prev = 0;\n        for (int[] station: stations) {\n            int location = station[0];\n            int capacity = station[1];\n            tank -= location - prev;\n            while (!pq.isEmpty() && tank < 0) {  // must refuel in past\n                tank += pq.poll();\n                ans++;\n            }\n\n            if (tank < 0) return -1;\n            pq.offer(capacity);\n            prev = location;\n        }\n\n        // Repeat body for station = (target, inf)\n        {\n            tank -= target - prev;\n            while (!pq.isEmpty() && tank < 0) {\n                tank += pq.poll();\n                ans++;\n            }\n            if (tank < 0) return -1;\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 172,
      "question": "Can you solve this real interview question? Leaf-Similar Trees - Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/16/tree.png]\n\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\n\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\n\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-1.jpg]\n\n\nInput: root1 = [3,5,1,6,2,9,8,null,null,7,4], root2 = [3,5,1,6,7,4,2,null,null,null,null,null,null,9,8]\nOutput: true\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/09/03/leaf-similar-2.jpg]\n\n\nInput: root1 = [1,2,3], root2 = [1,3,2]\nOutput: false\n\n\n \n\nConstraints:\n\n * The number of nodes in each tree will be in the range [1, 200].\n * Both of the given trees will have values in the range [0, 200].",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        vector<int> leaves1;\n        vector<int> leaves2;\n        dfs(root1, leaves1);\n        dfs(root2, leaves2);\n\n        return leaves1 == leaves2;\n    }\n\n    void dfs(TreeNode* node, vector<int>& leaves) {\n        if (node == NULL) return;\n        if (node->left == NULL && node->right == NULL)\n            leaves.push_back(node->val);\n        dfs(node->left, leaves);\n        dfs(node->right, leaves);\n    }\n};"
      ]
    },
    {
      "number": 173,
      "question": "Can you solve this real interview question? Length of Longest Fibonacci Subsequence - A sequence x1, x2, ..., xn is Fibonacci-like if:\n\n * n >= 3\n * xi + xi+1 == xi+2 for all i + 2 <= n\n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\n\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].\n\n \n\nExample 1:\n\n\nInput: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].\n\nExample 2:\n\n\nInput: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18].\n\n \n\nConstraints:\n\n * 3 <= arr.length <= 1000\n * 1 <= arr[i] < arr[i + 1] <= 109",
      "code": "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        int N = A.size();\n        unordered_set<int> S(A.begin(), A.end());\n\n        int ans = 0;\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j) {\n                /* With the starting pair (A[i], A[j]),\n                 * y represents the future expected value in\n                 * the fibonacci subsequence, and x represents\n                 * the most current value found. */\n                int x = A[j], y = A[i] + A[j];\n                int length = 2;\n                while (S.find(y) != S.end()) {\n                    int z = x + y;\n                    x = y;\n                    y = z;\n                    ans = max(ans, ++length);\n                }\n            }\n\n        return ans >= 3 ? ans : 0;\n    }\n};",
        "class Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& A) {\n        int N = A.size();\n        unordered_map<int, int> index;\n        for (int i = 0; i < N; ++i)\n            index[A[i]] = i;\n\n        unordered_map<int, int> longest;\n        int ans = 0;\n        for (int k = 0; k < N; ++k)\n            for (int j = 0; j < k; ++j) {\n                if (A[k] - A[j] < A[j] && index.count(A[k] - A[j])) {\n                    int i = index[A[k] - A[j]];\n                    longest[j * N + k] = longest[i * N + j] + 1;\n                    ans = max(ans, longest[j * N + k] + 2);\n                }\n            }\n\n        return ans >= 3 ? ans : 0;\n    }\n};"
      ]
    },
    {
      "number": 174,
      "question": "Can you solve this real interview question? Walking Robot Simulation - A robot on an infinite XY-plane starts at point (0, 0) facing north. The robot can receive a sequence of these three possible types of commands:\n\n * -2: Turn left 90 degrees.\n * -1: Turn right 90 degrees.\n * 1 <= k <= 9: Move forward k units, one unit at a time.\n\nSome of the grid squares are obstacles. The ith obstacle is at grid point obstacles[i] = (xi, yi). If the robot runs into an obstacle, then it will instead stay in its current location and move on to the next command.\n\nReturn the maximum Euclidean distance that the robot ever gets from the origin squared (i.e. if the distance is 5, return 25).\n\nNote:\n\n * North means +Y direction.\n * East means +X direction.\n * South means -Y direction.\n * West means -X direction.\n * There can be obstacle in [0,0].\n\n \n\nExample 1:\n\n\nInput: commands = [4,-1,3], obstacles = []\nOutput: 25\nExplanation: The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 3 units to (3, 4).\nThe furthest point the robot ever gets from the origin is (3, 4), which squared is 32 + 42 = 25 units away.\n\n\nExample 2:\n\n\nInput: commands = [4,-1,4,-2,4], obstacles = [[2,4]]\nOutput: 65\nExplanation: The robot starts at (0, 0):\n1. Move north 4 units to (0, 4).\n2. Turn right.\n3. Move east 1 unit and get blocked by the obstacle at (2, 4), robot is at (1, 4).\n4. Turn left.\n5. Move north 4 units to (1, 8).\nThe furthest point the robot ever gets from the origin is (1, 8), which squared is 12 + 82 = 65 units away.\n\n\nExample 3:\n\n\nInput: commands = [6,-1,-1,6], obstacles = []\nOutput: 36\nExplanation: The robot starts at (0, 0):\n1. Move north 6 units to (0, 6).\n2. Turn right.\n3. Turn right.\n4. Move south 6 units to (0, 0).\nThe furthest point the robot ever gets from the origin is (0, 6), which squared is 62 = 36 units away.\n\n\n \n\nConstraints:\n\n * 1 <= commands.length <= 104\n * commands[i] is either -2, -1, or an integer in the range [1, 9].\n * 0 <= obstacles.length <= 104\n * -3 * 104 <= xi, yi <= 3 * 104\n * The answer is guaranteed to be less than 231.",
      "code": "class Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& \nobstacles) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int robotSim(vector<int>& commands, vector<vector<int>>& obstacles) {\n        int dx[4] = {0, 1, 0, -1};\n        int dy[4] = {1, 0, -1, 0};\n        int x = 0, y = 0, di = 0;\n\n        unordered_set<pair<int, int>> obstacleSet;\n        for (vector<int> obstacle: obstacles)\n            obstacleSet.insert(make_pair(obstacle[0], obstacle[1]));\n\n        int ans = 0;\n        for (int cmd: commands) {\n            if (cmd == -2)\n                di = (di + 3) % 4;\n            else if (cmd == -1)\n                di = (di + 1) % 4;\n            else {\n                for (int k = 0; k < cmd; ++k) {\n                    int nx = x + dx[di];\n                    int ny = y + dy[di];\n                    if (obstacleSet.find(make_pair(nx, ny)) == obstacleSet.end()) {\n                        x = nx;\n                        y = ny;\n                        ans = max(ans, x*x + y*y);\n                    }\n                }\n            }\n        }\n\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 175,
      "question": "Can you solve this real interview question? Stone Game - Alice and Bob play a game with piles of stones. There are an even number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].\n\nThe objective of the game is to end with the most stones. The total number of stones across all the piles is odd, so there are no ties.\n\nAlice and Bob take turns, with Alice starting first. Each turn, a player takes the entire pile of stones either from the beginning or from the end of the row. This continues until there are no more piles left, at which point the person with the most stones wins.\n\nAssuming Alice and Bob play optimally, return true if Alice wins the game, or false if Bob wins.\n\n \n\nExample 1:\n\n\nInput: piles = [5,3,4,5]\nOutput: true\nExplanation: \nAlice starts first, and can only take the first 5 or the last 5.\nSay she takes the first 5, so that the row becomes [3, 4, 5].\nIf Bob takes 3, then the board is [4, 5], and Alice takes 5 to win with 10 points.\nIf Bob takes the last 5, then the board is [3, 4], and Alice takes 4 to win with 9 points.\nThis demonstrated that taking the first 5 was a winning move for Alice, so we return true.\n\n\nExample 2:\n\n\nInput: piles = [3,7,2,3]\nOutput: true\n\n\n \n\nConstraints:\n\n * 2 <= piles.length <= 500\n * piles.length is even.\n * 1 <= piles[i] <= 500\n * sum(piles[i]) is odd.",
      "code": "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        int N = piles.size();\n\n        // dp[i+1][j+1] = the value of the game [piles[i], ..., piles[j]]\n        int dp[N+2][N+2];\n        memset(dp, 0, sizeof(dp));\n\n        for (int size = 1; size <= N; ++size)\n            for (int i = 0, j = size - 1; j < N; ++i, ++j) {\n                int parity = (j + i + N) % 2;  // j - i - N; but +x = -x (mod 2)\n                if (parity == 1)\n                    dp[i+1][j+1] = max(piles[i] + dp[i+2][j+1], piles[j] + dp[i+1][j]);\n                else\n                    dp[i+1][j+1] = min(-piles[i] + dp[i+2][j+1], -piles[j] + dp[i+1][j]);\n            }\n\n        return dp[1][N] > 0;\n    }\n};",
        "class Solution {\npublic:\n    bool stoneGame(vector<int>& piles) {\n        return true;\n    }\n};"
      ]
    },
    {
      "number": 176,
      "question": "Can you solve this real interview question? Reachable Nodes In Subdivided Graph - You are given an undirected graph (the \"original graph\") with n nodes labeled from 0 to n - 1. You decide to subdivide each edge in the graph into a chain of nodes, with the number of new nodes varying between each edge.\n\nThe graph is given as a 2D array of edges where edges[i] = [ui, vi, cnti] indicates that there is an edge between nodes ui and vi in the original graph, and cnti is the total number of new nodes that you will subdivide the edge into. Note that cnti == 0 means you will not subdivide the edge.\n\nTo subdivide the edge [ui, vi], replace it with (cnti + 1) new edges and cnti new nodes. The new nodes are x1, x2, ..., xcnti, and the new edges are [ui, x1], [x1, x2], [x2, x3], ..., [xcnti-1, xcnti], [xcnti, vi].\n\nIn this new graph, you want to know how many nodes are reachable from the node 0, where a node is reachable if the distance is maxMoves or less.\n\nGiven the original graph and maxMoves, return the number of nodes that are reachable from node 0 in the new graph.\n\n \n\nExample 1:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/01/origfinal.png]\n\n\nInput: edges = [[0,1,10],[0,2,1],[1,2,2]], maxMoves = 6, n = 3\nOutput: 13\nExplanation: The edge subdivisions are shown in the image above.\nThe nodes that are reachable are highlighted in yellow.\n\n\nExample 2:\n\n\nInput: edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], maxMoves = 10, n = 4\nOutput: 23\n\n\nExample 3:\n\n\nInput: edges = [[1,2,4],[1,4,5],[1,3,1],[2,3,4],[3,4,5]], maxMoves = 17, n = 5\nOutput: 1\nExplanation: Node 0 is disconnected from the rest of the graph, so only node 0 is reachable.\n\n\n \n\nConstraints:\n\n * 0 <= edges.length <= min(n * (n - 1) / 2, 104)\n * edges[i].length == 3\n * 0 <= ui < vi < n\n * There are no multiple edges in the graph.\n * 0 <= cnti <= 104\n * 0 <= maxMoves <= 109\n * 1 <= n <= 3000",
      "code": "class Solution {\npublic:\n    int reachableNodes(vector<vector<int>>& edges, int \nmaxMoves, int n) {\n        \n    }\n};",
      "solution": [
        "#define pii pair<int, int>\n\nclass Solution {\npublic:\n    int reachableNodes(vector<vector<int>>& edges, int M, int N) {\n        vector<vector<pii>> graph(N);\n        for (vector<int> edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            graph[u].push_back({v, w});\n            graph[v].push_back({u, w});\n        }\n\n        map<int, int> dist;\n        dist[0] = 0;\n        for (int i = 1; i < N; ++i)\n            dist[i] = M+1;\n\n        map<pii, int> used;\n        int ans = 0;\n\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\n        pq.push({0, 0});\n\n        while (!pq.empty()) {\n            pii top = pq.top();\n            pq.pop();\n            int d = top.first, node = top.second;\n            if (d > dist[node]) continue;\n\n            // Each node is only visited once.  We've reached\n            // a node in our original graph.\n            ans++;\n\n            for (auto pair: graph[node]) {\n                // M - d is how much further we can walk from this node;\n                // weight is how many new nodes there are on this edge.\n                // v is the maximum utilization of this edge.\n                int nei = pair.first;\n                int weight = pair.second;\n                used[{node, nei}] = min(weight, M - d);\n\n                // d2 is the total distance to reach 'nei' (neighbor) node\n                // in the original graph.\n                int d2 = d + weight + 1;\n                if (d2 < min(dist[nei], M+1)) {\n                    pq.push({d2, nei});\n                    dist[nei] = d2;\n                }\n            }\n        }\n\n        // At the end, each edge (u, v, w) can be used with a maximum\n        // of w new nodes: a max of used[u, v] nodes from one side,\n        // and used[v, u] nodes from the other.\n        for (vector<int> edge: edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            ans += min(w, used[{u, v}] + used[{v, u}]);\n        }\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 177,
      "question": "Can you solve this real interview question? Projection Area of 3D Shapes - You are given an n x n grid where we place some 1 x 1 x 1 cubes that are axis-aligned with the x, y, and z axes.\n\nEach value v = grid[i][j] represents a tower of v cubes placed on top of the cell (i, j).\n\nWe view the projection of these cubes onto the xy, yz, and zx planes.\n\nA projection is like a shadow, that maps our 3-dimensional figure to a 2-dimensional plane. We are viewing the \"shadow\" when looking at the cubes from the top, the front, and the side.\n\nReturn the total area of all three projections.\n\n \n\nExample 1:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png]\n\n\nInput: grid = [[1,2],[3,4]]\nOutput: 17\nExplanation: Here are the three projections (\"shadows\") of the shape made with each axis-aligned plane.\n\n\nExample 2:\n\n\nInput: grid = [[2]]\nOutput: 5\n\n\nExample 3:\n\n\nInput: grid = [[1,0],[0,2]]\nOutput: 8\n\n\n \n\nConstraints:\n\n * n == grid.length == grid[i].length\n * 1 <= n <= 50\n * 0 <= grid[i][j] <= 50",
      "code": "class Solution {\npublic:\n    int projectionArea(vector<vector<int>>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int projectionArea(vector<vector<int>>& grid) {\n        int N = grid.size();\n        int ans = 0;\n\n        for (int i = 0; i < N;  ++i) {\n            int bestRow = 0;  // largest of grid[i][j]\n            int bestCol = 0;  // largest of grid[j][i]\n            for (int j = 0; j < N; ++j) {\n                if (grid[i][j] > 0) ans++;  // top shadow\n                bestRow = max(bestRow, grid[i][j]);\n                bestCol = max(bestCol, grid[j][i]);\n            }\n            ans += bestRow + bestCol;\n        }\n\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 178,
      "question": "Can you solve this real interview question? Uncommon Words from Two Sentences - A sentence is a string of single-space separated words where each word consists only of lowercase letters.\n\nA word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\n\nGiven two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\nOutput: [\"sweet\",\"sour\"]\n\n\nExample 2:\n\nInput: s1 = \"apple apple\", s2 = \"banana\"\nOutput: [\"banana\"]\n\n\n \n\nConstraints:\n\n * 1 <= s1.length, s2.length <= 200\n * s1 and s2 consist of lowercase English letters and spaces.\n * s1 and s2 do not have leading or trailing spaces.\n * All the words in s1 and s2 are separated by a single space.",
      "code": "class Solution {\npublic:\n    vector<string> uncommonFromSentences(string s1, string \ns2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String[] uncommonFromSentences(String A, String B) {\n        Map<String, Integer> count = new HashMap();\n        for (String word: A.split(\" \"))\n            count.put(word, count.getOrDefault(word, 0) + 1);\n        for (String word: B.split(\" \"))\n            count.put(word, count.getOrDefault(word, 0) + 1);\n\n        List<String> ans = new LinkedList();\n        for (String word: count.keySet())\n            if (count.get(word) == 1)\n                ans.add(word);\n\n        return ans.toArray(new String[ans.size()]);\n    }\n}"
      ]
    },
    {
      "number": 179,
      "question": "Can you solve this real interview question? Spiral Matrix III - You start at the cell (rStart, cStart) of an rows x cols grid facing east. The northwest corner is at the first row and column in the grid, and the southeast corner is at the last row and column.\n\nYou will walk in a clockwise spiral shape to visit every position in this grid. Whenever you move outside the grid's boundary, we continue our walk outside the grid (but may return to the grid boundary later.). Eventually, we reach all rows * cols spaces of the grid.\n\nReturn an array of coordinates representing the positions of the grid in the order you visited them.\n\n \n\nExample 1:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_1.png]\n\n\nInput: rows = 1, cols = 4, rStart = 0, cStart = 0\nOutput: [[0,0],[0,1],[0,2],[0,3]]\n\n\nExample 2:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/24/example_2.png]\n\n\nInput: rows = 5, cols = 6, rStart = 1, cStart = 4\nOutput: [[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]\n\n\n \n\nConstraints:\n\n * 1 <= rows, cols <= 100\n * 0 <= rStart < rows\n * 0 <= cStart < cols",
      "code": "class Solution {\npublic:\n    vector<vector<int>> spiralMatrixIII(int rows, int cols, \nint rStart, int cStart) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[][] spiralMatrixIII(int R, int C, int r0, int c0) {\n        int[] dr = new int[]{0, 1, 0, -1};\n        int[] dc = new int[]{1, 0, -1, 0};\n\n        int[][] ans = new int[R*C][2];\n        int t = 0;\n\n        ans[t++] = new int[]{r0, c0};\n        if (R * C == 1) return ans;\n\n        for (int k = 1; k < 2*(R+C); k += 2)\n            for (int i = 0; i < 4; ++i) {  // i: direction index\n                int dk = k + (i / 2);  // number of steps in this direction\n                for (int j = 0; j < dk; ++j) {  // for each step in this direction...\n                    // step in the i-th direction\n                    r0 += dr[i];\n                    c0 += dc[i];\n                    if (0 <= r0 && r0 < R && 0 <= c0 && c0 < C) {\n                        ans[t++] = new int[]{r0, c0};\n                        if (t == R * C) return ans;\n                    }\n                }\n            }\n\n        throw null;\n    }\n}"
      ]
    },
    {
      "number": 180,
      "question": "Can you solve this real interview question? Sum of Subsequence Widths - The width of a sequence is the difference between the maximum and minimum elements in the sequence.\n\nGiven an array of integers nums, return the sum of the widths of all the non-empty subsequences of nums. Since the answer may be very large, return it modulo 109 + 7.\n\nA subsequence is a sequence that can be derived from an array by deleting some or no elements without changing the order of the remaining elements. For example, [3,6,2,7] is a subsequence of the array [0,3,1,6,2,2,7].\n\n \n\nExample 1:\n\n\nInput: nums = [2,1,3]\nOutput: 6\nExplanation: The subsequences are [1], [2], [3], [2,1], [2,3], [1,3], [2,1,3].\nThe corresponding widths are 0, 0, 0, 1, 1, 2, 2.\nThe sum of these widths is 6.\n\n\nExample 2:\n\n\nInput: nums = [2]\nOutput: 0\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 105",
      "code": "class Solution {\npublic:\n    int sumSubseqWidths(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int sumSubseqWidths(int[] A) {\n        int MOD = 1_000_000_007;\n        int N = A.length;\n        Arrays.sort(A);\n\n        long[] pow2 = new long[N];\n        pow2[0] = 1;\n        for (int i = 1; i < N; ++i)\n            pow2[i] = pow2[i-1] * 2 % MOD;\n\n        long ans = 0;\n        for (int i = 0; i < N; ++i)\n            ans = (ans + (pow2[i] - pow2[N-1-i]) * A[i]) % MOD;\n\n        return (int) ans;\n    }\n}"
      ]
    },
    {
      "number": 181,
      "question": "Can you solve this real interview question? All Possible Full Binary Trees - Given an integer n, return a list of all possible full binary trees with n nodes. Each node of each tree in the answer must have Node.val == 0.\n\nEach element of the answer is the root node of one possible tree. You may return the final list of trees in any order.\n\nA full binary tree is a binary tree where each node has exactly 0 or 2 children.\n\n \n\nExample 1:\n\n[https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/22/fivetrees.png]\n\n\nInput: n = 7\nOutput: [[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]\n\n\nExample 2:\n\n\nInput: n = 3\nOutput: [[0,0,0]]\n\n\n \n\nConstraints:\n\n * 1 <= n <= 20",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> allPossibleFBT(int n) {\n        \n    }\n};",
      "solution": [
        "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    unordered_map<int, vector<TreeNode*>> memo;\n    vector<TreeNode*> allPossibleFBT(int n) {\n        if ((n % 2) == 0) {\n            return {};\n        }\n        \n        if (n == 1) {\n            return {new TreeNode()};\n        }\n        \n        if(memo.find(n) != memo.end()) {\n            return memo[n];\n        }\n\n        vector<TreeNode*> res;\n        for (int i = 1; i < n; i += 2) {\n            vector<TreeNode*> left = allPossibleFBT(i);\n            vector<TreeNode*> right = allPossibleFBT(n - i - 1);\n            \n            for (auto l : left) {\n                for (auto r : right) {\n                    TreeNode* root = new TreeNode(0, l, r);\n                    res.push_back(root);\n                }\n            }\n        }\n        \n        return memo[n] = res;\n    }\n};",
        "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<TreeNode*> allPossibleFBT(int n) {\n        if (n % 2 == 0) {\n            return {};\n        }\n\n        vector<vector<TreeNode*>> dp(n + 1);\n\n        dp[1].push_back(new TreeNode(0));\n        for (int count = 3; count <= n; count += 2) {\n            for (int i = 1; i < count - 1; i += 2) {\n                int j = count - 1 - i;\n                for (auto left : dp[i]) {\n                    for (auto right : dp[j]) {\n                        TreeNode* root = new TreeNode(0, left, right);\n                        dp[count].push_back(root);\n                    }\n                }\n            }\n        }\n        \n        return dp[n];\n    }\n};"
      ]
    },
    {
      "number": 182,
      "question": "Can you solve this real interview question? Bitwise ORs of Subarrays - Given an integer array arr, return the number of distinct bitwise ORs of all the non-empty subarrays of arr.\n\nThe bitwise OR of a subarray is the bitwise OR of each integer in the subarray. The bitwise OR of a subarray of one integer is that integer.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n \n\nExample 1:\n\n\nInput: arr = [0]\nOutput: 1\nExplanation: There is only one possible result: 0.\n\n\nExample 2:\n\n\nInput: arr = [1,1,2]\nOutput: 3\nExplanation: The possible subarrays are [1], [1], [2], [1, 1], [1, 2], [1, 1, 2].\nThese yield the results 1, 1, 2, 1, 3, 3.\nThere are 3 unique values, so the answer is 3.\n\n\nExample 3:\n\n\nInput: arr = [1,2,4]\nOutput: 6\nExplanation: The possible results are 1, 2, 3, 4, 6, and 7.\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 5 * 104\n * 0 <= arr[i] <= 109",
      "code": "class Solution {\npublic:\n    int subarrayBitwiseORs(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int subarrayBitwiseORs(int[] A) {\n        Set<Integer> ans = new HashSet();\n        Set<Integer> cur = new HashSet();\n        cur.add(0);\n        for (int x: A) {\n            Set<Integer> cur2 = new HashSet();\n            for (int y: cur)\n                cur2.add(x | y);\n            cur2.add(x);\n            cur = cur2;\n            ans.addAll(cur);\n        }\n\n        return ans.size();\n    }\n}"
      ]
    },
    {
      "number": 183,
      "question": "Can you solve this real interview question? Numbers At Most N Given Digit Set - Given an array of digits which is sorted in non-decreasing order. You can write numbers using each digits[i] as many times as we want. For example, if digits = ['1','3','5'], we may write numbers such as '13', '551', and '1351315'.\n\nReturn the number of positive integers that can be generated that are less than or equal to a given integer n.\n\n \n\nExample 1:\n\n\nInput: digits = [\"1\",\"3\",\"5\",\"7\"], n = 100\nOutput: 20\nExplanation: \nThe 20 numbers that can be written are:\n1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.\n\n\nExample 2:\n\n\nInput: digits = [\"1\",\"4\",\"9\"], n = 1000000000\nOutput: 29523\nExplanation: \nWe can write 3 one digit numbers, 9 two digit numbers, 27 three digit numbers,\n81 four digit numbers, 243 five digit numbers, 729 six digit numbers,\n2187 seven digit numbers, 6561 eight digit numbers, and 19683 nine digit numbers.\nIn total, this is 29523 integers that can be written using the digits array.\n\n\nExample 3:\n\n\nInput: digits = [\"7\"], n = 8\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= digits.length <= 9\n * digits[i].length == 1\n * digits[i] is a digit from '1' to '9'.\n * All the values in digits are unique.\n * digits is sorted in non-decreasing order.\n * 1 <= n <= 109",
      "code": "class Solution {\npublic:\n    int atMostNGivenDigitSet(vector<string>& digits, int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int at mostNGivenDigitSet(String[] D, int N) {\n        String S = String.valueOf(N);\n        int K = S.length();\n        int[] dp = new int[K+1];\n        dp[K] = 1;\n\n        for (int i = K-1; i >= 0; --i) {\n            // compute dp[i]\n            int Si = S.charAt(i) - '0';\n            for (String d: D) {\n                if (Integer.valueOf(d) < Si)\n                    dp[i] += Math.pow(D.length, K-i-1);\n                else if (Integer.valueOf(d) == Si)\n                    dp[i] += dp[i+1];\n            }\n        }\n\n        for (int i = 1; i < K; ++i)\n            dp[0] += Math.pow(D.length, i);\n        return dp[0];\n    }\n}",
        "class Solution {\n    public int at mostNGivenDigitSet(String[] D, int N) {\n        int B = D.length; // bijective-base B\n        char[] ca = String.valueOf(N).toCharArray();\n        int K = ca.length;\n        int[] A = new int[K];\n        int t = 0;\n\n        for (char c: ca) {\n            int c_index = 0;  // Largest such that c >= D[c_index - 1]\n            boolean match = false;\n            for (int i = 0; i < B; ++i) {\n                if (c >= D[i].charAt(0))\n                    c_index = i+1;\n                if (c == D[i].charAt(0))\n                    match = true;\n            }\n\n            A[t++] = c_index;\n            if (match) continue;\n\n            if (c_index == 0) { // subtract 1\n                for (int j = t-1; j > 0; --j) {\n                    if (A[j] > 0) break;\n                    A[j] += B;\n                    A[j-1]--;\n                }\n            }\n\n            while (t < K)\n                A[t++] = B;\n            break;\n        }\n\n        int ans = 0;\n        for (int x: A)\n            ans = ans * B + x;\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 184,
      "question": "Can you solve this real interview question? Super Palindromes - Let's say a positive integer is a super-palindrome if it is a palindrome, and it is also the square of a palindrome.\n\nGiven two positive integers left and right represented as strings, return the number of super-palindromes integers in the inclusive range [left, right].\n\n \n\nExample 1:\n\n\nInput: left = \"4\", right = \"1000\"\nOutput: 4\nExplanation: 4, 9, 121, and 484 are superpalindromes.\nNote that 676 is not a superpalindrome: 26 * 26 = 676, but 26 is not a palindrome.\n\n\nExample 2:\n\n\nInput: left = \"1\", right = \"2\"\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= left.length, right.length <= 18\n * left and right consist of only digits.\n * left and right cannot have leading zeros.\n * left and right represent integers in the range [1, 1018 - 1].\n * left is less than or equal to right.",
      "code": "class Solution {\npublic:\n    int superpalindromesInRange(string left, string right) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int superpalindromesInRange(String sL, String sR) {\n        long L = Long.valueOf(sL);\n        long R = Long.valueOf(sR);\n        int MAGIC = 100000;\n        int ans = 0;\n\n        // count odd length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 2; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n\n        // count even length;\n        for (int k = 1; k < MAGIC; ++k) {\n            StringBuilder sb = new StringBuilder(Integer.toString(k));\n            for (int i = sb.length() - 1; i >= 0; --i)\n                sb.append(sb.charAt(i));\n            long v = Long.valueOf(sb.toString());\n            v *= v;\n            if (v > R) break;\n            if (v >= L && isPalindrome(v)) ans++;\n        }\n\n        return ans;\n    }\n\n    public boolean isPalindrome(long x) {\n        return x == reverse(x);\n    }\n\n    public long reverse(long x) {\n        long ans = 0;\n        while (x > 0) {\n            ans = 10 * ans + x % 10;\n            x /= 10;\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 185,
      "question": "Can you solve this real interview question? Smallest Range II - You are given an integer array nums and an integer k.\n\nFor each index i where 0 <= i < nums.length, change nums[i] to be either nums[i] + k or nums[i] - k.\n\nThe score of nums is the difference between the maximum and minimum elements in nums.\n\nReturn the minimum score of nums after changing the values at each index.\n\n \n\nExample 1:\n\n\nInput: nums = [1], k = 0\nOutput: 0\nExplanation: The score is max(nums) - min(nums) = 1 - 1 = 0.\n\n\nExample 2:\n\n\nInput: nums = [0,10], k = 2\nOutput: 6\nExplanation: Change nums to be [2, 8]. The score is max(nums) - min(nums) = 8 - 2 = 6.\n\n\nExample 3:\n\n\nInput: nums = [1,3,6], k = 3\nOutput: 3\nExplanation: Change nums to be [4, 6, 3]. The score is max(nums) - min(nums) = 6 - 3 = 3.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * 0 <= nums[i] <= 104\n * 0 <= k <= 104",
      "code": "class Solution {\npublic:\n    int smallestRangeII(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int smallestRangeII(int[] A, int K) {\n        int N = A.length;\n        Arrays.sort(A);\n        int ans = A[N-1] - A[0];\n\n        for (int i = 0; i < A.length - 1; ++i) {\n            int a = A[i], b = A[i+1];\n            int high = Math.max(A[N-1] - K, a + K);\n            int low = Math.min(A[0] + K, b - K);\n            ans = Math.min(ans, high - low);\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 186,
      "question": "Can you solve this real interview question? Online Election - You are given two integer arrays persons and times. In an election, the ith vote was cast for persons[i] at time times[i].\n\nFor each query at a time t, find the person that was leading the election at time t. Votes cast at time t will count towards our query. In the case of a tie, the most recent vote (among tied candidates) wins.\n\nImplement the TopVotedCandidate class:\n\n * TopVotedCandidate(int[] persons, int[] times) Initializes the object with the persons and times arrays.\n * int q(int t) Returns the number of the person that was leading the election at time t according to the mentioned rules.\n\n \n\nExample 1:\n\n\nInput\n[\"TopVotedCandidate\", \"q\", \"q\", \"q\", \"q\", \"q\", \"q\"]\n[[[0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]], [3], [12], [25], [15], [24], [8]]\nOutput\n[null, 0, 1, 1, 0, 0, 1]\n\nExplanation\nTopVotedCandidate topVotedCandidate = new TopVotedCandidate([0, 1, 1, 0, 0, 1, 0], [0, 5, 10, 15, 20, 25, 30]);\ntopVotedCandidate.q(3); // return 0, At time 3, the votes are [0], and 0 is leading.\ntopVotedCandidate.q(12); // return 1, At time 12, the votes are [0,1,1], and 1 is leading.\ntopVotedCandidate.q(25); // return 1, At time 25, the votes are [0,1,1,0,0,1], and 1 is leading (as ties go to the most recent vote.)\ntopVotedCandidate.q(15); // return 0\ntopVotedCandidate.q(24); // return 0\ntopVotedCandidate.q(8); // return 1\n\n\n\n \n\nConstraints:\n\n * 1 <= persons.length <= 5000\n * times.length == persons.length\n * 0 <= persons[i] < persons.length\n * 0 <= times[i] <= 109\n * times is sorted in a strictly increasing order.\n * times[0] <= t <= 109\n * At most 104 calls will be made to q.",
      "code": "class TopVotedCandidate {\npublic:\n    TopVotedCandidate(vector<int>& persons, vector<int>& \ntimes) {\n        \n    }\n    \n    int q(int t) {\n        \n    }\n};\n\n/**\n * Your TopVotedCandidate object will be instantiated and \ncalled as such:\n * TopVotedCandidate* obj = new TopVotedCandidate(persons, \ntimes);\n * int param_1 = obj->q(t);\n */",
      "solution": [
        "class TopVotedCandidate {\n    List<List<Vote>> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n\n            count.put(p, c);\n            while (A.size() <= c)\n                A.add(new ArrayList<Vote>());\n            A.get(c).add(new Vote(p, t));\n        }\n    }\n\n    public int q(int t) {\n        // Binary search on A[i][0].time for smallest i\n        // such that A[i][0].time > t\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).get(0).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        int i = lo - 1;\n\n        // Binary search on A[i][j].time for smallest j\n        // such that A[i][j].time > t\n        lo = 0; hi = A.get(i).size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(i).get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n        int j = Math.max(lo-1, 0);\n        return A.get(i).get(j).person;\n    }\n}\n\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}",
        "class TopVotedCandidate {\n    List<Vote> A;\n    public TopVotedCandidate(int[] persons, int[] times) {\n        A = new ArrayList();\n        Map<Integer, Integer> count = new HashMap();\n        int leader = -1;  // current leader\n        int m = 0;  // current number of votes for leader\n\n        for (int i = 0; i < persons.length; ++i) {\n            int p = persons[i], t = times[i];\n            int c = count.getOrDefault(p, 0) + 1;\n            count.put(p, c);\n\n            if (c >= m) {\n                if (p != leader) {  // lead change\n                    leader = p;\n                    A.add(new Vote(leader, t));\n                }\n\n                if (c > m) m = c;\n            }\n        }\n    }\n\n    public int q(int t) {\n        int lo = 1, hi = A.size();\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (A.get(mi).time <= t)\n                lo = mi + 1;\n            else\n                hi = mi;\n        }\n\n        return A.get(lo - 1).person;\n    }\n}\n\nclass Vote {\n    int person, time;\n    Vote(int p, int t) {\n        person = p;\n        time = t;\n    }\n}"
      ]
    },
    {
      "number": 187,
      "question": "Can you solve this real interview question? Cat and Mouse - A game on an undirected graph is played by two players, Mouse and Cat, who alternate turns.\n\nThe graph is given as follows: graph[a] is a list of all nodes b such that ab is an edge of the graph.\n\nThe mouse starts at node 1 and goes first, the cat starts at node 2 and goes second, and there is a hole at node 0.\n\nDuring each player's turn, they must travel along one edge of the graph that meets where they are.  For example, if the Mouse is at node 1, it must travel to any node in graph[1].\n\nAdditionally, it is not allowed for the Cat to travel to the Hole (node 0.)\n\nThen, the game can end in three ways:\n\n * If ever the Cat occupies the same node as the Mouse, the Cat wins.\n * If ever the Mouse reaches the Hole, the Mouse wins.\n * If ever a position is repeated (i.e., the players are in the same position as a previous turn, and it is the same player's turn to move), the game is a draw.\n\nGiven a graph, and assuming both players play optimally, return\n\n * 1 if the mouse wins the game,\n * 2 if the cat wins the game, or\n * 0 if the game is a draw.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/11/17/cat1.jpg]\n\n\nInput: graph = [[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]\nOutput: 0\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/11/17/cat2.jpg]\n\n\nInput: graph = [[1,3],[0],[3],[0,2]]\nOutput: 1\n\n\n \n\nConstraints:\n\n * 3 <= graph.length <= 50\n * 1 <= graph[i].length < graph.length\n * 0 <= graph[i][j] < graph.length\n * graph[i][j] != i\n * graph[i] is unique.\n * The mouse and the cat can always move. ",
      "code": "class Solution {\npublic:\n    int catMouseGame(vector<vector<int>>& graph) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int catMouseGame(int[][] graph) {\n        int N = graph.length;\n        final int DRAW = 0, MOUSE = 1, CAT = 2;\n\n        int[][][] color = new int[50][50][3];\n        int[][][] degree = new int[50][50][3];\n\n        // degree[node] : the number of neutral children of this node\n        for (int m = 0; m < N; ++m)\n            for (int c = 0; c < N; ++c) {\n                degree[m][c][1] = graph[m].length;\n                degree[m][c][2] = graph[c].length;\n                for (int x: graph[c]) if (x == 0) {\n                    degree[m][c][2]--;\n                    break;\n                }\n            }\n\n        // enqueued : all nodes that are colored\n        Queue<int[]> queue = new LinkedList();\n        for (int i = 0; i < N; ++i)\n            for (int t = 1; t <= 2; ++t) {\n                color[0][i][t] = MOUSE;\n                queue.add(new int[]{0, i, t, MOUSE});\n                if (i > 0) {\n                    color[i][i][t] = CAT;\n                    queue.add(new int[]{i, i, t, CAT});\n                }\n            }\n\n        // percolate\n        while (!queue.isEmpty()) {\n            // for nodes that are colored :\n            int[] node = queue.remove();\n            int i = node[0], j = node[1], t = node[2], c = node[3];\n            // for every parent of this node i, j, t :\n            for (int[] parent: parents(graph, i, j, t)) {\n                int i2 = parent[0], j2 = parent[1], t2 = parent[2];\n                // if this parent is not colored :\n                if (color[i2][j2][t2] == DRAW) {\n                    // if the parent can make a winning move (ie. mouse to MOUSE), do so\n                    if (t2 == c) {\n                        color[i2][j2][t2] = c;\n                        queue.add(new int[]{i2, j2, t2, c});\n                    } else {\n                        // else, this parent has degree[parent]--, and enqueue\n                        // if all children of this parent are colored as losing moves\n                        degree[i2][j2][t2]--;\n                        if (degree[i2][j2][t2] == 0) {\n                            color[i2][j2][t2] = 3 - t2;\n                            queue.add(new int[]{i2, j2, t2, 3 - t2});\n                        }\n                    }\n                }\n            }\n        }\n\n        return color[1][2][1];\n    }\n\n    // What nodes could play their turn to\n    // arrive at node (m, c, t) ?\n    public List<int[]> parents(int[][] graph, int m, int c, int t) {\n        List<int[]> ans = new ArrayList();\n        if (t == 2) {\n            for (int m2: graph[m])\n                ans.add(new int[]{m2, c, 3-t});\n        } else {\n            for (int c2: graph[c]) if (c2 > 0)\n                ans.add(new int[]{m, c2, 3-t});\n        }\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 188,
      "question": "Can you solve this real interview question? X of a Kind in a Deck of Cards - You are given an integer array deck where deck[i] represents the number written on the ith card.\n\nPartition the cards into one or more groups such that:\n\n * Each group has exactly x cards where x > 1, and\n * All the cards in one group have the same integer written on them.\n\nReturn true if such partition is possible, or false otherwise.\n\n \n\nExample 1:\n\n\nInput: deck = [1,2,3,4,4,3,2,1]\nOutput: true\nExplanation: Possible partition [1,1],[2,2],[3,3],[4,4].\n\n\nExample 2:\n\n\nInput: deck = [1,1,1,2,2,2,3,3]\nOutput: false\nExplanation: No possible partition.\n\n\n \n\nConstraints:\n\n * 1 <= deck.length <= 104\n * 0 <= deck[i] < 104",
      "code": "class Solution {\npublic:\n    bool hasGroupsSizeX(vector<int>& deck) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean hasGroupsSizeX(int[] deck) {\n        int N = deck.length;\n        int[] count = new int[10000];\n        for (int c: deck)\n            count[c]++;\n\n        List<Integer> values = new ArrayList();\n        for (int i = 0; i < 10000; ++i)\n            if (count[i] > 0)\n                values.add(count[i]);\n\n        search: for (int X = 2; X <= N; ++X)\n            if (N % X == 0) {\n                for (int v: values)\n                    if (v % X != 0)\n                        continue search;\n                return true;\n            }\n\n        return false;\n    }\n}",
        "class Solution {\n    public boolean hasGroupsSizeX(int[] deck) {\n        int[] count = new int[10000];\n        for (int c: deck)\n            count[c]++;\n\n        int g = -1;\n        for (int i = 0; i < 10000; ++i)\n            if (count[i] > 0) {\n                if (g == -1)\n                    g = count[i];\n                else\n                    g = gcd(g, count[i]);\n            }\n\n        return g >= 2;\n    }\n\n    public int gcd(int x, int y) {\n        return x == 0 ? y : gcd(y%x, x);\n    }\n}"
      ]
    },
    {
      "number": 189,
      "question": "Can you solve this real interview question? Partition Array into Disjoint Intervals - Given an integer array nums, partition it into two (contiguous) subarrays left and right so that:\n\n * Every element in left is less than or equal to every element in right.\n * left and right are non-empty.\n * left has the smallest possible size.\n\nReturn the length of left after such a partitioning.\n\nTest cases are generated such that partitioning exists.\n\n \n\nExample 1:\n\n\nInput: nums = [5,0,3,8,6]\nOutput: 3\nExplanation: left = [5,0,3], right = [8,6]\n\n\nExample 2:\n\n\nInput: nums = [1,1,1,0,6,12]\nOutput: 4\nExplanation: left = [1,1,1,0], right = [6,12]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 105\n * 0 <= nums[i] <= 106\n * There is at least one valid answer for the given input.",
      "code": "class Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int N = nums.size();\n        int maxLeft[N];\n        int minRight[N];\n        \n        maxLeft[0] = nums[0];\n        minRight[N - 1] = nums[N - 1];\n        \n        for (int i = 1; i < N; ++i) {\n            maxLeft[i] = max(maxLeft[i - 1], nums[i]);\n        }\n        \n        for (int i = N - 2; i >= 0; --i) {\n            minRight[i] = min(minRight[i + 1], nums[i]);\n        }\n        \n        for (int i = 1; i < N; ++i) {\n            if (maxLeft[i - 1] <= minRight[i]) {\n                return i;\n            } \n        }\n        // In case there is no solution, we'll return -1\n        return -1;\n    }\n}; ",
        "class Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int N = nums.size();\n        int minRight[N];\n        minRight[N - 1] = nums[N - 1];\n        \n        for (int i = N - 2; i >= 0; --i) {\n            minRight[i] = min(minRight[i + 1], nums[i]);\n        }\n        \n        int currMax = nums[0];\n        for (int i = 1; i < N; ++i) {\n            currMax = max(currMax, nums[i - 1]);\n            if (currMax <= minRight[i]) {\n                return i;\n            } \n        }\n        // In case there is no solution, we'll return -1\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    int partitionDisjoint(vector<int>& nums) {\n        int currMax = nums[0];\n        int possibleMax = nums[0];\n        int length = 1;\n        \n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] < currMax) {\n                length = i + 1;\n                currMax = possibleMax;\n            } else {\n                possibleMax = max(possibleMax, nums[i]);\n            }\n        }\n        \n        return length;\n    }\n};"
      ]
    },
    {
      "number": 190,
      "question": "Can you solve this real interview question? Word Subsets - You are given two string arrays words1 and words2.\n\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\n\n * For example, \"wrr\" is a subset of \"warrior\" but is not a subset of \"world\".\n\nA string a from words1 is universal if for every string b in words2, b is a subset of a.\n\nReturn an array of all the universal strings in words1. You may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"e\",\"o\"]\nOutput: [\"facebook\",\"google\",\"leetcode\"]\n\n\nExample 2:\n\n\nInput: words1 = [\"amazon\",\"apple\",\"facebook\",\"google\",\"leetcode\"], words2 = [\"l\",\"e\"]\nOutput: [\"apple\",\"google\",\"leetcode\"]\n\n\n \n\nConstraints:\n\n * 1 <= words1.length, words2.length <= 104\n * 1 <= words1[i].length, words2[i].length <= 10\n * words1[i] and words2[i] consist only of lowercase English letters.\n * All the strings of words1 are unique.",
      "code": "class Solution {\npublic:\n    vector<string> wordSubsets(vector<string>& words1, \nvector<string>& words2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<String> wordSubsets(String[] A, String[] B) {\n        int[] bmax = count(\"\");\n        for (String b: B) {\n            int[] bCount = count(b);\n            for (int i = 0; i < 26; ++i)\n                bmax[i] = Math.max(bmax[i], bCount[i]);\n        }\n\n        List<String> ans = new ArrayList();\n        search: for (String a: A) {\n            int[] aCount = count(a);\n            for (int i = 0; i < 26; ++i)\n                if (aCount[i] < bmax[i])\n                    continue search;\n            ans.add(a);\n        }\n\n        return ans;\n    }\n\n    public int[] count(String S) {\n        int[] ans = new int[26];\n        for (char c: S.toCharArray())\n            ans[c - 'a']++;\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 191,
      "question": "Can you solve this real interview question? Reverse Only Letters - Given a string s, reverse the string according to the following rules:\n\n * All the characters that are not English letters remain in the same position.\n * All the English letters (lowercase or uppercase) should be reversed.\n\nReturn s after reversing it.\n\n \n\nExample 1:\n\nInput: s = \"ab-cd\"\nOutput: \"dc-ba\"\n\n\nExample 2:\n\nInput: s = \"a-bC-dEf-ghIj\"\nOutput: \"j-Ih-gfE-dCba\"\n\n\nExample 3:\n\nInput: s = \"Test1ng-Leet=code-Q!\"\nOutput: \"Qedo1ct-eeLg=ntse-T!\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 100\n * s consists of characters with ASCII values in the range [33, 122].\n * s does not contain '\\\"' or '\\\\'.",
      "code": "class Solution {\npublic:\n    string reverseOnlyLetters(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String reverseOnlyLetters(String S) {\n        Stack<Character> letters = new Stack();\n        for (char c: S.toCharArray())\n            if (Character.isLetter(c))\n                letters.push(c);\n\n        StringBuilder ans = new StringBuilder();\n        for (char c: S.toCharArray()) {\n            if (Character.isLetter(c))\n                ans.append(letters.pop());\n            else\n                ans.append(c);\n        }\n\n        return ans.toString();\n    }\n}",
        "class Solution {\n    public String reverseOnlyLetters(String S) {\n        StringBuilder ans = new StringBuilder();\n        int j = S.length() - 1;\n        for (int i = 0; i < S.length(); ++i) {\n            if (Character.isLetter(S.charAt(i))) {\n                while (!Character.isLetter(S.charAt(j)))\n                    j--;\n                ans.append(S.charAt(j--));\n            } else {\n                ans.append(S.charAt(i));\n            }\n        }\n\n        return ans.toString();\n    }\n}"
      ]
    },
    {
      "number": 192,
      "question": "Can you solve this real interview question? Maximum Sum Circular Subarray - Given a circular integer array nums of length n, return the maximum possible sum of a non-empty subarray of nums.\n\nA circular array means the end of the array connects to the beginning of the array. Formally, the next element of nums[i] is nums[(i + 1) % n] and the previous element of nums[i] is nums[(i - 1 + n) % n].\n\nA subarray may only include each element of the fixed buffer nums at most once. Formally, for a subarray nums[i], nums[i + 1], ..., nums[j], there does not exist i <= k1, k2 <= j with k1 % n == k2 % n.\n\n \n\nExample 1:\n\n\nInput: nums = [1,-2,3,-2]\nOutput: 3\nExplanation: Subarray [3] has maximum sum 3.\n\n\nExample 2:\n\n\nInput: nums = [5,-3,5]\nOutput: 10\nExplanation: Subarray [5,5] has maximum sum 5 + 5 = 10.\n\n\nExample 3:\n\n\nInput: nums = [-3,-2,-3]\nOutput: -2\nExplanation: Subarray [-2] has maximum sum -2.\n\n\n \n\nConstraints:\n\n * n == nums.length\n * 1 <= n <= 3 * 104\n * -3 * 104 <= nums[i] <= 3 * 104",
      "code": "class Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "// This is the solution to Maximum Subarray, which is the maximum \"normal sum\"\n// The algorithm is known as Kadane's algorithm\n\nint maxSubArray(vector<int>& nums) {\n    int currMax = nums[0];\n    int maxSum = nums[0];\n\n    for (int i = 1; i < nums.size(); i++) {\n        int num = nums[i];\n        currMax = max(num, currMax + num);\n        maxSum = max(maxSum, currMax);\n    }\n\n    return maxSum;\n}",
        "class Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        const int n = nums.size();\n        vector<int> rightMax(n);\n        rightMax[n - 1] = nums[n - 1];\n        int suffixSum = nums[n - 1];\n\n        for (int i = n - 2; i >= 0; --i) {\n            suffixSum += nums[i];\n            rightMax[i] = max(rightMax[i + 1], suffixSum);\n        }\n\n        int maxSum = nums[0];\n        int specialSum = nums[0];\n        int curMax = 0;\n        int prefixSum = 0;\n        for (int i = 0; i < n; ++i) {\n            // This is Kadane's algorithm.\n            curMax = max(curMax, 0) + nums[i];\n            maxSum = max(maxSum, curMax);\n\n            prefixSum += nums[i];\n            if (i + 1 < n) {\n                specialSum = max(specialSum, prefixSum + rightMax[i + 1]);\n            }\n        }\n\n        return max(maxSum, specialSum);\n    }\n};",
        "class Solution {\npublic:\n    int maxSubarraySumCircular(vector<int>& nums) {\n        int curMax = 0;\n        int curMin = 0;\n        int maxSum = nums[0];\n        int minSum = nums[0];\n        int totalSum = 0;\n        \n        for (int num: nums) {\n            // Normal Kadane's\n            curMax = max(curMax, 0) + num;\n            maxSum = max(maxSum, curMax);\n            \n            // Kadane's but with min to find minimum subarray\n            curMin = min(curMin, 0) + num;\n            minSum = min(minSum, curMin);\n            \n            totalSum += num;  \n        }\n\n        if (totalSum == minSum) {\n            return maxSum;\n        }\n        \n        return max(maxSum, totalSum - minSum);\n    }\n};"
      ]
    },
    {
      "number": 193,
      "question": "Can you solve this real interview question? Complete Binary Tree Inserter - A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\n\nDesign an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\n\nImplement the CBTInserter class:\n\n * CBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree.\n * int insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode.\n * TreeNode get_root() Returns the root node of the tree.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/08/03/lc-treeinsert.jpg]\n\n\nInput\n[\"CBTInserter\", \"insert\", \"insert\", \"get_root\"]\n[[[1, 2]], [3], [4], []]\nOutput\n[null, 1, 2, [1, 2, 3, 4]]\n\nExplanation\nCBTInserter cBTInserter = new CBTInserter([1, 2]);\ncBTInserter.insert(3);  // return 1\ncBTInserter.insert(4);  // return 2\ncBTInserter.get_root(); // return [1, 2, 3, 4]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree will be in the range [1, 1000].\n * 0 <= Node.val <= 5000\n * root is a complete binary tree.\n * 0 <= val <= 5000\n * At most 104 calls will be made to insert and get_root.",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass CBTInserter {\npublic:\n    CBTInserter(TreeNode* root) {\n        \n    }\n    \n    int insert(int val) {\n        \n    }\n    \n    TreeNode* get_root() {\n        ",
      "solution": [
        "class CBTInserter {\n    TreeNode root;\n    Deque<TreeNode> deque;\n    public CBTInserter(TreeNode root) {\n        this.root = root;\n        deque = new LinkedList();\n        Queue<TreeNode> queue = new LinkedList();\n        queue.offer(root);\n\n        // BFS to populate deque\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node.left == null || node.right == null)\n                deque.offerLast(node);\n            if (node.left != null)\n                queue.offer(node.left);\n            if (node.right != null)\n                queue.offer(node.right);\n        }\n    }\n\n    public int insert(int v) {\n        TreeNode node = deque.peekFirst();\n        deque.offerLast(new TreeNode(v));\n        if (node.left == null)\n            node.left = deque.peekLast();\n        else {\n            node.right = deque.peekLast();\n            deque.pollFirst();\n        }\n\n        return node.val;\n    }\n\n    public TreeNode get_root() {\n        return root;\n    }\n}"
      ]
    },
    {
      "number": 194,
      "question": "Can you solve this real interview question? Number of Music Playlists - Your music player contains n different songs. You want to listen to goal songs (not necessarily different) during your trip. To avoid boredom, you will create a playlist so that:\n\n * Every song is played at least once.\n * A song can only be played again only if k other songs have been played.\n\nGiven n, goal, and k, return the number of possible playlists that you can create. Since the answer can be very large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: n = 3, goal = 3, k = 1\nOutput: 6\nExplanation: There are 6 possible playlists: [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\n\nExample 2:\n\n\nInput: n = 2, goal = 3, k = 0\nOutput: 6\nExplanation: There are 6 possible playlists: [1, 1, 2], [1, 2, 1], [2, 1, 1], [2, 2, 1], [2, 1, 2], and [1, 2, 2].\n\n\nExample 3:\n\n\nInput: n = 2, goal = 3, k = 1\nOutput: 2\nExplanation: There are 2 possible playlists: [1, 2, 1] and [2, 1, 2].\n\n\n \n\nConstraints:\n\n * 0 <= k < n <= goal <= 100",
      "code": "class Solution {\npublic:\n    int numMusicPlaylists(int n, int goal, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int numMusicPlaylists(int n, int goal, int k) {\n        const int MOD = 1e9 + 7;\n\n        // Initialize the DP table\n        vector<vector<long>> dp(goal + 1, vector<long>(n + 1, 0));\n        dp[0][0] = 1;\n\n        for (int i = 1; i <= goal; i++) {\n            for (int j = 1; j <= min(i, n); j++) {\n                // The i-th song is a new song\n                dp[i][j] = dp[i - 1][j - 1] * (n - j + 1) % MOD;\n                // The i-th song is a song we have played before\n                if (j > k) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j] * (j - k)) % MOD;\n                }\n            }\n        }\n\n        return dp[goal][n];\n    }\n};",
        "class Solution {\npublic:\n    int numMusicPlaylists(int n, int goal, int k) {\n        const int MOD = 1e9 + 7;\n        vector dp(goal + 1, vector<long>(n + 1, -1));\n\n        function<long(int, int)> numberOfPlaylists = [&](int i, int j) -> long {\n            // Base cases\n            if (i == 0 && j == 0) {\n                return 1LL;\n            }\n            if (i == 0 || j == 0) {\n                return 0LL;\n            }\n            if (dp[i][j] != -1) {\n                return dp[i][j];\n            }\n            // DP transition: add a new song or replay an old one\n            dp[i][j] = (numberOfPlaylists(i - 1, j - 1) * (n - j + 1)) % MOD;\n            if (j > k) {\n                dp[i][j] += (numberOfPlaylists(i - 1, j) * (j - k)) % MOD;\n                dp[i][j] %= MOD;\n            }\n            return dp[i][j];\n        };\n\n        return numberOfPlaylists(goal, n);\n    }\n};",
        "#include <vector>\n\nclass Solution {\nprivate:\n    static const long long MOD = 1e9 + 7;\n    vector<long long> factorial;\n    vector<long long> invFactorial;\n\n    // Function to calculate power under modulo MOD\n    long long power(long long base, int exponent) {\n        long long result = 1;\n        // Loop until exponent is not zero\n        while (exponent > 0) {\n            // If exponent is odd, multiply result with base\n            if (exponent & 1) {\n                result = (result * base) % MOD;\n            }\n            // Divide the exponent by 2 and square the base\n            exponent >>= 1;\n            base = (base * base) % MOD;\n        }\n        return result;\n    }\n\n    // Function to pre-calculate factorials and inverse factorials\n    void precalculateFactorials(int n) {\n        factorial.resize(n + 1);\n        invFactorial.resize(n + 1);\n        factorial[0] = invFactorial[0] = 1;\n        // Calculate factorials and inverse factorials for each number up to 'n'\n        for (int i = 1; i <= n; i++) {\n            factorial[i] = (factorial[i - 1] * i) % MOD;\n            // Inverse factorial calculated using Fermat's Little Theorem\n            invFactorial[i] = power(factorial[i], MOD - 2);\n        }\n    }\n\npublic:\n    int numMusicPlaylists(int n, int goal, int k) {\n        // Pre-calculate factorials and inverse factorials\n        precalculateFactorials(n);\n        // Initialize variables for calculation\n        int sign = 1;\n        long long answer = 0;\n        // Loop from 'n' down to 'k'\n        for (int i = n; i >= k; i--) {\n            // Calculate temporary result for this iteration\n            long long temp = power(i - k, goal - k);\n            temp = (temp * invFactorial[n - i]) % MOD;\n            temp = (temp * invFactorial[i - k]) % MOD;\n            // Add or subtract temporary result to/from answer\n            answer = (answer + sign * temp + MOD) % MOD;\n            // Flip sign for next iteration\n            sign *= -1;\n        }\n        // Final result is n! * answer, all under modulo\n        return (factorial[n] * answer) % MOD;\n    }\n};"
      ]
    },
    {
      "number": 195,
      "question": "Can you solve this real interview question? Minimum Add to Make Parentheses Valid - A parentheses string is valid if and only if:\n\n * It is the empty string,\n * It can be written as AB (A concatenated with B), where A and B are valid strings, or\n * It can be written as (A), where A is a valid string.\n\nYou are given a parentheses string s. In one move, you can insert a parenthesis at any position of the string.\n\n * For example, if s = \"()))\", you can insert an opening parenthesis to be \"(()))\" or a closing parenthesis to be \"())))\".\n\nReturn the minimum number of moves required to make s valid.\n\n \n\nExample 1:\n\n\nInput: s = \"())\"\nOutput: 1\n\n\nExample 2:\n\n\nInput: s = \"(((\"\nOutput: 3\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s[i] is either '(' or ')'.",
      "code": "class Solution {\npublic:\n    int minAddToMakeValid(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minAddToMakeValid(String S) {\n        int ans = 0, bal = 0;\n        for (int i = 0; i < S.length(); ++i) {\n            bal += S.charAt(i) == '(' ? 1 : -1;\n            // It is guaranteed bal >= -1\n            if (bal == -1) {\n                ans++;\n                bal++;\n            }\n        }\n\n        return ans + bal;\n    }\n}"
      ]
    },
    {
      "number": 196,
      "question": "Can you solve this real interview question? Minimize Malware Spread - You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\n\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. We will remove exactly one node from initial.\n\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\nNote that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.\n\n \n\nExample 1:\n\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\n\nExample 2:\n\nInput: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]\nOutput: 0\n\n\nExample 3:\n\nInput: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]\nOutput: 1\n\n\n \n\nConstraints:\n\n * n == graph.length\n * n == graph[i].length\n * 2 <= n <= 300\n * graph[i][j] is 0 or 1.\n * graph[i][j] == graph[j][i]\n * graph[i][i] == 1\n * 1 <= initial.length <= n\n * 0 <= initial[i] <= n - 1\n * All the integers in initial are unique.",
      "code": "class Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph, \nvector<int>& initial) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        // 1. Color each component.\n        // colors[node] = the color of this node.\n\n        int N = graph.length;\n        int[] colors = new int[N];\n        Arrays.fill(colors, -1);\n        int C = 0;\n\n        for (int node = 0; node < N; ++node)\n            if (colors[node] == -1)\n                dfs(graph, colors, node, C++);\n\n        // 2. Size of each color.\n        int[] size = new int[C];\n        for (int color: colors)\n            size[color]++;\n\n        // 3. Find unique colors.\n        int[] colorCount = new int[C];\n        for (int node: initial)\n            colorCount[colors[node]]++;\n\n        // 4. Answer\n        int ans = Integer.MAX_VALUE;\n        for (int node: initial) {\n            int c = colors[node];\n            if (colorCount[c] == 1) {\n                if (ans == Integer.MAX_VALUE)\n                    ans = node;\n                else if (size[c] > size[colors[ans]])\n                    ans = node;\n                else if (size[c] == size[colors[ans]] && node < ans)\n                    ans = node;\n            }\n        }\n\n        if (ans == Integer.MAX_VALUE)\n            for (int node: initial)\n                ans = Math.min(ans, node);\n\n        return ans;\n    }\n\n    public void dfs(int[][] graph, int[] colors, int node, int color) {\n        colors[node] = color;\n        for (int nei = 0; nei < graph.length; ++nei)\n            if (graph[node][nei] == 1 && colors[nei] == -1)\n                dfs(graph, colors, nei, color);\n    }\n}",
        "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n        for (int i = 0; i < N; ++i)\n            for (int j = i+1; j < N; ++j)\n                if (graph[i][j] == 1)\n                    dsu.union(i, j);\n\n        int[] count = new int[N];\n        for (int node: initial)\n            count[dsu.find(node)]++;\n\n        int ans = -1, ansSize = -1;\n        for (int node: initial) {\n            int root = dsu.find(node);\n            if (count[root] == 1) {  // unique color\n                int rootSize = dsu.size(root);\n                if (rootSize > ansSize) {\n                    ansSize = rootSize;\n                    ans = node;\n                } else if (rootSize == ansSize && node < ans) {\n                    ansSize = rootSize;\n                    ans = node;\n                }\n            }\n        }\n\n        if (ans == -1) {\n            ans = Integer.MAX_VALUE;\n            for (int node: initial)\n                ans = Math.min(ans, node);\n        }\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}"
      ]
    },
    {
      "number": 197,
      "question": "Can you solve this real interview question? Minimize Malware Spread II - You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly connected to the jth node if graph[i][j] == 1.\n\nSome nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more nodes can be infected in this manner.\n\nSuppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops.\n\nWe will remove exactly one node from initial, completely removing it and any connections from this node to any other node.\n\nReturn the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.\n\n \n\nExample 1:\n\nInput: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nOutput: 0\n\n\nExample 2:\n\nInput: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]\nOutput: 1\n\n\nExample 3:\n\nInput: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]\nOutput: 1\n\n\n \n\nConstraints:\n\n * n == graph.length\n * n == graph[i].length\n * 2 <= n <= 300\n * graph[i][j] is 0 or 1.\n * graph[i][j] == graph[j][i]\n * graph[i][i] == 1\n * 1 <= initial.length < n\n * 0 <= initial[i] <= n - 1\n * All the integers in initial are unique.",
      "code": "class Solution {\npublic:\n    int minMalwareSpread(vector<vector<int>>& graph, \nvector<int>& initial) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial)\n            clean[x] = 0;\n\n        // For each node u in initial, dfs to find\n        // 'seen': all nodes not in initial that it can reach.\n        ArrayList<Integer>[] infectedBy = new ArrayList[N];\n        for (int i = 0; i < N; ++i)\n            infectedBy[i] = new ArrayList();\n\n        for (int u: initial) {\n            Set<Integer> seen = new HashSet();\n            dfs(graph, clean, u, seen);\n            for (int v: seen)\n                infectedBy[v].add(u);\n        }\n\n        // For each node u in initial, for every v not in initial\n        // that is uniquely infected by u, add 1 to the contribution for u.\n        int[] contribution = new int[N];\n        for (int v = 0; v < N; ++v)\n            if (infectedBy[v].size() == 1)\n                contribution[infectedBy[v].get(0)]++;\n\n        // Take the best answer.\n        Arrays.sort(initial);\n        int ans = initial[0], ansSize = -1;\n        for (int u: initial) {\n            int score = contribution[u];\n            if (score > ansSize || score == ansSize && u < ans) {\n                ans = u;\n                ansSize = score;\n            }\n        }\n        return ans;\n    }\n\n    public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {\n        for (int v = 0; v < graph.length; ++v)\n            if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {\n                seen.add(v);\n                dfs(graph, clean, v, seen);\n            }\n    }\n}",
        "class Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        int N = graph.length;\n        DSU dsu = new DSU(N);\n\n        // clean[u] == 1 if its a node in the graph not in initial.\n        int[] clean = new int[N];\n        Arrays.fill(clean, 1);\n        for (int x: initial) clean[x] = 0;\n\n        for (int u = 0; u < N; ++u) if (clean[u] == 1)\n            for (int v = 0; v < N; ++v) if (clean[v] == 1)\n                if (graph[u][v] == 1)\n                    dsu.union(u, v);\n\n        // dsu now represents the components of the graph without\n        // any nodes from initial.  Let's call this graph G.\n        int[] count = new int[N];\n        Map<Integer, Set<Integer>> nodeToCompo = new HashMap();\n        for (int u: initial) {\n            Set<Integer> components = new HashSet();\n            for (int v = 0; v < N; ++v) if (clean[v] == 1) {\n                if (graph[u][v] == 1)\n                    components.add(dsu.find(v));\n            }\n\n            nodeToCompo.put(u, components);\n            for (int c: components)\n                count[c]++;\n        }\n\n        // For each node u in initial, nodeToCompo.get(u)\n        // now has every component from G that u neighbors.\n\n        int ans = -1, ansSize = -1;\n        for (int u: nodeToCompo.keySet()) {\n            Set<Integer> components = nodeToCompo.get(u);\n            int score = 0;\n            for (int c: components)\n                if (count[c] == 1) // uniquely infected\n                    score += dsu.size(c);\n\n            if (score > ansSize || score == ansSize && u < ans) {\n                ansSize = score;\n                ans = u;\n            }\n        }\n\n        return ans;\n    }\n}\n\n\nclass DSU {\n    int[] p, sz;\n\n    DSU(int N) {\n        p = new int[N];\n        for (int x = 0; x < N; ++x)\n            p[x] = x;\n\n        sz = new int[N];\n        Arrays.fill(sz, 1);\n    }\n\n    public int find(int x) {\n        if (p[x] != x)\n            p[x] = find(p[x]);\n        return p[x];\n    }\n\n    public void union(int x, int y) {\n        int xr = find(x);\n        int yr = find(y);\n        p[xr] = yr;\n        sz[yr] += sz[xr];\n    }\n\n    public int size(int x) {\n        return sz[find(x)];\n    }\n}"
      ]
    },
    {
      "number": 198,
      "question": "Can you solve this real interview question? Binary Subarrays With Sum - Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\n\nA subarray is a contiguous part of the array.\n\n \n\nExample 1:\n\n\r\nInput: nums = [1,0,1,0,1], goal = 2\r\nOutput: 4\r\nExplanation: The 4 subarrays are bolded and underlined below:\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n[1,0,1,0,1]\r\n\n\nExample 2:\n\n\r\nInput: nums = [0,0,0,0,0], goal = 0\r\nOutput: 15\r\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 3 * 104\n * nums[i] is either 0 or 1.\n * 0 <= goal <= nums.length",
      "code": "class Solution {\npublic:\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int su = 0;\n        for (int x: A) su += x;\n\n        // indexes[i] = location of i-th one (1 indexed)\n        int[] indexes = new int[su + 2];\n        int t = 0;\n        indexes[t++] = -1;\n        for (int i = 0; i < A.length; ++i)\n            if (A[i] == 1)\n                indexes[t++] = i;\n        indexes[t] = A.length;\n\n        int ans = 0;\n        if (S == 0) {\n            for (int i = 0; i < indexes.length - 1; ++i) {\n                // w: number of zeros between consecutive ones\n                int w = indexes[i+1] - indexes[i] - 1;\n                ans += w * (w + 1) / 2;\n            }\n            return ans;\n        }\n\n        for (int i = 1; i < indexes.length - S; ++i) {\n            int j = i + S - 1;\n            int left = indexes[i] - indexes[i-1];\n            int right = indexes[j+1] - indexes[j];\n            ans += left * right;\n        }\n\n        return ans;\n    }\n}",
        "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int N = A.length;\n        int[] P = new int[N + 1];\n        for (int i = 0; i < N; ++i)\n            P[i+1] = P[i] + A[i];\n\n        Map<Integer, Integer> count = new HashMap();\n        int ans = 0;\n        for (int x: P) {\n            ans += count.getOrDefault(x, 0);\n            count.put(x+S, count.getOrDefault(x+S, 0) + 1);\n        }\n\n        return ans;\n    }\n}",
        "class Solution {\n    public int numSubarraysWithSum(int[] A, int S) {\n        int iLo = 0, iHi = 0;\n        int sumLo = 0, sumHi = 0;\n        int ans = 0;\n\n        for (int j = 0; j < A.length; ++j) {\n            // While sumLo is too big, iLo++\n            sumLo += A[j];\n            while (iLo < j && sumLo > S)\n                sumLo -= A[iLo++];\n\n            // While sumHi is too big, or equal and we can move, iHi++\n            sumHi += A[j];\n            while (iHi < j && (sumHi > S || sumHi == S && A[iHi] == 0))\n                sumHi -= A[iHi++];\n\n            if (sumLo == S)\n                ans += iHi - iLo + 1;\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 199,
      "question": "Can you solve this real interview question? Beautiful Array - An array nums of length n is beautiful if:\n\n * nums is a permutation of the integers in the range [1, n].\n * For every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j].\n\nGiven the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\n\n \n\nExample 1:\n\nInput: n = 4\nOutput: [2,1,4,3]\n\n\nExample 2:\n\nInput: n = 5\nOutput: [3,1,2,5,4]\n\n\n \n\nConstraints:\n\n * 1 <= n <= 1000",
      "code": "class Solution {\npublic:\n    vector<int> beautifulArray(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    Map<Integer, int[]> memo;\n    public int[] beautifulArray(int N) {\n        memo = new HashMap();\n        return f(N);\n    }\n\n    public int[] f(int N) {\n        if (memo.containsKey(N))\n            return memo.get(N);\n\n        int[] ans = new int[N];\n        if (N == 1) {\n            ans[0] = 1;\n        } else {\n            int t = 0;\n            for (int x: f((N+1)/2))  // odds\n                ans[t++] = 2*x - 1;\n            for (int x: f(N/2))  // evens\n                ans[t++] = 2*x;\n        }\n        memo.put(N, ans);\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 200,
      "question": "Can you solve this real interview question? Shortest Bridge - You are given an n x n binary matrix grid where 1 represents land and 0 represents water.\n\nAn island is a 4-directionally connected group of 1's not connected to any other 1's. There are exactly two islands in grid.\n\nYou may change 0's to 1's to connect the two islands to form one island.\n\nReturn the smallest number of 0's you must flip to connect the two islands.\n\n \n\nExample 1:\n\n\nInput: grid = [[0,1],[1,0]]\nOutput: 1\n\n\nExample 2:\n\n\nInput: grid = [[0,1,0],[0,0,0],[0,0,1]]\nOutput: 2\n\n\nExample 3:\n\n\nInput: grid = [[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]\nOutput: 1\n\n\n \n\nConstraints:\n\n * n == grid.length == grid[i].length\n * 2 <= n <= 100\n * grid[i][j] is either 0 or 1.\n * There are exactly two islands in grid.",
      "code": "class Solution {\npublic:\n    int shortestBridge(vector<vector<int>>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    private List<int[]> bfsQueue;\n\n    // Recursively check the neighboring land cell of current cell grid[x][y] and add all\n    // land cells of island A to bfsQueue.\n    private void dfs(int[][] grid, int x, int y, int n) {\n        grid[x][y] = 2;\n        bfsQueue.add(new int[]{x, y});\n        for (int[] pair : new int[][]{{x + 1, y}, {x - 1, y}, {x, y + 1}, {x, y - 1}}) {\n            int curX = pair[0], curY = pair[1];\n            if (0 <= curX && curX < n && 0 <= curY && curY < n && grid[curX][curY] == 1) {\n                dfs(grid, curX, curY, n);\n            }\n        }\n    }\n    \n    // Find any land cell, and we treat it as a cell of island A.\n    public int shortestBridge(int[][] grid) {    \n        int n = grid.length;\n        int firstX = -1, firstY = -1;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    firstX = i;\n                    firstY = j;\n                    break;\n                }\n            }\n        }\n        \n        // Add all land cells of island A to bfsQueue.\n        bfsQueue = new ArrayList<>();\n        dfs(grid, firstX, firstY, n);\n        \n        int distance = 0;\n        while (!bfsQueue.isEmpty()) {\n            List<int[]> newBfs = new ArrayList<>();\n            for (int[] pair : bfsQueue) {\n                int x = pair[0], y = pair[1];\n                for (int[] nextPair : new int[][]{{x + 1, y}, {x - 1, y}, {x, y + 1}, {x, y - 1}}) {\n                    int curX = nextPair[0], curY = nextPair[1];\n                    if (0 <= curX && curX < n && 0 <= curY && curY < n) {\n                        if (grid[curX][curY] == 1) {\n                            return distance;\n                        } else if (grid[curX][curY] == 0) {\n                            newBfs.add(nextPair);\n                            grid[curX][curY] = -1;\n                        }\n                    }\n                }\n            }\n\n            // Once we finish one round without finding land cells of island B, we will\n            // start the next round on all water cells that are 1 cell further away from\n            // island A and increment the distance by 1.\n            bfsQueue = newBfs;\n            distance++;\n        }\n        \n        return distance;\n    }   \n}",
        "class Solution {\n    public int shortestBridge(int[][] grid) {\n        int n = grid.length;\n        int firstX = -1, firstY = -1;\n        \n        // Find any land cell, and we treat it as a cell of island A.\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    firstX = i;\n                    firstY = j;\n                    break;\n                }\n            }\n        }\n\n        // bfsQueue for BFS on land cells of island A; secondBfsQueue for BFS on water cells.\n        List<int[]> bfsQueue = new ArrayList<>();\n        List<int[]> secondBfsQueue = new ArrayList<>();\n        bfsQueue.add(new int[]{firstX, firstY});\n        secondBfsQueue.add(new int[]{firstX, firstY});\n        grid[firstX][firstY] = 2;\n\n        // BFS for all land cells of island A and add them to secondBfsQueue.\n        while (!bfsQueue.isEmpty()) {\n            List<int[]> newBfs = new ArrayList<>();\n            for (int[] cell : bfsQueue) {\n                int x = cell[0];\n                int y = cell[1];\n                for (int[] next : new int[][]{{x + 1, y}, {x - 1, y}, {x, y + 1}, {x, y - 1}}) {\n                    int curX = next[0];\n                    int curY = next[1];\n                    if (curX >= 0 && curX < n && curY >= 0 && curY < n && grid[curX][curY] == 1) {\n                        newBfs.add(new int[]{curX, curY});\n                        secondBfsQueue.add(new int[]{curX, curY});\n                        grid[curX][curY] = 2;\n                    }\n                }\n            }\n            bfsQueue = newBfs;\n        }\n\n        int distance = 0;\n        while (!secondBfsQueue.isEmpty()) {\n            List<int[]> newBfs = new ArrayList<>();\n            for (int[] cell : secondBfsQueue) {\n                int x = cell[0];\n                int y = cell[1];\n                for (int[] next : new int[][]{{x + 1, y}, {x - 1, y}, {x, y + 1}, {x, y - 1}}) {\n                    int curX = next[0];\n                    int curY = next[1];\n                    if (curX >= 0 && curX < n && curY >= 0 && curY < n) {\n                        if (grid[curX][curY] == 1) {\n                            return distance;\n                        } else if (grid[curX][curY] == 0) {\n                            newBfs.add(new int[]{curX, curY});\n                            grid[curX][curY] = -1;\n                        }\n                    }\n                }\n            }\n\n            // Once we finish one round without finding land cells of island B, we will\n            // start the next round on all water cells that are 1 cell further away from\n            // island A and increment the distance by 1.\n            secondBfsQueue = newBfs;\n            distance++;\n        }\n        return distance;\n    }\n}"
      ]
    },
    {
      "number": 201,
      "question": "Can you solve this real interview question? Knight Dialer - The chess knight has a unique movement, it may move two squares vertically and one square horizontally, or two squares horizontally and one square vertically (with both forming the shape of an L). The possible movements of chess knight are shown in this diagaram:\n\nA chess knight can move as indicated in the chess diagram below:\n\n[https://assets.leetcode.com/uploads/2020/08/18/chess.jpg]\n\nWe have a chess knight and a phone pad as shown below, the knight can only stand on a numeric cell (i.e. blue cell).\n\n[https://assets.leetcode.com/uploads/2020/08/18/phone.jpg]\n\nGiven an integer n, return how many distinct phone numbers of length n we can dial.\n\nYou are allowed to place the knight on any numeric cell initially and then you should perform n - 1 jumps to dial a number of length n. All jumps should be valid knight jumps.\n\nAs the answer may be very large, return the answer modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: n = 1\nOutput: 10\nExplanation: We need to dial a number of length 1, so placing the knight over any numeric cell of the 10 cells is sufficient.\n\n\nExample 2:\n\n\nInput: n = 2\nOutput: 20\nExplanation: All the valid number we can dial are [04, 06, 16, 18, 27, 29, 34, 38, 40, 43, 49, 60, 61, 67, 72, 76, 81, 83, 92, 94]\n\n\nExample 3:\n\n\nInput: n = 3131\nOutput: 136006598\nExplanation: Please take care of the mod.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 5000",
      "code": "class Solution {\npublic:\n    int knightDialer(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> memo;\n    int n;\n    int MOD = 1e9 + 7;\n    vector<vector<int>> jumps = {\n        {4, 6},\n        {6, 8},\n        {7, 9},\n        {4, 8},\n        {3, 9, 0},\n        {},\n        {1, 7, 0},\n        {2, 6},\n        {1, 3},\n        {2, 4}\n    };\n    \n    int dp(int remain, int square) {\n        if (remain == 0) {\n            return 1;\n        }\n        \n        if (memo[remain][square] != 0) {\n            return memo[remain][square];\n        }\n        \n        int ans = 0;\n        for (int nextSquare : jumps[square]) {\n            ans = (ans + dp(remain - 1, nextSquare)) % MOD;\n        }\n        \n        memo[remain][square] = ans;\n        return ans;\n    }\n    \n    int knightDialer(int n) {\n        this->n = n;\n        memo = vector(n + 1, vector(10, 0));\n        int ans = 0;\n        for (int square = 0; square < 10; square++) {\n            ans = (ans + dp(n - 1, square)) % MOD;\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int knightDialer(int n) {\n        vector<vector<int>> jumps = {\n            {4, 6},\n            {6, 8},\n            {7, 9},\n            {4, 8},\n            {3, 9, 0},\n            {},\n            {1, 7, 0},\n            {2, 6},\n            {1, 3},\n            {2, 4}\n        };\n\n        int MOD = 1e9 + 7;\n        vector<vector<int>> dp(n, vector(10, 0));\n        for (int square = 0; square < 10; square++) {\n            dp[0][square] = 1;\n        }\n\n        for (int remain = 1; remain < n; remain++) {\n            for (int square = 0; square < 10; square++) {\n                int ans = 0;\n                for (int nextSquare : jumps[square]) {\n                    ans = (ans + dp[remain - 1][nextSquare]) % MOD;\n                }\n\n                dp[remain][square] = ans;\n            }\n        }\n\n        int ans = 0;\n        for (int square = 0; square < 10; square++) {\n            ans = (ans + dp[n - 1][square]) % MOD;\n        }\n\n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int knightDialer(int n) {\n        vector<vector<int>> jumps = {\n            {4, 6},\n            {6, 8},\n            {7, 9},\n            {4, 8},\n            {3, 9, 0},\n            {},\n            {1, 7, 0},\n            {2, 6},\n            {1, 3},\n            {2, 4}\n        };\n\n        int MOD = 1e9 + 7;\n        vector<int> dp(10, 0);\n        vector<int> prevDp(10, 1);\n\n        for (int remain = 1; remain < n; remain++) {\n            dp = vector(10, 0);\n            for (int square = 0; square < 10; square++) {\n                int ans = 0;\n                for (int nextSquare : jumps[square]) {\n                    ans = (ans + prevDp[nextSquare]) % MOD;\n                }\n\n                dp[square] = ans;\n            }\n            \n            prevDp = dp;\n        }\n\n        int ans = 0;\n        for (int square = 0; square < 10; square++) {\n            ans = (ans + prevDp[square]) % MOD;\n        }\n\n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int knightDialer(int n) {\n        if (n == 1) {\n            return 10;\n        }\n        \n        int A = 4;\n        int B = 2;\n        int C = 2;\n        int D = 1;\n        int MOD = 1e9 + 7;\n        \n        for (int i = 0; i < n - 1; i++) {\n            int tempA = A;\n            int tempB = B;\n            int tempC = C;\n            int tempD = D;\n            \n            A = ((2 * tempB) % MOD + (2 * tempC) % MOD) % MOD;\n            B = tempA;\n            C = (tempA + (2 * tempD) % MOD) % MOD;\n            D = tempC;\n        }\n        \n        int ans = (A + B) % MOD;\n        ans = (ans + C) % MOD;\n        return (ans + D) % MOD;\n    }\n};",
        "class Solution {\npublic:\n    int MOD = 1e9 + 7;\n    \n    int knightDialer(int n) {\n        if (n == 1) {\n            return 10;\n        }\n        \n        vector<vector<long>> A = {\n            {0, 0, 0, 0, 1, 0, 1, 0, 0, 0},\n            {0, 0, 0, 0, 0, 0, 1, 0, 1, 0},\n            {0, 0, 0, 0, 0, 0, 0, 1, 0, 1},\n            {0, 0, 0, 0, 1, 0, 0, 0, 1, 0},\n            {1, 0, 0, 1, 0, 0, 0, 0, 0, 1},\n            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},\n            {1, 1, 0, 0, 0, 0, 0, 1, 0, 0},\n            {0, 0, 1, 0, 0, 0, 1, 0, 0, 0},\n            {0, 1, 0, 1, 0, 0, 0, 0, 0, 0},\n            {0, 0, 1, 0, 1, 0, 0, 0, 0, 0}\n        };\n        \n        vector<vector<long>> v = {\n            {1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n        };\n        \n        n--;\n        while (n > 0) {\n            if ((n & 1) != 0) {\n                v = multiply(v, A);\n            }\n            \n            A = multiply(A, A);\n            n >>= 1;\n        }\n        \n        int ans = 0;\n        for (long num : v[0]) {\n            ans = (ans + num) % MOD;\n        }\n        \n        return ans;\n    }\n    \n    vector<vector<long>> multiply(vector<vector<long>>& A, vector<vector<long>>& B) {\n        vector<vector<long>> result(A.size(), vector<long>(B[0].size(), 0));\n        \n        for (int i = 0; i < A.size(); i++) {\n            for (int j = 0; j < B[0].size(); j++) {\n                for (int k = 0; k < B.size(); k++) {\n                    result[i][j] = (result[i][j] + A[i][k] * B[k][j]) % MOD;\n                }\n            }\n        }\n        \n        return result;\n    }\n};"
      ]
    },
    {
      "number": 202,
      "question": "Can you solve this real interview question? Stamping The Sequence - You are given two strings stamp and target. Initially, there is a string s of length target.length with all s[i] == '?'.\n\nIn one turn, you can place stamp over s and replace every letter in the s with the corresponding letter from stamp.\n\n * For example, if stamp = \"abc\" and target = \"abcba\", then s is \"?????\" initially. In one turn you can:\n   * place stamp at index 0 of s to obtain \"abc??\",\n   * place stamp at index 1 of s to obtain \"?abc?\", or\n   * place stamp at index 2 of s to obtain \"??abc\".\n   Note that stamp must be fully contained in the boundaries of s in order to stamp (i.e., you cannot place stamp at index 3 of s).\n\nWe want to convert s to target using at most 10 * target.length turns.\n\nReturn an array of the index of the left-most letter being stamped at each turn. If we cannot obtain target from s within 10 * target.length turns, return an empty array.\n\n \n\nExample 1:\n\n\nInput: stamp = \"abc\", target = \"ababc\"\nOutput: [0,2]\nExplanation: Initially s = \"?????\".\n- Place stamp at index 0 to get \"abc??\".\n- Place stamp at index 2 to get \"ababc\".\n[1,0,2] would also be accepted as an answer, as well as some other answers.\n\n\nExample 2:\n\n\nInput: stamp = \"abca\", target = \"aabcaca\"\nOutput: [3,0,1]\nExplanation: Initially s = \"???????\".\n- Place stamp at index 3 to get \"???abca\".\n- Place stamp at index 0 to get \"abcabca\".\n- Place stamp at index 1 to get \"aabcaca\".\n\n\n \n\nConstraints:\n\n * 1 <= stamp.length <= target.length <= 1000\n * stamp and target consist of lowercase English letters.",
      "code": "class Solution {\npublic:\n    vector<int> movesToStamp(string stamp, string target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] movesToStamp(String stamp, String target) {\n        int M = stamp.length(), N = target.length();\n        Queue<Integer> queue = new ArrayDeque();\n        boolean[] done = new boolean[N];\n        Stack<Integer> ans = new Stack();\n        List<Node> A = new ArrayList();\n\n        for (int i = 0; i <= N-M; ++i) {\n            // For each window [i, i+M), A[i] will contain\n            // info on what needs to change before we can\n            // reverse stamp at this window.\n\n            Set<Integer> made = new HashSet();\n            Set<Integer> todo = new HashSet();\n            for (int j = 0; j < M; ++j) {\n                if (target.charAt(i+j) == stamp.charAt(j))\n                    made.add(i+j);\n                else\n                    todo.add(i+j);\n            }\n\n            A.add(new Node(made, todo));\n\n            // If we can reverse stamp at i immediately,\n            // enqueue letters from this window.\n            if (todo.isEmpty()) {\n                ans.push(i);\n                for (int j = i; j < i + M; ++j) if (!done[j]) {\n                    queue.add(j);\n                    done[j] = true;\n                }\n            }\n        }\n\n        // For each enqueued letter (position),\n        while (!queue.isEmpty()) {\n            int i = queue.poll();\n\n            // For each window that is potentially affected,\n            // j: start of window\n            for (int j = Math.max(0, i-M+1); j <= Math.min(N-M, i); ++j) {\n                if (A.get(j).todo.contains(i)) {  // This window is affected\n                    A.get(j).todo.remove(i);\n                    if (A.get(j).todo.isEmpty()) {\n                        ans.push(j);\n                        for (int m: A.get(j).made) if (!done[m]) {\n                            queue.add(m);\n                            done[m] = true;\n                        }\n                    }\n                }\n            }\n        }\n\n        for (boolean b: done)\n            if (!b) return new int[0];\n\n        int[] ret = new int[ans.size()];\n        int t = 0;\n        while (!ans.isEmpty())\n            ret[t++] = ans.pop();\n\n        return ret;\n    }\n}\n\nclass Node {\n    Set<Integer> made, todo;\n    Node(Set<Integer> m, Set<Integer> t) {\n        made = m;\n        todo = t;\n    }\n}"
      ]
    },
    {
      "number": 203,
      "question": "Can you solve this real interview question? Reorder Data in Log Files - You are given an array of logs. Each log is a space-delimited string of words, where the first word is the identifier.\n\nThere are two types of logs:\n\n * Letter-logs: All words (except the identifier) consist of lowercase English letters.\n * Digit-logs: All words (except the identifier) consist of digits.\n\nReorder these logs so that:\n\n 1. The letter-logs come before all digit-logs.\n 2. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers.\n 3. The digit-logs maintain their relative ordering.\n\nReturn the final order of the logs.\n\n \n\nExample 1:\n\n\nInput: logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\nOutput: [\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\nExplanation:\nThe letter-log contents are all different, so their ordering is \"art can\", \"art zero\", \"own kit dig\".\nThe digit-logs have a relative order of \"dig1 8 1 5 1\", \"dig2 3 6\".\n\n\nExample 2:\n\n\nInput: logs = [\"a1 9 2 3 1\",\"g1 act car\",\"zo4 4 7\",\"ab1 off key dog\",\"a8 act zoo\"]\nOutput: [\"g1 act car\",\"a8 act zoo\",\"ab1 off key dog\",\"a1 9 2 3 1\",\"zo4 4 7\"]\n\n\n \n\nConstraints:\n\n * 1 <= logs.length <= 100\n * 3 <= logs[i].length <= 100\n * All the tokens of logs[i] are separated by a single space.\n * logs[i] is guaranteed to have an identifier and at least one word after the identifier.",
      "code": "class Solution {\npublic:\n    vector<string> reorderLogFiles(vector<string>& logs) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String[] reorderLogFiles(String[] logs) {\n\n        Comparator<String> myComp = new Comparator<String>() {\n            @Override\n            public int compare(String log1, String log2) {\n                // split each log into two parts: <identifier, content>\n                String[] split1 = log1.split(\" \", 2);\n                String[] split2 = log2.split(\" \", 2);\n\n                boolean isDigit1 = Character.isDigit(split1[1].charAt(0));\n                boolean isDigit2 = Character.isDigit(split2[1].charAt(0));\n\n                // case 1). both logs are letter-logs\n                if (!isDigit1 && !isDigit2) {\n                    // first compare the content\n                    int cmp = split1[1].compareTo(split2[1]);\n                    if (cmp != 0)\n                        return cmp;\n                    // logs of same content, compare the identifiers\n                    return split1[0].compareTo(split2[0]);\n                }\n\n                // case 2). one of logs is digit-log\n                if (!isDigit1 && isDigit2)\n                    // the letter-log comes before digit-logs\n                    return -1;\n                else if (isDigit1 && !isDigit2)\n                    return 1;\n                else\n                    // case 3). both logs are digit-log\n                    return 0;\n            }\n        };\n\n        Arrays.sort(logs, myComp);\n        return logs;\n    }\n}",
        "class Solution:\n    def reorderLogFiles(self, logs: List[str]) -> List[str]:\n\n        def get_key(log):\n            _id, rest = log.split(\" \", maxsplit=1)\n            return (0, rest, _id) if rest[0].isalpha() else (1, )\n\n        return sorted(logs, key=get_key)"
      ]
    },
    {
      "number": 204,
      "question": "Can you solve this real interview question? Minimum Area Rectangle - You are given an array of points in the X-Y plane points where points[i] = [xi, yi].\n\nReturn the minimum area of a rectangle formed from these points, with sides parallel to the X and Y axes. If there is not any such rectangle, return 0.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/08/03/rec1.JPG]\n\n\nInput: points = [[1,1],[1,3],[3,1],[3,3],[2,2]]\nOutput: 4\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/08/03/rec2.JPG]\n\n\nInput: points = [[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]\nOutput: 2\n\n\n \n\nConstraints:\n\n * 1 <= points.length <= 500\n * points[i].length == 2\n * 0 <= xi, yi <= 4 * 104\n * All the given points are unique.",
      "code": "class Solution {\npublic:\n    int minAreaRect(vector<vector<int>>& points) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minAreaRect(int[][] points) {\n        Map<Integer, List<Integer>> rows = new TreeMap();\n        for (int[] point: points) {\n            int x = point[0], y = point[1];\n            rows.computeIfAbsent(x, z-> new ArrayList()).add(y);\n        }\n\n        int ans = Integer.MAX_VALUE;\n        Map<Integer, Integer> lastx = new HashMap();\n        for (int x: rows.keySet()) {\n            List<Integer> row = rows.get(x);\n            Collections.sort(row);\n            for (int i = 0; i < row.size(); ++i)\n                for (int j = i+1; j < row.size(); ++j) {\n                    int y1 = row.get(i), y2 = row.get(j);\n                    int code = 40001 * y1 + y2;\n                    if (lastx.containsKey(code))\n                        ans = Math.min(ans, (x - lastx.get(code)) * (y2-y1));\n                    lastx.put(code, x);\n                }\n        }\n\n        return ans < Integer.MAX_VALUE ? ans : 0;\n    }\n}",
        "class Solution {\n    public int minAreaRect(int[][] points) {\n        Set<Integer> pointSet = new HashSet();\n        for (int[] point: points)\n            pointSet.add(40001 * point[0] + point[1]);\n\n        int ans = Integer.MAX_VALUE;\n        for (int i = 0; i < points.length; ++i)\n            for (int j = i+1; j < points.length; ++j) {\n                if (points[i][0] != points[j][0] && points[i][1] != points[j][1]) {\n                    if (pointSet.contains(40001 * points[i][0] + points[j][1]) &&\n                            pointSet.contains(40001 * points[j][0] + points[i][1])) {\n                        ans = Math.min(ans, Math.abs(points[j][0] - points[i][0]) *\n                                            Math.abs(points[j][1] - points[i][1]));\n                    }\n                }\n            }\n\n        return ans < Integer.MAX_VALUE ? ans : 0;\n    }\n}"
      ]
    },
    {
      "number": 205,
      "question": "Can you solve this real interview question? Distinct Subsequences II - Given a string s, return the number of distinct non-empty subsequences of s. Since the answer may be very large, return it modulo 109 + 7.\n\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not.\n\n \n\nExample 1:\n\n\nInput: s = \"abc\"\nOutput: 7\nExplanation: The 7 distinct subsequences are \"a\", \"b\", \"c\", \"ab\", \"ac\", \"bc\", and \"abc\".\n\n\nExample 2:\n\n\nInput: s = \"aba\"\nOutput: 6\nExplanation: The 6 distinct subsequences are \"a\", \"b\", \"ab\", \"aa\", \"ba\", and \"aba\".\n\n\nExample 3:\n\n\nInput: s = \"aaa\"\nOutput: 3\nExplanation: The 3 distinct subsequences are \"a\", \"aa\" and \"aaa\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 2000\n * s consists of lowercase English letters.",
      "code": "class Solution {\npublic:\n    int distinctSubseqII(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int distinctSubseqII(string s) {\n        const int N = s.length();\n        const int MOD = 1e9 + 7;\n        \n        vector<int> dp(N+1);\n        dp[0] = 1;\n        vector<int> last(26, -1);\n        \n        for(int i = 0; i < N; i++){\n            int x = s[i] - 'a';\n            dp[i+1] = dp[i] * 2 % MOD;\n            if(last[x] >= 0) // if this is the first occurence of ch\n                dp[i+1] -= dp[last[x]];\n            dp[i+1] %= MOD;\n            last[x] = i;\n        }\n        dp[N]--;\n        if(dp[N] < 0) dp[N] += MOD;\n        return dp[N];\n    }\n};"
      ]
    },
    {
      "number": 206,
      "question": "Can you solve this real interview question? DI String Match - A permutation perm of n + 1 integers of all the integers in the range [0, n] can be represented as a string s of length n where:\n\n * s[i] == 'I' if perm[i] < perm[i + 1], and\n * s[i] == 'D' if perm[i] > perm[i + 1].\n\nGiven a string s, reconstruct the permutation perm and return it. If there are multiple valid permutations perm, return any of them.\n\n \n\nExample 1:\n\nInput: s = \"IDID\"\nOutput: [0,4,1,3,2]\n\n\nExample 2:\n\nInput: s = \"III\"\nOutput: [0,1,2,3]\n\n\nExample 3:\n\nInput: s = \"DDI\"\nOutput: [3,2,0,1]\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s[i] is either 'I' or 'D'.",
      "code": "class Solution {\npublic:\n    vector<int> diStringMatch(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] diStringMatch(String S) {\n        int N = S.length();\n        int lo = 0, hi = N;\n        int[] ans = new int[N + 1];\n        for (int i = 0; i < N; ++i) {\n            if (S.charAt(i) == 'I')\n                ans[i] = lo++;\n            else\n                ans[i] = hi--;\n        }\n\n        ans[N] = lo;\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 207,
      "question": "Can you solve this real interview question? Find the Shortest Superstring - Given an array of strings words, return the smallest string that contains each string in words as a substring. If there are multiple valid strings of the smallest length, return any of them.\n\nYou may assume that no string in words is a substring of another string in words.\n\n \n\nExample 1:\n\n\nInput: words = [\"alex\",\"loves\",\"leetcode\"]\nOutput: \"alexlovesleetcode\"\nExplanation: All permutations of \"alex\",\"loves\",\"leetcode\" would also be accepted.\n\n\nExample 2:\n\n\nInput: words = [\"catg\",\"ctaagt\",\"gcta\",\"ttca\",\"atgcatc\"]\nOutput: \"gctaagttcatgcatc\"\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 12\n * 1 <= words[i].length <= 20\n * words[i] consists of lowercase English letters.\n * All the strings of words are unique.",
      "code": "class Solution {\npublic:\n    string shortestSuperstring(vector<string>& words) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String shortestSuperstring(String[] A) {\n        int N = A.length;\n\n        // Populate overlaps\n        int[][] overlaps = new int[N][N];\n        for (int i = 0; i < N; ++i)\n            for (int j = 0; j < N; ++j) if (i != j) {\n                int m = Math.min(A[i].length(), A[j].length());\n                for (int k = m; k >= 0; --k)\n                    if (A[i].endsWith(A[j].substring(0, k))) {\n                        overlaps[i][j] = k;\n                        break;\n                    }\n            }\n\n        // dp[mask][i] = most overlap with mask, ending with ith element\n        int[][] dp = new int[1<<N][N];\n        int[][] parent = new int[1<<N][N];\n        for (int mask = 0; mask < (1<<N); ++mask) {\n            Arrays.fill(parent[mask], -1);\n\n            for (int bit = 0; bit < N; ++bit) if (((mask >> bit) & 1) > 0) {\n                // Let's try to find dp[mask][bit].  Previously, we had\n                // a collection of items represented by pmask.\n                int pmask = mask ^ (1 << bit);\n                if (pmask == 0) continue;\n                for (int i = 0; i < N; ++i) if (((pmask >> i) & 1) > 0) {\n                    // For each bit i in pmask, calculate the value\n                    // if we ended with word i, then added word 'bit'.\n                    int val = dp[pmask][i] + overlaps[i][bit];\n                    if (val > dp[mask][bit]) {\n                        dp[mask][bit] = val;\n                        parent[mask][bit] = i;\n                    }\n                }\n            }\n        }\n\n        // # Answer will have length sum(len(A[i]) for i) - max(dp[-1])\n        // Reconstruct answer, first as a sequence 'perm' representing\n        // the indices of each word from left to right.\n\n        int[] perm = new int[N];\n        boolean[] seen = new boolean[N];\n        int t = 0;\n        int mask = (1 << N) - 1;\n\n        // p: the last element of perm (last word written left to right)\n        int p = 0;\n        for (int j = 0; j < N; ++j)\n            if (dp[(1<<N) - 1][j] > dp[(1<<N) - 1][p])\n                p = j;\n\n        // Follow parents down backwards path that retains maximum overlap\n        while (p != -1) {\n            perm[t++] = p;\n            seen[p] = true;\n            int p2 = parent[mask][p];\n            mask ^= 1 << p;\n            p = p2;\n        }\n\n        // Reverse perm\n        for (int i = 0; i < t/2; ++i) {\n            int v = perm[i];\n            perm[i] = perm[t-1-i];\n            perm[t-1-i] = v;\n        }\n\n        // Fill in remaining words not yet added\n        for (int i = 0; i < N; ++i) if (!seen[i])\n            perm[t++] = i;\n\n        // Reconstruct final answer given perm\n        StringBuilder ans = new StringBuilder(A[perm[0]]);\n        for (int i = 1; i < N; ++i) {\n            int overlap = overlaps[perm[i-1]][perm[i]];\n            ans.append(A[perm[i]].substring(overlap));\n        }\n\n        return ans.toString();\n    }\n}\n"
      ]
    },
    {
      "number": 208,
      "question": "Can you solve this real interview question? Minimum Increment to Make Array Unique - You are given an integer array nums. In one move, you can pick an index i where 0 <= i < nums.length and increment nums[i] by 1.\n\nReturn the minimum number of moves to make every value in nums unique.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,2]\nOutput: 1\nExplanation: After 1 move, the array could be [1, 2, 3].\n\n\nExample 2:\n\n\nInput: nums = [3,2,1,2,1,7]\nOutput: 6\nExplanation: After 6 moves, the array could be [3, 4, 1, 2, 5, 7].\nIt can be shown with 5 or less moves that it is impossible for the array to have all unique values.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 0 <= nums[i] <= 105",
      "code": "class Solution {\npublic:\n    int minIncrementForUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minIncrementForUnique(int[] nums) {\n        int maxVal = 0;\n        for (int x : nums) {\n            maxVal = Math.max(maxVal, x);\n        }\n        \n        int[] count = new int[nums.length + maxVal];\n        for (int x : nums) {\n            count[x]++;\n        }\n\n        int moves = 0;\n        int taken = 0;\n        for (int x = 0; x < nums.length + maxVal; ++x) {\n            if (count[x] >= 2) {\n                taken += count[x] - 1;\n                moves -= x * (count[x] - 1);\n            } else if (taken > 0 && count[x] == 0) {\n                taken--;\n                moves += x;\n            }\n        }\n\n        return moves;\n    }\n}",
        "class Solution {\n    public int minIncrementForUnique(int[] nums) {\n        Arrays.sort(nums);\n        int moves = 0, taken = 0;\n\n        for (int i = 1; i < nums.length; ++i) {\n            if (nums[i - 1] == nums[i]) {\n                taken++;\n                moves -= nums[i];\n            } else {\n                int give = Math.min(taken, nums[i] - nums[i - 1] - 1);\n                moves += give * (give + 1) / 2 + give * nums[i - 1];\n                taken -= give;\n            }\n        }\n\n        if (nums.length > 0)\n            moves += taken * (taken + 1) / 2 + taken * nums[nums.length - 1];\n\n        return moves;\n    }\n}"
      ]
    },
    {
      "number": 209,
      "question": "Can you solve this real interview question? Bag of Tokens - You have an initial power of power, an initial score of 0, and a bag of tokens where tokens[i] is the value of the ith token (0-indexed).\n\nYour goal is to maximize your total score by potentially playing each token in one of two ways:\n\n * If your current power is at least tokens[i], you may play the ith token face up, losing tokens[i] power and gaining 1 score.\n * If your current score is at least 1, you may play the ith token face down, gaining tokens[i] power and losing 1 score.\n\nEach token may be played at most once and in any order. You do not have to play all the tokens.\n\nReturn the largest possible score you can achieve after playing any number of tokens.\n\n \n\nExample 1:\n\n\nInput: tokens = [100], power = 50\nOutput: 0\nExplanation: Playing the only token in the bag is impossible because you either have too little power or too little score.\n\n\nExample 2:\n\n\nInput: tokens = [100,200], power = 150\nOutput: 1\nExplanation: Play the 0th token (100) face up, your power becomes 50 and score becomes 1.\nThere is no need to play the 1st token since you cannot play it face up to add to your score.\n\n\nExample 3:\n\n\nInput: tokens = [100,200,300,400], power = 200\nOutput: 2\nExplanation: Play the tokens in this order to get a score of 2:\n1. Play the 0th token (100) face up, your power becomes 100 and score becomes 1.\n2. Play the 3rd token (400) face down, your power becomes 500 and score becomes 0.\n3. Play the 1st token (200) face up, your power becomes 300 and score becomes 1.\n4. Play the 2nd token (300) face up, your power becomes 0 and score becomes 2.\n\n\n \n\nConstraints:\n\n * 0 <= tokens.length <= 1000\n * 0 <= tokens[i], power < 104",
      "code": "class Solution {\npublic:\n    int bagOfTokensScore(vector<int>& tokens, int power) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int bagOfTokensScore(int[] tokens, int P) {\n        Arrays.sort(tokens);\n        int lo = 0, hi = tokens.length - 1;\n        int points = 0, ans = 0;\n        while (lo <= hi && (P >= tokens[lo] || points > 0)) {\n            while (lo <= hi && P >= tokens[lo]) {\n                P -= tokens[lo++];\n                points++;\n            }\n\n            ans = Math.max(ans, points);\n            if (lo <= hi && points > 0) {\n                P += tokens[hi--];\n                points--;\n            }\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 210,
      "question": "Can you solve this real interview question? Reveal Cards In Increasing Order - You are given an integer array deck. There is a deck of cards where every card has a unique integer. The integer on the ith card is deck[i].\n\nYou can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck.\n\nYou will do the following steps repeatedly until all cards are revealed:\n\n 1. Take the top card of the deck, reveal it, and take it out of the deck.\n 2. If there are still cards in the deck then put the next top card of the deck at the bottom of the deck.\n 3. If there are still unrevealed cards, go back to step 1. Otherwise, stop.\n\nReturn an ordering of the deck that would reveal the cards in increasing order.\n\nNote that the first entry in the answer is considered to be the top of the deck.\n\n \n\nExample 1:\n\n\nInput: deck = [17,13,11,2,3,5,7]\nOutput: [2,13,3,11,5,17,7]\nExplanation: \nWe get the deck in the order [17,13,11,2,3,5,7] (this order does not matter), and reorder it.\nAfter reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck.\nWe reveal 2, and move 13 to the bottom.  The deck is now [3,11,5,17,7,13].\nWe reveal 3, and move 11 to the bottom.  The deck is now [5,17,7,13,11].\nWe reveal 5, and move 17 to the bottom.  The deck is now [7,13,11,17].\nWe reveal 7, and move 13 to the bottom.  The deck is now [11,17,13].\nWe reveal 11, and move 17 to the bottom.  The deck is now [13,17].\nWe reveal 13, and move 17 to the bottom.  The deck is now [17].\nWe reveal 17.\nSince all the cards revealed are in increasing order, the answer is correct.\n\n\nExample 2:\n\n\nInput: deck = [1,1000]\nOutput: [1,1000]\n\n\n \n\nConstraints:\n\n * 1 <= deck.length <= 1000\n * 1 <= deck[i] <= 106\n * All the values of deck are unique.",
      "code": "class Solution {\npublic:\n    vector<int> deckRevealedIncreasing(vector<int>& deck) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] deckRevealedIncreasing(int[] deck) {\n        int N = deck.length;\n        Deque<Integer> index = new LinkedList();\n        for (int i = 0; i < N; ++i)\n            index.add(i);\n\n        int[] ans = new int[N];\n        Arrays.sort(deck);\n        for (int card: deck) {\n            ans[index.pollFirst()] = card;\n            if (!index.isEmpty())\n                index.add(index.pollFirst());\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 211,
      "question": "Can you solve this real interview question? Flip Equivalent Binary Trees - For a binary tree T, we can define a flip operation as follows: choose any node, and swap the left and right child subtrees.\n\nA binary tree X is flip equivalent to a binary tree Y if and only if we can make X equal to Y after some number of flip operations.\n\nGiven the roots of two binary trees root1 and root2, return true if the two trees are flip equivalent or false otherwise.\n\n \n\nExample 1:\n\nFlipped Trees Diagram [https://assets.leetcode.com/uploads/2018/11/29/tree_ex.png]\n\n\nInput: root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]\nOutput: true\nExplanation: We flipped at nodes with values 1, 3, and 5.\n\n\nExample 2:\n\n\nInput: root1 = [], root2 = []\nOutput: true\n\n\nExample 3:\n\n\nInput: root1 = [], root2 = [1]\nOutput: false\n\n\n \n\nConstraints:\n\n * The number of nodes in each tree is in the range [0, 100].\n * Each tree will have unique node values in the range [0, 99].",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool flipEquiv(TreeNode* root1, TreeNode* root2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        if (root1 == root2)\n            return true;\n        if (root1 == null || root2 == null || root1.val != root2.val)\n            return false;\n\n        return (flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right) ||\n                flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left));\n    }\n}",
        "class Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        List<Integer> vals1 = new ArrayList();\n        List<Integer> vals2 = new ArrayList();\n        dfs(root1, vals1);\n        dfs(root2, vals2);\n        return vals1.equals(vals2);\n    }\n\n    public void dfs(TreeNode node, List<Integer> vals) {\n        if (node != null) {\n            vals.add(node.val);\n            int L = node.left != null ? node.left.val : -1;\n            int R = node.right != null ? node.right.val : -1;\n\n            if (L < R) {\n                dfs(node.left, vals);\n                dfs(node.right, vals);\n            } else {\n                dfs(node.right, vals);\n                dfs(node.left, vals);\n            }\n\n            vals.add(null);\n        }\n    }\n}\n"
      ]
    },
    {
      "number": 212,
      "question": "Can you solve this real interview question? Verifying an Alien Dictionary - In an alien language, surprisingly, they also use English lowercase letters, but possibly in a different order. The order of the alphabet is some permutation of lowercase letters.\n\nGiven a sequence of words written in the alien language, and the order of the alphabet, return true if and only if the given words are sorted lexicographically in this alien language.\n\n \n\nExample 1:\n\n\nInput: words = [\"hello\",\"leetcode\"], order = \"hlabcdefgijkmnopqrstuvwxyz\"\nOutput: true\nExplanation: As 'h' comes before 'l' in this language, then the sequence is sorted.\n\n\nExample 2:\n\n\nInput: words = [\"word\",\"world\",\"row\"], order = \"worldabcefghijkmnpqstuvxyz\"\nOutput: false\nExplanation: As 'd' comes after 'l' in this language, then words[0] > words[1], hence the sequence is unsorted.\n\n\nExample 3:\n\n\nInput: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\nOutput: false\nExplanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\", because 'l' > '', where '' is defined as the blank character which is less than any other character (More infohttps://en.wikipedia.org/wiki/Lexicographical_order).\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 100\n * 1 <= words[i].length <= 20\n * order.length == 26\n * All characters in words[i] and order are English lowercase letters.",
      "code": "class Solution {\npublic:\n    bool isAlienSorted(vector<string>& words, string order) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean isAlienSorted(String[] words, String order) {\n        int[] orderMap = new int[26];\n        for (int i = 0; i < order.length(); i++){\n            orderMap[order.charAt(i) - 'a'] = i;\n        }\n\n        for (int i = 0; i < words.length - 1; i++) {\n\n            for (int j = 0; j < words[i].length(); j++) {\n                // If we do not find a mismatch letter between words[i] and words[i + 1],\n                // we need to examine the case when words are like (\"apple\", \"app\").\n                if (j >= words[i + 1].length()) return false;\n\n                if (words[i].charAt(j) != words[i + 1].charAt(j)) {\nint currentWordChar = words[i].charAt(j) - 'a';\nint nextWordChar = words[i + 1].charAt(j) - 'a';\n                    if (orderMap[currentWordChar] > orderMap[nextWordChar]) return false;\n                    // if we find the first different letter and they are sorted,\n                    // then there's no need to check remaining letters\n                    else break;\n                }\n            }\n        }\n\n        return true;\n    }\n}"
      ]
    },
    {
      "number": 213,
      "question": "Can you solve this real interview question? Array of Doubled Pairs - Given an integer array of even length arr, return true if it is possible to reorder arr such that arr[2 * i + 1] = 2 * arr[2 * i] for every 0 <= i < len(arr) / 2, or false otherwise.\n\n \n\nExample 1:\n\n\nInput: arr = [3,1,3,6]\nOutput: false\n\n\nExample 2:\n\n\nInput: arr = [2,1,2,6]\nOutput: false\n\n\nExample 3:\n\n\nInput: arr = [4,-2,2,-4]\nOutput: true\nExplanation: We can take two groups, [-2,-4] and [2,4] to form [-2,-4,2,4] or [2,4,-2,-4].\n\n\n \n\nConstraints:\n\n * 2 <= arr.length <= 3 * 104\n * arr.length is even.\n * -105 <= arr[i] <= 105",
      "code": "class Solution {\npublic:\n    bool canReorderDoubled(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean canReorderDoubled(int[] A) {\n        // count[x] = the number of occurrences of x in A\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A)\n            count.put(x, count.getOrDefault(x, 0) + 1);\n\n        // B = A as Integer[], sorted by absolute value\n        Integer[] B = new Integer[A.length];\n        for (int i = 0; i < A.length; ++i)\n            B[i] = A[i];\n        Arrays.sort(B, Comparator.comparingInt(Math::abs));\n\n        for (int x: B) {\n            // If this can't be consumed, skip\n            if (count.get(x) == 0) continue;\n            // If this doesn't have a doubled partner, the answer is false\n            if (count.getOrDefault(2*x, 0) <= 0) return false;\n\n            // Write x, 2*x\n            count.put(x, count.get(x) - 1);\n            count.put(2*x, count.get(2*x) - 1);\n        }\n\n        // If we have written everything, the answer is true\n        return true;\n    }\n}"
      ]
    },
    {
      "number": 214,
      "question": "Can you solve this real interview question? Tallest Billboard - You are installing a billboard and want it to have the largest height. The billboard will have two steel supports, one on each side. Each steel support must be an equal height.\n\nYou are given a collection of rods that can be welded together. For example, if you have rods of lengths 1, 2, and 3, you can weld them together to make a support of length 6.\n\nReturn the largest possible height of your billboard installation. If you cannot support the billboard, return 0.\n\n \n\nExample 1:\n\n\nInput: rods = [1,2,3,6]\nOutput: 6\nExplanation: We have two disjoint subsets {1,2,3} and {6}, which have the same sum = 6.\n\n\nExample 2:\n\n\nInput: rods = [1,2,3,4,5,6]\nOutput: 10\nExplanation: We have two disjoint subsets {2,3,5} and {4,6}, which have the same sum = 10.\n\n\nExample 3:\n\n\nInput: rods = [1,2]\nOutput: 0\nExplanation: The billboard cannot be supported, so we return 0.\n\n\n \n\nConstraints:\n\n * 1 <= rods.length <= 20\n * 1 <= rods[i] <= 1000\n * sum(rods[i]) <= 5000",
      "code": "class Solution {\npublic:\n    int tallestBillboard(vector<int>& rods) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    // Helper function to collect every combination `(left, right)`\n    Map<Integer, Integer> helper(int[] rods, int leftIndex, int rightIndex) {\n        Set<Pair<Integer, Integer>> states = new HashSet<>();\n        states.add(new Pair(0, 0));\n        for (int i = leftIndex; i < rightIndex; ++i) {\n            int r = rods[i];\n            Set<Pair<Integer, Integer>> newStates = new HashSet<>();\n            for (Pair<Integer, Integer> p : states) {\n                newStates.add(new Pair(p.getKey() + r, p.getValue()));\n                newStates.add(new Pair(p.getKey(), p.getValue() + r));\n            }\n            states.addAll(newStates);\n        }\n\n        Map<Integer, Integer> dp = new HashMap<>();\n        for (Pair<Integer, Integer> p : states) {\n            int left = p.getKey(), right = p.getValue();\n            dp.put(left - right, Math.max(dp.getOrDefault(left - right, 0), left));\n        }\n        return dp;\n    }\n    \n    public int tallestBillboard(int[] rods) {\n        int n = rods.length;\n        Map<Integer, Integer> firstHalf = helper(rods, 0, n / 2);\n        Map<Integer, Integer> secondHalf = helper(rods, n / 2, n);\n\n        int answer = 0;\n        for (int diff : firstHalf.keySet()) {\n            if (secondHalf.containsKey(-diff)) {\n                answer = Math.max(answer, firstHalf.get(diff) + secondHalf.get(-diff));\n            }\n        }\n        return answer;\n    }\n}",
        "public class Solution {\n    public int tallestBillboard(int[] rods) {\n        // dp[taller - shorter] = taller\n        Map<Integer, Integer> dp = new HashMap<>();\n        dp.put(0, 0);\n        \n        for (int r : rods) {\n            // newDp means we don't add r to these stands.\n            Map<Integer, Integer> newDp = new HashMap<>(dp);\n            \n            for (Map.Entry<Integer, Integer> entry : dp.entrySet()) {\n                int diff = entry.getKey();\n                int taller = entry.getValue();\n                int shorter = taller - diff;\n                \n                // Add r to the taller stand, thus the height difference is increased to diff + r.\n                int newTaller = newDp.getOrDefault(diff + r, 0);\n                newDp.put(diff + r, Math.max(newTaller, taller + r));\n                \n                // Add r to the shorter stand, the height difference is expressed as abs(shorter + r - taller).\n                int newDiff = Math.abs(shorter + r - taller);\n                int newTaller2 = Math.max(shorter + r, taller);\n                newDp.put(newDiff, Math.max(newTaller2, newDp.getOrDefault(newDiff, 0)));\n            }\n            \n            dp = newDp;\n        }\n        \n        // Return the maximum height with 0 difference.\n        return dp.getOrDefault(0, 0);\n    }\n}"
      ]
    },
    {
      "number": 215,
      "question": "Can you solve this real interview question? Regions Cut By Slashes - An n x n grid is composed of 1 x 1 squares where each 1 x 1 square consists of a '/', '\\', or blank space ' '. These characters divide the square into contiguous regions.\n\nGiven the grid grid represented as a string array, return the number of regions.\n\nNote that backslash characters are escaped, so a '\\' is represented as '\\\\'.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2018/12/15/1.png]\n\n\nInput: grid = [\" /\",\"/ \"]\nOutput: 2\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2018/12/15/2.png]\n\n\nInput: grid = [\" /\",\"  \"]\nOutput: 1\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2018/12/15/4.png]\n\n\nInput: grid = [\"/\\\\\",\"\\\\/\"]\nOutput: 5\nExplanation: Recall that because \\ characters are escaped, \"\\\\/\" refers to \\/, and \"/\\\\\" refers to /\\.\n\n\n \n\nConstraints:\n\n * n == grid.length == grid[i].length\n * 1 <= n <= 30\n * grid[i][j] is either '/', '\\', or ' '.",
      "code": "class Solution {\npublic:\n    int regionsBySlashes(vector<string>& grid) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int regionsBySlashes(String[] grid) {\n        int N = grid.length;\n        DSU dsu = new DSU(4 * N * N);\n        for (int r = 0; r < N; ++r)\n            for (int c = 0; c < N; ++c) {\n                int root = 4 * (r * N + c);\n                char val = grid[r].charAt(c);\n                if (val != '\\\\') {\n                    dsu.union(root + 0, root + 1);\n                    dsu.union(root + 2, root + 3);\n                }\n                if (val != '/') {\n                    dsu.union(root + 0, root + 2);\n                    dsu.union(root + 1, root + 3);\n                }\n\n                // north south\n                if (r + 1 < N)\n                    dsu.union(root + 3, (root + 4 * N) + 0);\n                if (r - 1 >= 0)\n                    dsu.union(root + 0, (root - 4 * N) + 3);\n                // east west\n                if (c + 1 < N)\n                    dsu.union(root + 2, (root + 4) + 1);\n                if (c - 1 >= 0)\n                    dsu.union(root + 1, (root - 4) + 2);\n            }\n\n        int ans = 0;\n        for (int x = 0; x < 4 * N * N; ++x) {\n            if (dsu.find(x) == x)\n                ans++;\n        }\n\n        return ans;\n    }\n}\n\nclass DSU {\n    int[] parent;\n    public DSU(int N) {\n        parent = new int[N];\n        for (int i = 0; i < N; ++i)\n            parent[i] = i;\n    }\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n    public void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}"
      ]
    },
    {
      "number": 216,
      "question": "Can you solve this real interview question? Delete Columns to Make Sorted III - You are given an array of n strings strs, all of the same length.\n\nWe may choose any deletion indices, and we delete all the characters in those indices for each string.\n\nFor example, if we have strs = [\"abcdef\",\"uvwxyz\"] and deletion indices {0, 2, 3}, then the final array after deletions is [\"bef\", \"vyz\"].\n\nSuppose we chose a set of deletion indices answer such that after deletions, the final array has every string (row) in lexicographic order. (i.e., (strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]), and (strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1]), and so on). Return the minimum possible value of answer.length.\n\n \n\nExample 1:\n\n\nInput: strs = [\"babca\",\"bbazb\"]\nOutput: 3\nExplanation: After deleting columns 0, 1, and 4, the final array is strs = [\"bc\", \"az\"].\nBoth these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).\nNote that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.\n\nExample 2:\n\n\nInput: strs = [\"edcba\"]\nOutput: 4\nExplanation: If we delete less than 4 columns, the only row will not be lexicographically sorted.\n\n\nExample 3:\n\n\nInput: strs = [\"ghi\",\"def\",\"abc\"]\nOutput: 0\nExplanation: All rows are already lexicographically sorted.\n\n\n \n\nConstraints:\n\n * n == strs.length\n * 1 <= n <= 100\n * 1 <= strs[i].length <= 100\n * strs[i] consists of lowercase English letters.\n\n *  ",
      "code": "class Solution {\npublic:\n    int minDeletionSize(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minDeletionSize(String[] A) {\n        int W = A[0].length();\n        int[] dp = new int[W];\n        Arrays.fill(dp, 1);\n        for (int i = W-2; i >= 0; --i)\n            search: for (int j = i+1; j < W; ++j) {\n                for (String row: A)\n                    if (row.charAt(i) > row.charAt(j))\n                        continue search;\n\n                dp[i] = Math.max(dp[i], 1 + dp[j]);\n            }\n\n        int kept = 0;\n        for (int x: dp)\n            kept = Math.max(kept, x);\n        return W - kept;\n    }\n}"
      ]
    },
    {
      "number": 217,
      "question": "Can you solve this real interview question? N-Repeated Element in Size 2N Array - You are given an integer array nums with the following properties:\n\n * nums.length == 2 * n.\n * nums contains n + 1 unique elements.\n * Exactly one element of nums is repeated n times.\n\nReturn the element that is repeated n times.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,3]\nOutput: 3\n\n\nExample 2:\n\nInput: nums = [2,1,2,5,3,2]\nOutput: 2\n\n\nExample 3:\n\nInput: nums = [5,1,5,2,5,3,5,4]\nOutput: 5\n\n\n \n\nConstraints:\n\n * 2 <= n <= 5000\n * nums.length == 2 * n\n * 0 <= nums[i] <= 104\n * nums contains n + 1 unique elements and one of them is repeated exactly n times.",
      "code": "class Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int repeatedNTimes(int[] A) {\n        Map<Integer, Integer> count = new HashMap();\n        for (int x: A) {\n            count.put(x, count.getOrDefault(x, 0) + 1);\n        }\n\n        for (int k: count.keySet())\n            if (count.get(k) > 1)\n                return k;\n\n        throw null;\n    }\n}",
        "class Solution {\n    public int repeatedNTimes(int[] A) {\n        for (int k = 1; k <= 3; ++k)\n            for (int i = 0; i < A.length - k; ++i)\n                if (A[i] == A[i+k])\n                    return A[i];\n\n        throw null;\n    }\n}"
      ]
    },
    {
      "number": 218,
      "question": "Can you solve this real interview question? Univalued Binary Tree - A binary tree is uni-valued if every node in the tree has the same value.\n\nGiven the root of a binary tree, return true if the given tree is uni-valued, or false otherwise.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2018/12/28/unival_bst_1.png]\n\n\nInput: root = [1,1,1,1,1,null,1]\nOutput: true\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2018/12/28/unival_bst_2.png]\n\n\nInput: root = [2,2,2,5,2]\nOutput: false\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 100].\n * 0 <= Node.val < 100",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool isUnivalTree(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    List<Integer> vals;\n    public boolean isUnivalTree(TreeNode root) {\n        vals = new ArrayList();\n        dfs(root);\n        for (int v: vals)\n            if (v != vals.get(0))\n                return false;\n        return true;\n    }\n\n    public void dfs(TreeNode node) {\n        if (node != null) {\n            vals.add(node.val);\n            dfs(node.left);\n            dfs(node.right);\n        }\n    }\n}",
        "class Solution {\n    public boolean isUnivalTree(TreeNode root) {\n        boolean left_correct = (root.left == null ||\n                (root.val == root.left.val && isUnivalTree(root.left)));\n        boolean right_correct = (root.right == null ||\n                (root.val == root.right.val && isUnivalTree(root.right)));\n        return left_correct && right_correct;\n    }\n}"
      ]
    },
    {
      "number": 219,
      "question": "Can you solve this real interview question? Vowel Spellchecker - Given a wordlist, we want to implement a spellchecker that converts a query word into a correct word.\n\nFor a given query word, the spell checker handles two categories of spelling mistakes:\n\n * Capitalization: If the query matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the case in the wordlist.\n   * Example: wordlist = [\"yellow\"], query = \"YellOw\": correct = \"yellow\"\n   * Example: wordlist = [\"Yellow\"], query = \"yellow\": correct = \"Yellow\"\n   * Example: wordlist = [\"yellow\"], query = \"yellow\": correct = \"yellow\"\n * Vowel Errors: If after replacing the vowels ('a', 'e', 'i', 'o', 'u') of the query word with any vowel individually, it matches a word in the wordlist (case-insensitive), then the query word is returned with the same case as the match in the wordlist.\n   * Example: wordlist = [\"YellOw\"], query = \"yollow\": correct = \"YellOw\"\n   * Example: wordlist = [\"YellOw\"], query = \"yeellow\": correct = \"\" (no match)\n   * Example: wordlist = [\"YellOw\"], query = \"yllw\": correct = \"\" (no match)\n\nIn addition, the spell checker operates under the following precedence rules:\n\n * When the query exactly matches a word in the wordlist (case-sensitive), you should return the same word back.\n * When the query matches a word up to capitlization, you should return the first such match in the wordlist.\n * When the query matches a word up to vowel errors, you should return the first such match in the wordlist.\n * If the query has no matches in the wordlist, you should return the empty string.\n\nGiven some queries, return a list of words answer, where answer[i] is the correct word for query = queries[i].\n\n \n\nExample 1:\n\nInput: wordlist = [\"KiTe\",\"kite\",\"hare\",\"Hare\"], queries = [\"kite\",\"Kite\",\"KiTe\",\"Hare\",\"HARE\",\"Hear\",\"hear\",\"keti\",\"keet\",\"keto\"]\nOutput: [\"kite\",\"KiTe\",\"KiTe\",\"Hare\",\"hare\",\"\",\"\",\"KiTe\",\"\",\"KiTe\"]\n\n\nExample 2:\n\nInput: wordlist = [\"yellow\"], queries = [\"YellOw\"]\nOutput: [\"yellow\"]\n\n\n \n\nConstraints:\n\n * 1 <= wordlist.length, queries.length <= 5000\n * 1 <= wordlist[i].length, queries[i].length <= 7\n * wordlist[i] and queries[i] consist only of only English letters.",
      "code": "class Solution {\npublic:\n    vector<string> spellchecker(vector<string>& wordlist, \nvector<string>& queries) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    Set<String> words_perfect;\n    Map<String, String> words_cap;\n    Map<String, String> words_vow;\n\n    public String[] spellchecker(String[] wordlist, String[] queries) {\n        words_perfect = new HashSet();\n        words_cap = new HashMap();\n        words_vow = new HashMap();\n\n        for (String word: wordlist) {\n            words_perfect.add(word);\n\n            String wordlow = word.toLowerCase();\n            words_cap.putIfAbsent(wordlow, word);\n\n            String wordlowDV = devowel(wordlow);\n            words_vow.putIfAbsent(wordlowDV, word);\n        }\n\n        String[] ans = new String[queries.length];\n        int t = 0;\n        for (String query: queries)\n            ans[t++] = solve(query);\n        return ans;\n    }\n\n    public String solve(String query) {\n        if (words_perfect.contains(query))\n            return query;\n\n        String queryL = query.toLowerCase();\n        if (words_cap.containsKey(queryL))\n            return words_cap.get(queryL);\n\n        String queryLV = devowel(queryL);\n        if (words_vow.containsKey(queryLV))\n            return words_vow.get(queryLV);\n\n        return \"\";\n    }\n\n    public String devowel(String word) {\n        StringBuilder ans = new StringBuilder();\n        for (char c: word.toCharArray())\n            ans.append(isVowel(c) ? '*' : c);\n        return ans.toString();\n    }\n\n    public boolean isVowel(char c) {\n        return (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u');\n    }\n}"
      ]
    },
    {
      "number": 220,
      "question": "Can you solve this real interview question? Numbers With Same Consecutive Differences - Given two integers n and k, return an array of all the integers of length n where the difference between every two consecutive digits is k. You may return the answer in any order.\n\nNote that the integers should not have leading zeros. Integers as 02 and 043 are not allowed.\n\n \n\nExample 1:\n\n\nInput: n = 3, k = 7\nOutput: [181,292,707,818,929]\nExplanation: Note that 070 is not a valid number, because it has leading zeroes.\n\n\nExample 2:\n\n\nInput: n = 2, k = 1\nOutput: [10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]\n\n\n \n\nConstraints:\n\n * 2 <= n <= 9\n * 0 <= k <= 9",
      "code": "class Solution {\npublic:\n    vector<int> numsSameConsecDiff(int n, int k) {\n        \n    }\n};",
      "solution": [
        "\nclass Solution {\n\n    public int[] numsSameConsecDiff(int N, int K) {\n        if (N == 1)\n            return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n        List<Integer> results = new ArrayList<Integer>();\n        for (int num = 1; num < 10; ++num)\n            this.DFS(N - 1, num, K, results);\n\n        // convert the ArrayList to int[]\n        return results.stream().mapToInt(i->i).toArray();\n    }\n\n    protected void DFS(int N, int num, int K, List<Integer> results) {\n        if (N == 0) {\n            results.add(num);\n            return;\n        }\n        List<Integer> nextDigits = new ArrayList<>();\n\n        Integer tailDigit = num % 10;\n        nextDigits.add(tailDigit + K);\n        if (K != 0)\n            nextDigits.add(tailDigit - K);\n        for (Integer nextDigit : nextDigits) {\n            if (0 <= nextDigit && nextDigit < 10) {\n                Integer newNum = num * 10 + nextDigit;\n                this.DFS(N - 1, newNum, K, results);\n            }\n        }\n    }\n}",
        "class Solution {\n\n    public int[] numsSameConsecDiff(int N, int K) {\n\n        if (N == 1)\n            return new int[] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n        List<Integer> queue = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        for(int level = 1; level < N; ++ level) {\n            ArrayList<Integer> nextQueue = new ArrayList<>();\n            // iterate through each number within the level\n            for (Integer num : queue) {\n                Integer tailDigit = num % 10;\n\n                ArrayList<Integer> nextDigits = new ArrayList<>();\n                nextDigits.add(tailDigit + K);\n                if (K != 0)\n                    nextDigits.add(tailDigit - K);\n                for (Integer nextDigit : nextDigits) {\n                    if (0 <= nextDigit && nextDigit < 10) {\n                        Integer newNum = num * 10 + nextDigit;\n                        nextQueue.add(newNum);\n                    }\n                }\n            }\n            // prepare for the next level\n            queue = nextQueue;\n        }\n\n        return queue.stream().mapToInt(i->i).toArray();\n    }\n}"
      ]
    },
    {
      "number": 221,
      "question": "Can you solve this real interview question? Binary Tree Cameras - You are given the root of a binary tree. We install cameras on the tree nodes where each camera at a node can monitor its parent, itself, and its immediate children.\n\nReturn the minimum number of cameras needed to monitor all nodes of the tree.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_01.png]\n\n\nInput: root = [0,0,null,0,0]\nOutput: 1\nExplanation: One camera is enough to monitor all nodes if placed as shown.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2018/12/29/bst_cameras_02.png]\n\n\nInput: root = [0,0,null,0,null,0,null,null,0]\nOutput: 2\nExplanation: At least two cameras are needed to monitor all nodes of the tree. The above image shows one of the valid configurations of camera placement.\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 1000].\n * Node.val == 0",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minCameraCover(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minCameraCover(TreeNode root) {\n        int[] ans = solve(root);\n        return Math.min(ans[1], ans[2]);\n    }\n\n    // 0: Strict ST; All nodes below this are covered, but not this one\n    // 1: Normal ST; All nodes below and incl this are covered - no camera\n    // 2: Placed camera; All nodes below this are covered, plus camera here\n    public int[] solve(TreeNode node) {\n        if (node == null)\n            return new int[]{0, 0, 99999};\n\n        int[] L = solve(node.left);\n        int[] R = solve(node.right);\n        int mL12 = Math.min(L[1], L[2]);\n        int mR12 = Math.min(R[1], R[2]);\n\n        int d0 = L[1] + R[1];\n        int d1 = Math.min(L[2] + mR12, R[2] + mL12);\n        int d2 = 1 + Math.min(L[0], mL12) + Math.min(R[0], mR12);\n        return new int[]{d0, d1, d2};\n    }\n}\n",
        "class Solution {\n    int ans;\n    Set<TreeNode> covered;\n    public int minCameraCover(TreeNode root) {\n        ans = 0;\n        covered = new HashSet();\n        covered.add(null);\n\n        dfs(root, null);\n        return ans;\n    }\n\n    public void dfs(TreeNode node, TreeNode par) {\n        if (node != null) {\n            dfs(node.left, node);\n            dfs(node.right, node);\n\n            if (par == null && !covered.contains(node) ||\n                    !covered.contains(node.left) ||\n                    !covered.contains(node.right)) {\n                ans++;\n                covered.add(node);\n                covered.add(par);\n                covered.add(node.left);\n                covered.add(node.right);\n            }\n        }\n    }\n}"
      ]
    },
    {
      "number": 222,
      "question": "Can you solve this real interview question? Pancake Sorting - Given an array of integers arr, sort the array by performing a series of pancake flips.\n\nIn one pancake flip we do the following steps:\n\n * Choose an integer k where 1 <= k <= arr.length.\n * Reverse the sub-array arr[0...k-1] (0-indexed).\n\nFor example, if arr = [3,2,1,4] and we performed a pancake flip choosing k = 3, we reverse the sub-array [3,2,1], so arr = [1,2,3,4] after the pancake flip at k = 3.\n\nReturn an array of the k-values corresponding to a sequence of pancake flips that sort arr. Any valid answer that sorts the array within 10 * arr.length flips will be judged as correct.\n\n \n\nExample 1:\n\n\nInput: arr = [3,2,4,1]\nOutput: [4,2,4,3]\nExplanation: \nWe perform 4 pancake flips, with k values 4, 2, 4, and 3.\nStarting state: arr = [3, 2, 4, 1]\nAfter 1st flip (k = 4): arr = [1, 4, 2, 3]\nAfter 2nd flip (k = 2): arr = [4, 1, 2, 3]\nAfter 3rd flip (k = 4): arr = [3, 2, 1, 4]\nAfter 4th flip (k = 3): arr = [1, 2, 3, 4], which is sorted.\n\n\nExample 2:\n\n\nInput: arr = [1,2,3]\nOutput: []\nExplanation: The input is already sorted, so there is no need to flip anything.\nNote that other answers, such as [3, 3], would also be accepted.\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 100\n * 1 <= arr[i] <= arr.length\n * All integers in arr are unique (i.e. arr is a permutation of the integers from 1 to arr.length).",
      "code": "class Solution {\npublic:\n    vector<int> pancakeSort(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    /**\n     * sort like bubble-sort i.e. sink the largest number to the bottom at each round.\n     */\n    public List<Integer> pancakeSort(int[] A) {\n        List<Integer> ans = new ArrayList<>();\n\n        for (int valueToSort = A.length; valueToSort > 0; valueToSort--) {\n            // locate the position for the value to sort in this round\n            int index = this.find(A, valueToSort);\n\n            // sink the value_to_sort to the bottom,\n            // with at most two steps of pancake flipping.\n            if (index == valueToSort - 1)\n                continue;\n            // 1). flip the value to the head if necessary\n            if (index != 0) {\n                ans.add(index + 1);\n                this.flip(A, index + 1);\n            }\n            // 2). now that the value is at the head, flip it to the bottom\n            ans.add(valueToSort);\n            this.flip(A, valueToSort);\n        }\n\n        return ans;\n    }\n\n    protected void flip(int[] sublist, int k) {\n        int i = 0;\n        while (i < k / 2) {\n            int temp = sublist[i];\n            sublist[i] = sublist[k - i - 1];\n            sublist[k - i - 1] = temp;\n            i += 1;\n        }\n    }\n\n    protected int find(int[] a, int target) {\n        for (int i = 0; i < a.length; i++)\n            if (a[i] == target)\n                return i;\n        return -1;\n    }\n}"
      ]
    },
    {
      "number": 223,
      "question": "Can you solve this real interview question? Powerful Integers - Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\n\nAn integer is powerful if it can be represented as xi + yj for some integers i >= 0 and j >= 0.\n\nYou may return the answer in any order. In your answer, each value should occur at most once.\n\n \n\nExample 1:\n\n\nInput: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32\n\n\nExample 2:\n\n\nInput: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]\n\n\n \n\nConstraints:\n\n * 1 <= x, y <= 100\n * 0 <= bound <= 106",
      "code": "class Solution {\npublic:\n    vector<int> powerfulIntegers(int x, int y, int bound) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n        \n        int a = x == 1 ? bound : (int) (Math.log(bound) / Math.log(x));\n        int b = y == 1 ? bound : (int) (Math.log(bound) / Math.log(y));\n        \n        HashSet<Integer> powerfulIntegers = new HashSet<Integer>();\n        \n        for (int i = 0; i <= a; i++) {\n            for (int j = 0; j <= b; j++) {\n                \n                int value = (int) Math.pow(x, i) + (int) Math.pow(y, j);\n                \n                if (value <= bound) {\n                    powerfulIntegers.add(value);\n                }\n                \n                // No point in considering other powers of \"1\".\n                if (y == 1) {\n                    break;\n                }\n            }\n            \n            if (x == 1) {\n                break;\n            }\n        }\n        \n        return new ArrayList<Integer>(powerfulIntegers);\n    }\n}"
      ]
    },
    {
      "number": 224,
      "question": "Can you solve this real interview question? Flip Binary Tree To Match Preorder Traversal - You are given the root of a binary tree with n nodes, where each node is uniquely assigned a value from 1 to n. You are also given a sequence of n values voyage, which is the desired pre-order traversal [https://en.wikipedia.org/wiki/Tree_traversal#Pre-order] of the binary tree.\n\nAny node in the binary tree can be flipped by swapping its left and right subtrees. For example, flipping node 1 will have the following effect:\n\n[https://assets.leetcode.com/uploads/2021/02/15/fliptree.jpg]\n\nFlip the smallest number of nodes so that the pre-order traversal of the tree matches voyage.\n\nReturn a list of the values of all flipped nodes. You may return the answer in any order. If it is impossible to flip the nodes in the tree to make the pre-order traversal match voyage, return the list [-1].\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/01/02/1219-01.png]\n\n\nInput: root = [1,2], voyage = [2,1]\nOutput: [-1]\nExplanation: It is impossible to flip the nodes such that the pre-order traversal matches voyage.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2019/01/02/1219-02.png]\n\n\nInput: root = [1,2,3], voyage = [1,3,2]\nOutput: [1]\nExplanation: Flipping node 1 swaps nodes 2 and 3, so the pre-order traversal matches voyage.\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2019/01/02/1219-02.png]\n\n\nInput: root = [1,2,3], voyage = [1,2,3]\nOutput: []\nExplanation: The tree's pre-order traversal already matches voyage, so no nodes need to be flipped.\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is n.\n * n == voyage.length\n * 1 <= n <= 100\n * 1 <= Node.val, voyage[i] <= n\n * All the values in the tree are unique.\n * All the values in voyage are unique.",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> flipMatchVoyage(TreeNode* root, \nvector<int>& voyage) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    List<Integer> flipped;\n    int index;\n    int[] voyage;\n\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {\n        flipped = new ArrayList();\n        index = 0;\n        this.voyage = voyage;\n\n        dfs(root);\n        if (!flipped.isEmpty() && flipped.get(0) == -1) {\n            flipped.clear();\n            flipped.add(-1);\n        }\n\n        return flipped;\n    }\n\n    public void dfs(TreeNode node) {\n        if (node != null) {\n            if (node.val != voyage[index++]) {\n                flipped.clear();\n                flipped.add(-1);\n                return;\n            }\n\n            if (index < voyage.length && node.left != null &&\n                    node.left.val != voyage[index]) {\n                flipped.add(node.val);\n                dfs(node.right);\n                dfs(node.left);\n            } else {\n                dfs(node.left);\n                dfs(node.right);\n            }\n        }\n    }\n}"
      ]
    },
    {
      "number": 225,
      "question": "Can you solve this real interview question? Equal Rational Numbers - Given two strings s and t, each of which represents a non-negative rational number, return true if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\n\nA rational number can be represented using up to three parts: <IntegerPart>, <NonRepeatingPart>, and a <RepeatingPart>. The number will be represented in one of the following three ways:\n\n * <IntegerPart>\n   * For example, 12, 0, and 123.\n * <IntegerPart><.><NonRepeatingPart>\n   * For example, 0.5, 1., 2.12, and 123.0001.\n * <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)>\n   * For example, 0.1(6), 1.(9), 123.00(1212).\n\nThe repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets. For example:\n\n * 1/6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66).\n\n \n\nExample 1:\n\n\nInput: s = \"0.(52)\", t = \"0.5(25)\"\nOutput: true\nExplanation: Because \"0.(52)\" represents 0.52525252..., and \"0.5(25)\" represents 0.52525252525..... , the strings represent the same number.\n\n\nExample 2:\n\n\nInput: s = \"0.1666(6)\", t = \"0.166(66)\"\nOutput: true\n\n\nExample 3:\n\n\nInput: s = \"0.9(9)\", t = \"1.\"\nOutput: true\nExplanation: \"0.9(9)\" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.https://en.wikipedia.org/wiki/0.999...]\n\"1.\" represents the number 1, which is formed correctly: (IntegerPart) = \"1\" and (NonRepeatingPart) = \"\".\n\n\n \n\nConstraints:\n\n * Each part consists only of digits.\n * The <IntegerPart> does not have leading zeros (except for the zero itself).\n * 1 <= <IntegerPart>.length <= 4\n * 0 <= <NonRepeatingPart>.length <= 4\n * 1 <= <RepeatingPart>.length <= 4",
      "code": "class Solution {\npublic:\n    bool isRationalEqual(string s, string t) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public boolean isRationalEqual(String S, String T) {\n        Fraction f1 = convert(S);\n        Fraction f2 = convert(T);\n        return f1.n == f2.n && f1.d == f2.d;\n    }\n\n    public Fraction convert(String S) {\n        int state = 0; //whole, decimal, repeating\n        Fraction ans = new Fraction(0, 1);\n        int decimal_size = 0;\n\n        for (String part: S.split(\"[.()]\")) {\n            state++;\n            if (part.isEmpty()) continue;\n            long x = Long.valueOf(part);\n            int sz = part.length();\n\n            if (state == 1) { // whole\n                 ans.iadd(new Fraction(x, 1));\n            } else if (state == 2) { // decimal\n                 ans.iadd(new Fraction(x, (long) Math.pow(10, sz)));\n                 decimal_size = sz;\n            } else { // repeating\n                 long denom = (long) Math.pow(10, decimal_size);\n                 denom *= (long) (Math.pow(10, sz) - 1);\n                 ans.iadd(new Fraction(x, denom));\n            }\n        }\n        return ans;\n    }\n}\n\nclass Fraction {\n    long n, d;\n    Fraction(long n, long d) {\n        long g = gcd(n, d);\n        this.n = n / g;\n        this.d = d / g;\n    }\n\n    public void iadd(Fraction other) {\n        long numerator = this.n * other.d + this.d * other.n;\n        long denominator = this.d * other.d;\n        long g = Fraction.gcd(numerator, denominator);\n        this.n = numerator / g;\n        this.d = denominator / g;\n    }\n\n    static long gcd(long x, long y) {\n        return x != 0 ? gcd(y % x, x) : y;\n    }\n}"
      ]
    },
    {
      "number": 226,
      "question": "Can you solve this real interview question? Subarray Sums Divisible by K - Given an integer array nums and an integer k, return the number of non-empty subarrays that have a sum divisible by k.\n\nA subarray is a contiguous part of an array.\n\n \n\nExample 1:\n\n\nInput: nums = [4,5,0,-2,-3,1], k = 5\nOutput: 7\nExplanation: There are 7 subarrays with a sum divisible by k = 5:\n[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]\n\n\nExample 2:\n\n\nInput: nums = [5], k = 9\nOutput: 0\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 3 * 104\n * -104 <= nums[i] <= 104\n * 2 <= k <= 104",
      "code": "class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int subarraysDivByK(vector<int>& nums, int k) {\n        int n = nums.size();\n        int prefixMod = 0, result = 0;\n\n        // There are k mod groups 0...k-1.\n        vector<int> modGroups(k);\n        modGroups[0] = 1;\n\n        for (int num : nums) {\n            // Take modulo twice to avoid negative remainders.\n            prefixMod = (prefixMod + num % k + k) % k;\n            // Add the count of subarrays that have the same remainder as the current\n            // one to cancel out the remainders.\n            result += modGroups[prefixMod];\n            modGroups[prefixMod]++;\n        }\n\n        return result;\n    }\n};"
      ]
    },
    {
      "number": 227,
      "question": "Can you solve this real interview question? Largest Perimeter Triangle - Given an integer array nums, return the largest perimeter of a triangle with a non-zero area, formed from three of these lengths. If it is impossible to form any triangle of a non-zero area, return 0.\n\n \n\nExample 1:\n\n\nInput: nums = [2,1,2]\nOutput: 5\nExplanation: You can form a triangle with three side lengths: 1, 2, and 2.\n\n\nExample 2:\n\n\nInput: nums = [1,2,1,10]\nOutput: 0\nExplanation: \nYou cannot use the side lengths 1, 1, and 2 to form a triangle.\nYou cannot use the side lengths 1, 1, and 10 to form a triangle.\nYou cannot use the side lengths 1, 2, and 10 to form a triangle.\nAs we cannot use any three side lengths to form a triangle of non-zero area, we return 0.\n\n\n \n\nConstraints:\n\n * 3 <= nums.length <= 104\n * 1 <= nums[i] <= 106",
      "code": "class Solution {\npublic:\n    int largestPerimeter(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int largestPerimeter(int[] A) {\n        Arrays.sort(A);\n        for (int i = A.length - 3; i >= 0; --i)\n            if (A[i] + A[i+1] > A[i+2])\n                return A[i] + A[i+1] + A[i+2];\n        return 0;\n    }\n}"
      ]
    },
    {
      "number": 228,
      "question": "Can you solve this real interview question? Longest Turbulent Subarray - Given an integer array arr, return the length of a maximum size turbulent subarray of arr.\n\nA subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\n\nMore formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:\n\n * For i <= k < j:\n   * arr[k] > arr[k + 1] when k is odd, and\n   * arr[k] < arr[k + 1] when k is even.\n * Or, for i <= k < j:\n   * arr[k] > arr[k + 1] when k is even, and\n   * arr[k] < arr[k + 1] when k is odd.\n\n \n\nExample 1:\n\n\nInput: arr = [9,4,2,10,7,8,8,1,9]\nOutput: 5\nExplanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n\n\nExample 2:\n\n\nInput: arr = [4,8,12,16]\nOutput: 2\n\n\nExample 3:\n\n\nInput: arr = [100]\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 4 * 104\n * 0 <= arr[i] <= 109",
      "code": "class Solution {\npublic:\n    int maxTurbulenceSize(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int maxTurbulenceSize(int[] A) {\n        int N = A.length;\n        int ans = 1;\n        int anchor = 0;\n\n        for (int i = 1; i < N; ++i) {\n            int c = Integer.compare(A[i-1], A[i]);\n            if (c == 0) {\n                anchor = i;\n            } else if (i == N-1 || c * Integer.compare(A[i], A[i+1]) != -1) {\n                ans = Math.max(ans, i - anchor + 1);\n                anchor = i;\n            }\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 229,
      "question": "Can you solve this real interview question? Distribute Coins in Binary Tree - You are given the root of a binary tree with n nodes where each node in the tree has node.val coins. There are n coins in total throughout the whole tree.\n\nIn one move, we may choose two adjacent nodes and move one coin from one node to another. A move may be from parent to child, or from child to parent.\n\nReturn the minimum number of moves required to make every node have exactly one coin.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/01/18/tree1.png]\n\n\nInput: root = [3,0,0]\nOutput: 2\nExplanation: From the root of the tree, we move one coin to its left child, and one coin to its right child.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2019/01/18/tree2.png]\n\n\nInput: root = [0,3,0]\nOutput: 3\nExplanation: From the left child of the root, we move two coins to the root [taking two moves]. Then, we move one coin from the root of the tree to the right child.\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is n.\n * 1 <= n <= 100\n * 0 <= Node.val <= n\n * The sum of all Node.val is n.",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int distributeCoins(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    int ans;\n    public int distributeCoins(TreeNode root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    public int dfs(TreeNode node) {\n        if (node == null) return 0;\n        int L = dfs(node.left);\n        int R = dfs(node.right);\n        ans += Math.abs(L) + Math.abs(R);\n        return node.val + L + R - 1;\n    }\n}"
      ]
    },
    {
      "number": 230,
      "question": "Can you solve this real interview question? Minimum Cost For Tickets - You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\n\nTrain tickets are sold in three different ways:\n\n * a 1-day pass is sold for costs[0] dollars,\n * a 7-day pass is sold for costs[1] dollars, and\n * a 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\n * For example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n\n \n\nExample 1:\n\n\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n\n\nExample 2:\n\n\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n\n\n \n\nConstraints:\n\n * 1 <= days.length <= 365\n * 1 <= days[i] <= 365\n * days is in strictly increasing order.\n * costs.length == 3\n * 1 <= costs[i] <= 1000",
      "code": "class Solution {\npublic:\n    int mincostTickets(vector<int>& days, vector<int>& \ncosts) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    unordered_set<int> isTravelNeeded;\n    \n    int solve(vector<int>& dp, vector<int>& days, vector<int>& costs, int currDay) {\n        // If we have iterated over travel days, return 0.\n        if (currDay > days[days.size() - 1]) {\n            return 0;\n        }\n        \n        // If we don't need to travel on this day, move on to next day.\n        if (isTravelNeeded.find(currDay) == isTravelNeeded.end()) {\n            return solve(dp, days, costs, currDay + 1);\n        }\n        \n        // If already calculated, return from here with the stored answer.\n        if (dp[currDay] != -1) {\n            return dp[currDay];\n        }\n        \n        int oneDay = costs[0] + solve(dp, days, costs, currDay + 1);\n        int sevenDay = costs[1] + solve(dp, days, costs, currDay + 7);\n        int thirtyDay = costs[2] + solve(dp, days, costs, currDay + 30);\n        \n        // Store the cost with the minimum of the three options.\n        return dp[currDay] = min(oneDay, min(sevenDay, thirtyDay));\n    }\n    \n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        // The last day on which we need to travel.\n        int lastDay = days[days.size() - 1];\n        vector<int> dp(lastDay + 1, -1);\n        \n        // Mark the days on which we need to travel.\n        for (int day : days) {\n            isTravelNeeded.insert(day);\n        }\n        \n        return solve(dp, days, costs, 1);\n    }\n};",
        "class Solution {\npublic:\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\n        int lastDay = days[days.size() - 1];\n        vector<int> dp(lastDay + 1, 0);\n        \n        int i = 0;\n        for (int day = 1; day <= lastDay; day++) {\n            if (day < days[i]) {\n                dp[day] = dp[day - 1];\n            } else {\n                i++;\n                dp[day] = min({dp[day - 1] + costs[0],\n                               dp[max(0, day - 7)] + costs[1],\n                               dp[max(0, day - 30)] + costs[2]});\n            }\n        }\n     \n        return dp[lastDay];\n    }\n};"
      ]
    },
    {
      "number": 231,
      "question": "Can you solve this real interview question? String Without AAA or BBB - Given two integers a and b, return any string s such that:\n\n * s has length a + b and contains exactly a 'a' letters, and exactly b 'b' letters,\n * The substring 'aaa' does not occur in s, and\n * The substring 'bbb' does not occur in s.\n\n \n\nExample 1:\n\n\nInput: a = 1, b = 2\nOutput: \"abb\"\nExplanation: \"abb\", \"bab\" and \"bba\" are all correct answers.\n\n\nExample 2:\n\n\nInput: a = 4, b = 1\nOutput: \"aabaa\"\n\n\n \n\nConstraints:\n\n * 0 <= a, b <= 100\n * It is guaranteed such an s exists for the given a and b.",
      "code": "class Solution {\npublic:\n    string strWithout3a3b(int a, int b) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String strWithout3a3b(int A, int B) {\n        StringBuilder ans = new StringBuilder();\n\n        while (A > 0 || B > 0) {\n            boolean writeA = false;\n            int L = ans.length();\n            if (L >= 2 && ans.charAt(L-1) == ans.charAt(L-2)) {\n                if (ans.charAt(L-1) == 'b')\n                    writeA = true;\n            } else {\n                if (A >= B)\n                    writeA = true;\n            }\n\n            if (writeA) {\n                A--;\n                ans.append('a');\n            } else {\n                B--;\n                ans.append('b');\n            }\n        }\n\n        return ans.toString();\n    }\n}"
      ]
    },
    {
      "number": 232,
      "question": "Can you solve this real interview question? Sum of Even Numbers After Queries - You are given an integer array nums and an array queries where queries[i] = [vali, indexi].\n\nFor each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.\n\nReturn an integer array answer where answer[i] is the answer to the ith query.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\nOutput: [8,6,2,4]\nExplanation: At the beginning, the array is [1,2,3,4].\nAfter adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.\nAfter adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.\nAfter adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.\nAfter adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.\n\n\nExample 2:\n\n\nInput: nums = [1], queries = [[4,0]]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * -104 <= nums[i] <= 104\n * 1 <= queries.length <= 104\n * -104 <= vali <= 104\n * 0 <= indexi < nums.length",
      "code": "class Solution {\npublic:\n    vector<int> sumEvenAfterQueries(vector<int>& nums, \nvector<vector<int>>& queries) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] sumEvenAfterQueries(int[] A, int[][] queries) {\n        int S = 0;\n        for (int x: A)\n            if (x % 2 == 0)\n                S += x;\n\n        int[] ans = new int[queries.length];\n\n        for (int i = 0; i < queries.length; ++i) {\n            int val = queries[i][0], index = queries[i][1];\n            if (A[index] % 2 == 0) S -= A[index];\n            A[index] += val;\n            if (A[index] % 2 == 0) S += A[index];\n            ans[i] = S;\n        }\n\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 233,
      "question": "Can you solve this real interview question? Smallest String Starting From Leaf - You are given the root of a binary tree where each node has a value in the range [0, 25] representing the letters 'a' to 'z'.\n\nReturn the lexicographically smallest string that starts at a leaf of this tree and ends at the root.\n\nAs a reminder, any shorter prefix of a string is lexicographically smaller.\n\n * For example, \"ab\" is lexicographically smaller than \"aba\".\n\nA leaf of a node is a node that has no children.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/01/30/tree1.png]\n\n\nInput: root = [0,1,2,3,4,3,4]\nOutput: \"dba\"\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2019/01/30/tree2.png]\n\n\nInput: root = [25,1,3,1,3,0,2]\nOutput: \"adz\"\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2019/02/01/tree3.png]\n\n\nInput: root = [2,2,1,null,1,0,null,0]\nOutput: \"abc\"\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 8500].\n * 0 <= Node.val <= 25",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    string smallestFromLeaf(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    String ans = \"~\";\n    public String smallestFromLeaf(TreeNode root) {\n        dfs(root, new StringBuilder());\n        return ans;\n    }\n\n    public void dfs(TreeNode node, StringBuilder sb) {\n        if (node == null) return;\n        sb.append((char)('a' + node.val));\n\n        if (node.left == null && node.right == null) {\n            sb.reverse();\n            String S = sb.toString();\n            sb.reverse();\n\n            if (S.compareTo(ans) < 0)\n                ans = S;\n        }\n\n        dfs(node.left, sb);\n        dfs(node.right, sb);\n        sb.deleteCharAt(sb.length() - 1);\n    }\n}"
      ]
    },
    {
      "number": 234,
      "question": "Can you solve this real interview question? Add to Array-Form of Integer - The array-form of an integer num is an array representing its digits in left to right order.\n\n * For example, for num = 1321, the array form is [1,3,2,1].\n\nGiven num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.\n\n \n\nExample 1:\n\n\nInput: num = [1,2,0,0], k = 34\nOutput: [1,2,3,4]\nExplanation: 1200 + 34 = 1234\n\n\nExample 2:\n\n\nInput: num = [2,7,4], k = 181\nOutput: [4,5,5]\nExplanation: 274 + 181 = 455\n\n\nExample 3:\n\n\nInput: num = [2,1,5], k = 806\nOutput: [1,0,2,1]\nExplanation: 215 + 806 = 1021\n\n\n \n\nConstraints:\n\n * 1 <= num.length <= 104\n * 0 <= num[i] <= 9\n * num does not contain any leading zeros except for the zero itself.\n * 1 <= k <= 104",
      "code": "class Solution {\npublic:\n    vector<int> addToArrayForm(vector<int>& num, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<Integer> addToArrayForm(int[] A, int K) {\n        int N = A.length;\n        int cur = K;\n        List<Integer> ans = new ArrayList();\n\n        int i = N;\n        while (--i >= 0 || cur > 0) {\n            if (i >= 0)\n                cur += A[i];\n            ans.add(cur % 10);\n            cur /= 10;\n        }\n\n        Collections.reverse(ans);\n        return ans;\n    }\n}"
      ]
    },
    {
      "number": 235,
      "question": "Can you solve this real interview question? Broken Calculator - There is a broken calculator that has the integer startValue on its display initially. In one operation, you can:\n\n * multiply the number on display by 2, or\n * subtract 1 from the number on display.\n\nGiven two integers startValue and target, return the minimum number of operations needed to display target on the calculator.\n\n \n\nExample 1:\n\n\nInput: startValue = 2, target = 3\nOutput: 2\nExplanation: Use double operation and then decrement operation {2 -> 4 -> 3}.\n\n\nExample 2:\n\n\nInput: startValue = 5, target = 8\nOutput: 2\nExplanation: Use decrement and then double {5 -> 4 -> 8}.\n\n\nExample 3:\n\n\nInput: startValue = 3, target = 10\nOutput: 3\nExplanation: Use double, decrement and double {3 -> 6 -> 5 -> 10}.\n\n\n \n\nConstraints:\n\n * 1 <= startValue, target <= 109",
      "code": "class Solution {\npublic:\n    int brokenCalc(int startValue, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int brokenCalc(int startValue, int target) {\n        int ans = 0;\n        while (target > startValue) {\n            ans++;\n            if (target % 2 == 1)\n                target++;\n            else\n                target /= 2;\n        }\n\n        return ans + startValue - target;\n    }\n}"
      ]
    },
    {
      "number": 236,
      "question": "Can you solve this real interview question? Subarrays with K Different Integers - Given an integer array nums and an integer k, return the number of good subarrays of nums.\n\nA good array is an array where the number of different integers in that array is exactly k.\n\n * For example, [1,2,3,1,2] has 3 different integers: 1, 2, and 3.\n\nA subarray is a contiguous part of an array.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,1,2,3], k = 2\nOutput: 7\nExplanation: Subarrays formed with exactly 2 different integers: [1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2]\n\n\nExample 2:\n\n\nInput: nums = [1,2,1,3,4], k = 3\nOutput: 3\nExplanation: Subarrays formed with exactly 3 different integers: [1,2,1,3], [2,1,3], [1,3,4].\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 2 * 104\n * 1 <= nums[i], k <= nums.length",
      "code": "class Solution {\npublic:\n    int subarraysWithKDistinct(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int subarraysWithKDistinct(int[] A, int K) {\n        Window window1 = new Window();\n        Window window2 = new Window();\n        int ans = 0, left1 = 0, left2 = 0;\n\n        for (int right = 0; right < A.length; ++right) {\n            int x = A[right];\n            window1.add(x);\n            window2.add(x);\n\n            while (window1.different() > K)\n                window1.remove(A[left1++]);\n            while (window2.different() >= K)\n                window2.remove(A[left2++]);\n\n            ans += left2 - left1;\n        }\n\n        return ans;\n    }\n}\n\nclass Window {\n    Map<Integer, Integer> count;\n    int nonzero;\n\n    Window() {\n        count = new HashMap();\n        nonzero = 0;\n    }\n\n    void add(int x) {\n        count.put(x, count.getOrDefault(x, 0) + 1);\n        if (count.get(x) == 1)\n            nonzero++;\n    }\n\n    void remove(int x) {\n        count.put(x, count.get(x) - 1);\n        if (count.get(x) == 0)\n            nonzero--;\n    }\n\n    int different() {\n        return nonzero;\n    }\n}"
      ]
    },
    {
      "number": 237,
      "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
      "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
      ]
    },
    {
      "number": 238,
      "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
      "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 239,
      "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
      ]
    },
    {
      "number": 240,
      "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
      ]
    },
    {
      "number": 241,
      "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
      "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
      ]
    },
    {
      "number": 242,
      "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
      "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
      ]
    },
    {
      "number": 243,
      "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
      "solution": [
        "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
        "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
      ]
    },
    {
      "number": 244,
      "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
        "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
      ]
    },
    {
      "number": 245,
      "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
      ]
    },
    {
      "number": 246,
      "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
      "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
      ]
    },
    {
      "number": 247,
      "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
      ]
    },
    {
      "number": 248,
      "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
      "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
        "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 249,
      "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
      "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
      ]
    },
    {
      "number": 250,
      "question": "Can you solve this real interview question? Product Sales Analysis I - Table: Sales\n\n\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) is the primary key (combination of columns with unique values) of this table.\nproduct_id is a foreign key (reference column) to Product table.\nEach row of this table shows a sale on the product product_id in a certain year.\nNote that the price is per unit.\n\n\n \n\nTable: Product\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id is the primary key (column with unique values) of this table.\nEach row of this table indicates the product name of each product.\n\n\n \n\nWrite a solution to report the product_name, year, and price for each sale_id in the Sales table.\n\nReturn the resulting table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nSales table:\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\nProduct table:\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\nOutput: \n+--------------+-------+-------+\n| product_name | year  | price |\n+--------------+-------+-------+\n| Nokia        | 2008  | 5000  |\n| Nokia        | 2009  | 5000  |\n| Apple        | 2011  | 9000  |\n+--------------+-------+-------+\nExplanation: \nFrom sale_id = 1, we can conclude that Nokia was sold for 5000 in the year 2008.\nFrom sale_id = 2, we can conclude that Nokia was sold for 5000 in the year 2009.\nFrom sale_id = 7, we can conclude that Apple was sold for 9000 in the year 2011.\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef sales_analysis(sales: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\n    sales_and_product = sales.merge(\n        product,\n        on=[\"product_id\"]\n        )\n    df = sales_and_product[['product_name', 'year', 'price']]\n\n    return df"
      ]
    },
    {
      "number": 251,
      "question": "Can you solve this real interview question? Product Sales Analysis II - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
      "code": "",
      "solution": [
        "import pandas as pd\n\ndef sales_analysis(sales: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\n\n    pd = sales.groupby(['product_id'], as_index = False)['quantity'].sum().rename(columns = {'quantity': 'total_quantity'})\n\n    return pd"
      ]
    },
    {
      "number": 252,
      "question": "Can you solve this real interview question? Product Sales Analysis III - Table: Sales\n\n\n+-------------+-------+\n| Column Name | Type  |\n+-------------+-------+\n| sale_id     | int   |\n| product_id  | int   |\n| year        | int   |\n| quantity    | int   |\n| price       | int   |\n+-------------+-------+\n(sale_id, year) is the primary key (combination of columns with unique values) of this table.\nproduct_id is a foreign key (reference column) to Product table.\nEach row of this table shows a sale on the product product_id in a certain year.\nNote that the price is per unit.\n\n\n \n\nTable: Product\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n+--------------+---------+\nproduct_id is the primary key (column with unique values) of this table.\nEach row of this table indicates the product name of each product.\n\n\n \n\nWrite a solution to select the product id, year, quantity, and price for the first year of every product sold.\n\nReturn the resulting table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nSales table:\n+---------+------------+------+----------+-------+\n| sale_id | product_id | year | quantity | price |\n+---------+------------+------+----------+-------+ \n| 1       | 100        | 2008 | 10       | 5000  |\n| 2       | 100        | 2009 | 12       | 5000  |\n| 7       | 200        | 2011 | 15       | 9000  |\n+---------+------------+------+----------+-------+\nProduct table:\n+------------+--------------+\n| product_id | product_name |\n+------------+--------------+\n| 100        | Nokia        |\n| 200        | Apple        |\n| 300        | Samsung      |\n+------------+--------------+\nOutput: \n+------------+------------+----------+-------+\n| product_id | first_year | quantity | price |\n+------------+------------+----------+-------+ \n| 100        | 2008       | 10       | 5000  |\n| 200        | 2011       | 15       | 9000  |\n+------------+------------+----------+-------+\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef sales_analysis(sales: pd.DataFrame, product: pd.DataFrame) -> pd.DataFrame:\n  df = sales.groupby('product_id', as_index=False)['year'].min()\n  return sales.merge(df, on='product_id', how='inner')\\\n    .query('year_x == year_y')\\\n    .rename(columns={'year_x': 'first_year'})\\\n    [['product_id', 'first_year', 'quantity', 'price']]\n  "
      ]
    },
    {
      "number": 253,
      "question": "Can you solve this real interview question? Greatest Common Divisor of Strings - For two strings s and t, we say \"t divides s\" if and only if s = t + ... + t (i.e., t is concatenated with itself one or more times).\n\nGiven two strings str1 and str2, return the largest string x such that x divides both str1 and str2.\n\n \n\nExample 1:\n\n\nInput: str1 = \"ABCABC\", str2 = \"ABC\"\nOutput: \"ABC\"\n\n\nExample 2:\n\n\nInput: str1 = \"ABABAB\", str2 = \"ABAB\"\nOutput: \"AB\"\n\n\nExample 3:\n\n\nInput: str1 = \"LEET\", str2 = \"CODE\"\nOutput: \"\"\n\n\n \n\nConstraints:\n\n * 1 <= str1.length, str2.length <= 1000\n * str1 and str2 consist of English uppercase letters.",
      "code": "class Solution {\npublic:\n    string gcdOfStrings(string str1, string str2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool valid(string str1, string str2, int k) {\n        int len1 = str1.size(), len2 = str2.size();\n        if (len1 % k > 0 || len2 % k > 0) {\n            return false;\n        } else {\n            string base = str1.substr(0, k);\n            int n1 = len1 / k, n2 = len2 / k;\n            return str1 == joinWords(base, n1) && str2 == joinWords(base, n2);\n        }\n    }\n    string joinWords(string str, int k) {\n        string ans = \"\";\n        for (int i = 0; i < k; ++i) {\n            ans += str;\n        }\n        return ans;\n    }\n    \n    \n    string gcdOfStrings(string str1, string str2) {\n        int len1 = str1.length(), len2 = str2.length();\n        for (int i = min(len1, len2); i >= 1; --i) {\n            if (valid(str1, str2, i)) {\n                return str1.substr(0, i);\n            }\n        }\n        return \"\";\n    }\n};",
        "class Solution {\npublic:\n    string gcdOfStrings(string str1, string str2) {\n        // Check if they have non-zero GCD string.\n        if (str1 + str2 != str2 + str1) {\n            return \"\";\n        }\n\n        // Get the GCD of the two lengths.\n        int gcdLength = gcd(str1.size(), str2.size());\n        return str1.substr(0, gcdLength);\n    }\n};"
      ]
    },
    {
      "number": 254,
      "question": "Can you solve this real interview question? Sales Analysis III - Table: Product\n\n\n+--------------+---------+\n| Column Name  | Type    |\n+--------------+---------+\n| product_id   | int     |\n| product_name | varchar |\n| unit_price   | int     |\n+--------------+---------+\nproduct_id is the primary key (column with unique values) of this table.\nEach row of this table indicates the name and the price of each product.\n\n\nTable: Sales\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| seller_id   | int     |\n| product_id  | int     |\n| buyer_id    | int     |\n| sale_date   | date    |\n| quantity    | int     |\n| price       | int     |\n+-------------+---------+\nThis table can have duplicate rows.\nproduct_id is a foreign key (reference column) to the Product table.\nEach row of this table contains some information about one sale.\n\n\n \n\nWrite a solution to report the products that were only sold in the first quarter of 2019. That is, between 2019-01-01 and 2019-03-31 inclusive.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nProduct table:\n+------------+--------------+------------+\n| product_id | product_name | unit_price |\n+------------+--------------+------------+\n| 1          | S8           | 1000       |\n| 2          | G4           | 800        |\n| 3          | iPhone       | 1400       |\n+------------+--------------+------------+\nSales table:\n+-----------+------------+----------+------------+----------+-------+\n| seller_id | product_id | buyer_id | sale_date  | quantity | price |\n+-----------+------------+----------+------------+----------+-------+\n| 1         | 1          | 1        | 2019-01-21 | 2        | 2000  |\n| 1         | 2          | 2        | 2019-02-17 | 1        | 800   |\n| 2         | 2          | 3        | 2019-06-02 | 1        | 800   |\n| 3         | 3          | 4        | 2019-05-13 | 2        | 2800  |\n+-----------+------------+----------+------------+----------+-------+\nOutput: \n+-------------+--------------+\n| product_id  | product_name |\n+-------------+--------------+\n| 1           | S8           |\n+-------------+--------------+\nExplanation: \nThe product with id 1 was only sold in the spring of 2019.\nThe product with id 2 was sold in the spring of 2019 but was also sold after the spring of 2019.\nThe product with id 3 was sold after spring 2019.\nWe return only product 1 as it is the product that was only sold in the spring of 2019.\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef sales_analysis(product: pd.DataFrame, sales: pd.DataFrame) -> pd.DataFrame:\n    start_time = pd.to_datetime('2019-01-01')\n    end_time = pd.to_datetime('2019-03-31')\n    df = sales.groupby('product_id').filter(lambda x:\n        min(x['sale_date']) >= start_time and max(x['sale_date']) <= end_time\n    )\n    df = df.drop_duplicates(subset = 'product_id')\n    df = df.merge(product, left_on = 'product_id', right_on = 'product_id')\n    return df[['product_id', 'product_name']]"
      ]
    },
    {
      "number": 255,
      "question": "Can you solve this real interview question? Duplicate Zeros - Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.\n\nNote that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.\n\n \n\nExample 1:\n\n\nInput: arr = [1,0,2,3,0,4,5,0]\nOutput: [1,0,0,2,3,0,0,4]\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\n\nExample 2:\n\n\nInput: arr = [1,2,3]\nOutput: [1,2,3]\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 104\n * 0 <= arr[i] <= 9",
      "code": "class Solution {\npublic:\n    void duplicateZeros(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public void duplicateZeros(int[] arr) {\n        int possibleDups = 0;\n        int length_ = arr.length - 1;\n\n        // Find the number of zeros to be duplicated\n        // Stopping when left points beyond the last element in the original array\n        // which would be part of the modified array\n        for (int left = 0; left <= length_ - possibleDups; left++) {\n\n            // Count the zeros\n            if (arr[left] == 0) {\n\n                // Edge case: This zero can't be duplicated. We have no more space,\n                // as left is pointing to the last element which could be included  \n                if (left == length_ - possibleDups) {\n                    // For this zero we just copy it without duplication.\n                    arr[length_] = 0;\n                    length_ -= 1;\n                    break;\n                }\n                possibleDups++;\n            }\n        }\n\n        // Start backwards from the last element which would be part of new array.\n        int last = length_ - possibleDups;\n\n        // Copy zero twice, and non zero once.\n        for (int i = last; i >= 0; i--) {\n            if (arr[i] == 0) {\n                arr[i + possibleDups] = 0;\n                possibleDups--;\n                arr[i + possibleDups] = 0;\n            } else {\n                arr[i + possibleDups] = arr[i];\n            }\n        }\n    }\n}"
      ]
    },
    {
      "number": 256,
      "question": "Can you solve this real interview question? Find in Mountain Array - (This problem is an interactive problem.)\n\nYou may recall that an array arr is a mountain array if and only if:\n\n * arr.length >= 3\n * There exists some i with 0 < i < arr.length - 1 such that:\n   * arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n   * arr[i] > arr[i + 1] > ... > arr[arr.length - 1]\n\nGiven a mountain array mountainArr, return the minimum index such that mountainArr.get(index) == target. If such an index does not exist, return -1.\n\nYou cannot access the mountain array directly. You may only access the array using a MountainArray interface:\n\n * MountainArray.get(k) returns the element of the array at index k (0-indexed).\n * MountainArray.length() returns the length of the array.\n\nSubmissions making more than 100 calls to MountainArray.get will be judged Wrong Answer. Also, any solutions that attempt to circumvent the judge will result in disqualification.\n\n \n\nExample 1:\n\n\nInput: array = [1,2,3,4,5,3,1], target = 3\nOutput: 2\nExplanation: 3 exists in the array, at index=2 and index=5. Return the minimum index, which is 2.\n\nExample 2:\n\n\nInput: array = [0,1,2,4,2,1], target = 3\nOutput: -1\nExplanation: 3 does not exist in the array, so we return -1.\n\n\n \n\nConstraints:\n\n * 3 <= mountain_arr.length() <= 104\n * 0 <= target <= 109\n * 0 <= mountain_arr.get(index) <= 109",
      "code": "/**\n * // This is the MountainArray's API interface.\n * // You should not implement it, or speculate about its \nimplementation\n * class MountainArray {\n *   public:\n *     int get(int index);\n *     int length();\n * };\n */\n\nclass Solution {\npublic:\n    int findInMountainArray(int target, MountainArray &\nmountainArr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int findInMountainArray(int target, MountainArray &mountainArr) {\n        // Save the length of the mountain array\n        int length = mountainArr.length();\n\n        // 1. Find the index of the peak element\n        int low = 1;\n        int high = length - 2;\n        while (low != high) {\n            int testIndex = (low + high) / 2;\n            if (mountainArr.get(testIndex) < mountainArr.get(testIndex + 1)) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex;\n            }\n        }\n        int peakIndex = low;\n\n        // 2. Search in the strictly increasing part of the array\n        low = 0;\n        high = peakIndex;\n        while (low != high) {\n            int testIndex = (low + high) / 2;\n            if (mountainArr.get(testIndex) < target) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex;\n            }\n        }\n        // Check if the target is present in the strictly increasing part\n        if (mountainArr.get(low) == target) {\n            return low;\n        }\n\n        // 3. Otherwise, search in the strictly decreasing part\n        low = peakIndex + 1;\n        high = length - 1;\n        while (low != high) {\n            int testIndex = (low + high) / 2;\n            if (mountainArr.get(testIndex) > target) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex;\n            }\n        }\n        // Check if the target is present in the strictly decreasing part\n        if (mountainArr.get(low) == target) {\n            return low;\n        }\n\n        // Target is not present in the mountain array\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    int findInMountainArray(int target, MountainArray &mountainArr) {\n        // Save the length of the mountain array\n        int length = mountainArr.length();\n\n        // Initialize the cache\n        unordered_map<int, int> cache;\n\n        // 1. Find the index of the peak element\n        int low = 1;\n        int high = length - 2;\n        while (low != high) {\n            int testIndex = (low + high) >> 1;\n\n            int curr;\n            if (cache.find(testIndex) != cache.end()) {\n                curr = cache[testIndex];\n            } else {\n                curr = mountainArr.get(testIndex);\n                cache[testIndex] = curr;\n            }\n\n            int next;\n            if (cache.find(testIndex + 1) != cache.end()) {\n                next = cache[testIndex + 1];\n            } else {\n                next = mountainArr.get(testIndex + 1);\n                cache[testIndex + 1] = next;\n            }\n\n            if (curr < next) {\n                if (curr == target) {\n                    return testIndex;\n                }\n                if (next == target) {\n                    return testIndex + 1;\n                }\n                low = testIndex + 1;\n            } else {\n                high = testIndex;\n            }\n        }\n\n        int peakIndex = low;\n\n        // 2. Search in the strictly increasing part of the array\n        // If found, will be returned in the loop itself.\n        low = 0;\n        high = peakIndex;\n        while (low <= high) {\n            int testIndex = (low + high) >> 1;\n\n            int curr;\n            if (cache.find(testIndex) != cache.end()) {\n                curr = cache[testIndex];\n            } else {\n                curr = mountainArr.get(testIndex);\n            }\n                \n            if (curr == target) {\n                return testIndex;\n            } else if (curr < target) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex - 1;\n            }\n        }\n\n        // 3. Search in the strictly decreasing part of the array\n        // If found, will be returned in the loop itself.\n        low = peakIndex + 1;\n        high = length - 1;\n        while (low <= high) {\n            int testIndex = (low + high) >> 1;\n\n            int curr;\n            if (cache.find(testIndex) != cache.end()) {\n                curr = cache[testIndex];\n            } else {\n                curr = mountainArr.get(testIndex);\n            }\n                \n            if (curr == target) {\n                return testIndex;\n            } else if (curr > target) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex - 1;\n            }\n        }\n\n        // Target is not present in the mountain array\n        return -1;\n    }\n}; ",
        "class Solution {\npublic:\n    int findInMountainArray(int target, MountainArray &mountainArr) {\n        // Save the length of the mountain array\n        int length = mountainArr.length();\n\n        // 1. Find the index of the peak element\n        int low = 1;\n        int high = length - 2;\n        while (low != high) {\n            int testIndex = (low + high) >> 1;\n            int curr = mountainArr.get(testIndex);\n            int next = mountainArr.get(testIndex + 1);\n            \n            if (curr < next) {\n                if (curr == target) {\n                    return testIndex;\n                }\n                if (next == target) {\n                    return testIndex + 1;\n                }\n                low = testIndex + 1;\n            } else {\n                high = testIndex;\n            }\n        }\n\n        int peakIndex = low;\n\n        // 2. Search in the strictly increasing part of the array\n        // If found, will be returned in the loop itself.\n        low = 0;\n        high = peakIndex;\n        while (low <= high) {\n            int testIndex = (low + high) >> 1;\n            int curr = mountainArr.get(testIndex);\n                \n            if (curr == target) {\n                return testIndex;\n            } else if (curr < target) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex - 1;\n            }\n        }\n\n        // 3. Search in the strictly decreasing part of the array\n        // If found, will be returned in the loop itself.\n        low = peakIndex + 1;\n        high = length - 1;\n        while (low <= high) {\n            int testIndex = (low + high) >> 1;\n            int curr = mountainArr.get(testIndex);\n                \n            if (curr == target) {\n                return testIndex;\n            } else if (curr > target) {\n                low = testIndex + 1;\n            } else {\n                high = testIndex - 1;\n            }\n        }\n        \n        // Target is not present in the mountain array\n        return -1;\n    }\n};"
      ]
    },
    {
      "number": 257,
      "question": "Can you solve this real interview question? Smallest Sufficient Team - In a project, you have a list of required skills req_skills, and a list of people. The ith person people[i] contains a list of skills that the person has.\n\nConsider a sufficient team: a set of people such that for every required skill in req_skills, there is at least one person in the team who has that skill. We can represent these teams by the index of each person.\n\n * For example, team = [0, 1, 3] represents the people with skills people[0], people[1], and people[3].\n\nReturn any sufficient team of the smallest possible size, represented by the index of each person. You may return the answer in any order.\n\nIt is guaranteed an answer exists.\n\n \n\nExample 1:\n\nInput: req_skills = [\"java\",\"nodejs\",\"reactjs\"], people = [[\"java\"],[\"nodejs\"],[\"nodejs\",\"reactjs\"]]\nOutput: [0,2]\n\n\nExample 2:\n\nInput: req_skills = [\"algorithms\",\"math\",\"java\",\"reactjs\",\"csharp\",\"aws\"], people = [[\"algorithms\",\"math\",\"java\"],[\"algorithms\",\"math\",\"reactjs\"],[\"java\",\"csharp\",\"aws\"],[\"reactjs\",\"csharp\"],[\"csharp\",\"math\"],[\"aws\",\"java\"]]\nOutput: [1,2]\n\n\n \n\nConstraints:\n\n * 1 <= req_skills.length <= 16\n * 1 <= req_skills[i].length <= 16\n * req_skills[i] consists of lowercase English letters.\n * All the strings of req_skills are unique.\n * 1 <= people.length <= 60\n * 0 <= people[i].length <= 16\n * 1 <= people[i][j].length <= 16\n * people[i][j] consists of lowercase English letters.\n * All the strings of people[i] are unique.\n * Every skill in people[i] is a skill in req_skills.\n * It is guaranteed a sufficient team exists.",
      "code": "class Solution {\npublic:\n    vector<int> smallestSufficientTeam(vector<string>& \nreq_skills, vector<vector<string>>& people) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n        int n = people.size(), m = req_skills.size();\n        unordered_map<string, int> skillId;\n        for (int i = 0; i < m; i++) {\n            skillId[req_skills[i]] = i;\n        }\n        vector<int> skillsMaskOfPerson(n);\n        for (int i = 0; i < n; i++) {\n            for (string skill : people[i]) {\n                skillsMaskOfPerson[i] |= 1 << skillId[skill];\n            }\n        }\n        vector<long long> dp(1 << m, (1LL << n) - 1);\n        dp[0] = 0;\n        for (int skillsMask = 1; skillsMask < (1 << m); skillsMask++) {\n            for (int i = 0; i < n; i++) {\n                int smallerSkillsMask = skillsMask & ~skillsMaskOfPerson[i];\n                if (smallerSkillsMask != skillsMask) {\n                    long long peopleMask = dp[smallerSkillsMask] | (1LL << i);\n                    if (__builtin_popcountll(peopleMask) < __builtin_popcountll(dp[skillsMask])) {\n                        dp[skillsMask] = peopleMask;\n                    }\n                }\n            }\n        }\n        long long answerMask = dp[(1 << m) - 1];\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if ((answerMask >> i) & 1) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> smallestSufficientTeam(vector<string>& req_skills, vector<vector<string>>& people) {\n        int n = people.size(), m = req_skills.size();\n        unordered_map<string, int> skillId;\n        for (int i = 0; i < m; i++) {\n            skillId[req_skills[i]] = i;\n        }\n        vector<int> skillsMaskOfPerson(n);\n        vector<long long> dp(1 << m, -1);\n        for (int i = 0; i < n; i++) {\n            for (string skill : people[i]) {\n                skillsMaskOfPerson[i] |= 1 << skillId[skill];\n            }\n        }\n        function<long long(int)> f = [&](int skillsMask) -> long long {\n            if (skillsMask == 0) {\n                return 0;\n            }\n            if (dp[skillsMask] != -1) {\n                return dp[skillsMask];\n            }\n            for (int i = 0; i < n; i++) {\n                int smallerSkillsMask = skillsMask & ~skillsMaskOfPerson[i];\n                if (smallerSkillsMask != skillsMask) {\n                    long long peopleMask = f(smallerSkillsMask) | (1LL << i);\n                    if (dp[skillsMask] == -1 || __builtin_popcountll(peopleMask) <\n                                                    __builtin_popcountll(dp[skillsMask])) {\n                        dp[skillsMask] = peopleMask;\n                    }\n                }\n            }\n            return dp[skillsMask];\n        };\n        long long answerMask = f((1 << m) - 1);\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            if ((answerMask >> i) & 1) {\n                ans.push_back(i);\n            }\n        }\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 258,
      "question": "Can you solve this real interview question? Reported Posts II - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
      "code": "",
      "solution": [
        "import pandas as pd\n\ndef reported_posts(actions: pd.DataFrame, removals: pd.DataFrame) -> pd.DataFrame:\n\n    spam = actions[actions['extra'] == 'spam'].drop_duplicates(['action_date', 'post_id'])\n\n    removed_spam = spam.merge(removals, on='post_id', how='left')\n\n    df = removed_spam.groupby(\"action_date\", as_index=False).agg(\n        removed_spam=('remove_date', 'count'), \n        total_spam=('remove_date', 'size')\n    )\n    \n    df = df.assign(average_daily_percent = df['removed_spam']*100/df['total_spam'])\n\n    avg = df.agg({'average_daily_percent': ['mean']}).round(2)\n\n    return avg"
      ]
    },
    {
      "number": 259,
      "question": "Can you solve this real interview question? Stone Game II - Alice and Bob continue their games with piles of stones.  There are a number of piles arranged in a row, and each pile has a positive integer number of stones piles[i].  The objective of the game is to end with the most stones. \n\nAlice and Bob take turns, with Alice starting first.  Initially, M = 1.\n\nOn each player's turn, that player can take all the stones in the first X remaining piles, where 1 <= X <= 2M.  Then, we set M = max(M, X).\n\nThe game continues until all the stones have been taken.\n\nAssuming Alice and Bob play optimally, return the maximum number of stones Alice can get.\n\n \n\nExample 1:\n\n\nInput: piles = [2,7,9,4,4]\nOutput: 10\nExplanation:  If Alice takes one pile at the beginning, Bob takes two piles, then Alice takes 2 piles again. Alice can get 2 + 4 + 4 = 10 piles in total. If Alice takes two piles at the beginning, then Bob can take all three piles left. In this case, Alice get 2 + 7 = 9 piles in total. So we return 10 since it's larger. \n\n\nExample 2:\n\n\nInput: piles = [1,2,3,4,5,100]\nOutput: 104\n\n\n \n\nConstraints:\n\n * 1 <= piles.length <= 100\n * 1 <= piles[i] <= 104",
      "code": "class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int n = piles.size();\n        function<int(int, int, int)> f = [&](int p, int i, int m) -> int {\n            if (i == n) {\n                return 0;\n            }\n            int res = p == 1 ? 1000000 : -1, s = 0;\n            for (int x = 1; x <= min(2 * m, n - i); x++) {\n                s += piles[i + x - 1];\n                if (p == 0) {\n                    res = max(res, s + f(1, i + x, max(m, x)));\n                }\n                else {\n                    res = min(res, f(0, i + x, max(m, x)));\n                }\n            }\n            return res;\n        };\n        return f(0, 0, 1);\n    }\n};",
        "class Solution {\npublic:\n    int stoneGameII(vector<int>& piles) {\n        int n = piles.size();\n        vector dp(2, vector(n + 1, vector<int>(n + 1, -1)));\n        \n        function<int(int, int, int)> f = [&](int p, int i, int m) -> int {\n            if (i == n) {\n                return 0;\n            }\n            if (dp[p][i][m] != -1) {\n                return dp[p][i][m];\n            }\n            int res = p == 1 ? 1000000 : -1, s = 0;\n            for (int x = 1; x <= min(2 * m, n - i); x++) {\n                s += piles[i + x - 1];\n                if (p == 0) {\n                    res = max(res, s + f(1, i + x, max(m, x)));\n                }\n                else {\n                    res = min(res, f(0, i + x, max(m, x)));\n                }\n            }\n            return dp[p][i][m] = res;\n        };\n        \n        return f(0, 0, 1);\n    }\n};"
      ]
    },
    {
      "number": 260,
      "question": "Can you solve this real interview question? Snapshot Array - Implement a SnapshotArray that supports the following interface:\n\n * SnapshotArray(int length) initializes an array-like data structure with the given length. Initially, each element equals 0.\n * void set(index, val) sets the element at the given index to be equal to val.\n * int snap() takes a snapshot of the array and returns the snap_id: the total number of times we called snap() minus 1.\n * int get(index, snap_id) returns the value at the given index, at the time we took the snapshot with the given snap_id\n\n \n\nExample 1:\n\n\nInput: [\"SnapshotArray\",\"set\",\"snap\",\"set\",\"get\"]\n[[3],[0,5],[],[0,6],[0,0]]\nOutput: [null,null,0,null,5]\nExplanation: \nSnapshotArray snapshotArr = new SnapshotArray(3); // set the length to be 3\nsnapshotArr.set(0,5);  // Set array[0] = 5\nsnapshotArr.snap();  // Take a snapshot, return snap_id = 0\nsnapshotArr.set(0,6);\nsnapshotArr.get(0,0);  // Get the value of array[0] with snap_id = 0, return 5\n\n \n\nConstraints:\n\n * 1 <= length <= 5 * 104\n * 0 <= index < length\n * 0 <= val <= 109\n * 0 <= snap_id < (the total number of times we call snap())\n * At most 5 * 104 calls will be made to set, snap, and get.",
      "code": "class SnapshotArray {\npublic:\n    SnapshotArray(int length) {\n        \n    }\n    \n    void set(int index, int val) {\n        \n    }\n    \n    int snap() {\n        \n    }\n    \n    int get(int index, int snap_id) {\n        \n    }\n};\n\n/**\n * Your SnapshotArray object will be instantiated and \ncalled as such:\n * SnapshotArray* obj = new SnapshotArray(length);\n * obj->set(index,val);\n * int param_2 = obj->snap();",
      "solution": [
        "class SnapshotArray {\npublic:\n    int snapId;\n    vector<vector<pair<int, int>>> historyRecords;\n    SnapshotArray(int length) {\n        snapId = 0;\n        historyRecords.resize(length);\n        for (int i = 0; i < length; ++i) {\n            historyRecords[i].push_back(make_pair(0, 0));\n        }\n    }\n    \n    void set(int index, int val) {\n        historyRecords[index].push_back(make_pair(snapId, val));\n    }\n    \n    int snap() {\n        return snapId++;\n    }\n    \n    int get(int index, int snap_id) {\n        auto it = upper_bound(historyRecords[index].begin(), historyRecords[index].end(), make_pair(snap_id, INT_MAX));\n        return prev(it)->second;\n    }\n};"
      ]
    },
    {
      "number": 261,
      "question": "Can you solve this real interview question? Market Analysis I - Table: Users\n\n\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| user_id        | int     |\n| join_date      | date    |\n| favorite_brand | varchar |\n+----------------+---------+\nuser_id is the primary key (column with unique values) of this table.\nThis table has the info of the users of an online shopping website where users can sell and buy items.\n\n\n \n\nTable: Orders\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| order_id      | int     |\n| order_date    | date    |\n| item_id       | int     |\n| buyer_id      | int     |\n| seller_id     | int     |\n+---------------+---------+\norder_id is the primary key (column with unique values) of this table.\nitem_id is a foreign key (reference column) to the Items table.\nbuyer_id and seller_id are foreign keys to the Users table.\n\n\n \n\nTable: Items\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| item_id       | int     |\n| item_brand    | varchar |\n+---------------+---------+\nitem_id is the primary key (column with unique values) of this table.\n\n\n \n\nWrite a solution to find for each user, the join date and the number of orders they made as a buyer in 2019.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nUsers table:\n+---------+------------+----------------+\n| user_id | join_date  | favorite_brand |\n+---------+------------+----------------+\n| 1       | 2018-01-01 | Lenovo         |\n| 2       | 2018-02-09 | Samsung        |\n| 3       | 2018-01-19 | LG             |\n| 4       | 2018-05-21 | HP             |\n+---------+------------+----------------+\nOrders table:\n+----------+------------+---------+----------+-----------+\n| order_id | order_date | item_id | buyer_id | seller_id |\n+----------+------------+---------+----------+-----------+\n| 1        | 2019-08-01 | 4       | 1        | 2         |\n| 2        | 2018-08-02 | 2       | 1        | 3         |\n| 3        | 2019-08-03 | 3       | 2        | 3         |\n| 4        | 2018-08-04 | 1       | 4        | 2         |\n| 5        | 2018-08-04 | 1       | 3        | 4         |\n| 6        | 2019-08-05 | 2       | 2        | 4         |\n+----------+------------+---------+----------+-----------+\nItems table:\n+---------+------------+\n| item_id | item_brand |\n+---------+------------+\n| 1       | Samsung    |\n| 2       | Lenovo     |\n| 3       | LG         |\n| 4       | HP         |\n+---------+------------+\nOutput: \n+-----------+------------+----------------+\n| buyer_id  | join_date  | orders_in_2019 |\n+-----------+------------+----------------+\n| 1         | 2018-01-01 | 1              |\n| 2         | 2018-02-09 | 2              |\n| 3         | 2018-01-19 | 0              |\n| 4         | 2018-05-21 | 0              |\n+-----------+------------+----------------+\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "\nimport pandas as pd\n\ndef market_analysis(\n    users: pd.DataFrame, orders: pd.DataFrame, items: pd.DataFrame\n) -> pd.DataFrame:\n\n    # Step 1: Filter the orders dataframe to only include orders from the year 2019.\n    df = orders.query(\"order_date.dt.year==2019\").merge(\n        # Step 2: Merge the filtered orders with the users dataframe on buyer_id and user_id.\n        users,\n        left_on=\"buyer_id\",\n        right_on=\"user_id\",\n        how=\"right\",\n    )\n\n    # Step 3: Group the merged dataframe by user_id and join_date, then count the number of items (orders) for each user.\n    result = df.groupby([\"user_id\", \"join_date\"]).item_id.count()\n\n    # Step 4: Format the output by resetting the index and renaming the columns for clarity.\n    return result.reset_index().rename(\n        columns={\"user_id\": \"buyer_id\", \"item_id\": \"orders_in_2019\"}\n    )"
      ]
    },
    {
      "number": 262,
      "question": "Can you solve this real interview question? Find Words That Can Be Formed by Characters - You are given an array of strings words and a string chars.\n\nA string is good if it can be formed by characters from chars (each character can only be used once).\n\nReturn the sum of lengths of all good strings in words.\n\n \n\nExample 1:\n\n\nInput: words = [\"cat\",\"bt\",\"hat\",\"tree\"], chars = \"atach\"\nOutput: 6\nExplanation: The strings that can be formed are \"cat\" and \"hat\" so the answer is 3 + 3 = 6.\n\n\nExample 2:\n\n\nInput: words = [\"hello\",\"world\",\"leetcode\"], chars = \"welldonehoneyr\"\nOutput: 10\nExplanation: The strings that can be formed are \"hello\" and \"world\" so the answer is 5 + 5 = 10.\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 1000\n * 1 <= words[i].length, chars.length <= 100\n * words[i] and chars consist of lowercase English letters.",
      "code": "class Solution {\npublic:\n    int countCharacters(vector<string>& words, string chars) \n{\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int countCharacters(vector<string>& words, string chars) {\n        unordered_map<char, int> counts;\n        for (char c : chars) {\n            counts[c]++;\n        }\n        \n        int ans = 0;\n        for (string word : words) {\n            unordered_map<char, int> wordCount;\n            for (char c : word) {\n                wordCount[c]++;\n            }\n            \n            bool good = true;\n            for (auto& [c, freq] : wordCount) {\n                if (counts[c] < freq) {\n                    good = false;\n                    break;\n                }\n            }\n            \n            if (good) {\n                ans += word.size();\n            }\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int countCharacters(vector<string>& words, string chars) {\n        vector<int> counts(26, 0);\n        for (char c : chars) {\n            counts[c - 'a']++;\n        }\n        \n        int ans = 0;\n        for (string word : words) {\n            vector<int> wordCount(26, 0);\n            for (char c : word) {\n                wordCount[c - 'a']++;\n            }\n            \n            bool good = true;\n            for (int i = 0; i < 26; i++) {\n                if (counts[i] < wordCount[i]) {\n                    good = false;\n                    break;\n                }\n            }\n            \n            if (good) {\n                ans += word.size();\n            }\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 263,
      "question": "Can you solve this real interview question? Maximum Level Sum of a Binary Tree - Given the root of a binary tree, the level of its root is 1, the level of its children is 2, and so on.\n\nReturn the smallest level x such that the sum of all the values of nodes at level x is maximal.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/05/03/capture.JPG]\n\n\nInput: root = [1,7,0,7,-8,null,null]\nOutput: 2\nExplanation: \nLevel 1 sum = 1.\nLevel 2 sum = 7 + 0 = 7.\nLevel 3 sum = 7 + -8 = -1.\nSo we return the level with the maximum sum which is level 2.\n\n\nExample 2:\n\n\nInput: root = [989,null,10250,98693,-89388,null,null,null,-32127]\nOutput: 2\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * -105 <= Node.val <= 105",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int maxLevelSum(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int maxLevelSum(TreeNode* root) {\n        int maxSum = INT_MIN;\n        int ans = 0, level = 0;\n\n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            level++;\n            int sumAtCurrentLevel = 0;\n            // Iterate over all the nodes in the current level.\n            for (int sz = q.size(); sz > 0; --sz) {\n                TreeNode* node = q.front();\n                q.pop();\n                sumAtCurrentLevel += node->val;\n\n                if (node->left != nullptr) {\n                    q.push(node->left);\n                }\n                if (node->right != nullptr) {\n                    q.push(node->right);\n                }\n            }\n\n            if (maxSum < sumAtCurrentLevel) {\n                maxSum = sumAtCurrentLevel;\n                ans = level;\n            }\n        }\n\n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    void dfs(TreeNode* node, int level, vector<int>& sumOfNodesAtLevel) {\n        if (node == nullptr) {\n            return;\n        }\n\n        if (sumOfNodesAtLevel.size() == level) {\n            sumOfNodesAtLevel.push_back(node->val);\n        } else {\n            sumOfNodesAtLevel[level] += node->val;\n        }\n\n        dfs(node->left, level + 1, sumOfNodesAtLevel);\n        dfs(node->right, level + 1, sumOfNodesAtLevel);\n    }\n\n    int maxLevelSum(TreeNode* root) {\n        vector<int> sumOfNodesAtLevel;\n        dfs(root, 0, sumOfNodesAtLevel);\n\n        int maxSum = INT_MIN;\n        int ans = 0;\n\n        for (int i = 0; i < sumOfNodesAtLevel.size(); i++) {\n            if (maxSum < sumOfNodesAtLevel[i]) {\n                maxSum = sumOfNodesAtLevel[i];\n                ans = i + 1;\n            }\n        }\n\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 264,
      "question": "Can you solve this real interview question? Make Array Strictly Increasing - Given two integer arrays arr1 and arr2, return the minimum number of operations (possibly zero) needed to make arr1 strictly increasing.\n\nIn one operation, you can choose two indices 0 <= i < arr1.length and 0 <= j < arr2.length and do the assignment arr1[i] = arr2[j].\n\nIf there is no way to make arr1 strictly increasing, return -1.\n\n \n\nExample 1:\n\n\nInput: arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]\nOutput: 1\nExplanation: Replace 5 with 2, then arr1 = [1, 2, 3, 6, 7].\n\n\nExample 2:\n\n\nInput: arr1 = [1,5,3,6,7], arr2 = [4,3,1]\nOutput: 2\nExplanation: Replace 5 with 3 and then replace 3 with 4. arr1 = [1, 3, 4, 6, 7].\n\n\nExample 3:\n\n\nInput: arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]\nOutput: -1\nExplanation: You can't make arr1 strictly increasing.\n\n \n\nConstraints:\n\n * 1 <= arr1.length, arr2.length <= 2000\n * 0 <= arr1[i], arr2[i] <= 10^9\n\n ",
      "code": "class Solution {\npublic:\n    int makeArrayIncreasing(vector<int>& arr1, vector<int>& \narr2) {\n        \n    }\n};",
      "solution": [
        "class Solution { \n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Arrays.sort(arr2);\n        \n        int answer = dfs(0, -1, arr1, arr2);\n        \n        return answer < 2_001 ? answer : -1;\n    }\n    \n    Map<Pair<Integer, Integer>, Integer> dp = new HashMap<>();\n    private int dfs(int i, int prev, int[] arr1, int[] arr2) {\n        if (i == arr1.length) {\n            return 0;\n        }\n        if (dp.containsKey(new Pair<>(i, prev))) {\n            return dp.get(new Pair<>(i, prev));\n        }\n\n        int cost = 2_001;\n\n        // If arr1[i] is already greater than prev, we can leave it be.\n        if (arr1[i] > prev) {\n            cost = dfs(i + 1, arr1[i], arr1, arr2);\n        }\n\n        // Find a replacement with the smallest value in arr2.\n        int idx = bisectRight(arr2, prev);\n\n        // Replace arr1[i], with a cost of 1 operation.\n        if (idx < arr2.length) {\n            cost = Math.min(cost, 1 + dfs(i + 1, arr2[idx], arr1, arr2));\n        }\n\n        dp.put(new Pair<>(i, prev), cost);\n        return cost;\n    }\n    \n    private static int bisectRight(int[] arr, int value) {\n        int left = 0, right = arr.length;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    } \n}",
        "class Solution {\n    public int makeArrayIncreasing(int[] arr1, int[] arr2) {\n        Map<Integer, Integer> dp = new HashMap<>();\n        Arrays.sort(arr2);\n        int n = arr2.length;\n        dp.put(-1, 0);\n\n        for (int i = 0; i < arr1.length; i++) {\n            Map<Integer, Integer> newDp = new HashMap<>();\n            for (int prev : dp.keySet()) {\n                if (arr1[i] > prev) {\n                    newDp.put(arr1[i], Math.min(newDp.getOrDefault(arr1[i], Integer.MAX_VALUE), dp.get(prev)));\n                }\n                int idx = bisectRight(arr2, prev);\n                if (idx < n) {\n                    newDp.put(arr2[idx], Math.min(newDp.getOrDefault(arr2[idx], Integer.MAX_VALUE), 1 + dp.get(prev)));\n                }\n            }\n            dp = newDp;\n        }\n        \n        int answer = Integer.MAX_VALUE;\n        for (int value : dp.values()) {\n            answer = Math.min(answer, value);\n        }\n        \n        return answer == Integer.MAX_VALUE ? -1 : answer;\n    }\n    \n    private static int bisectRight(int[] arr, int value) {\n        int left = 0, right = arr.length;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (arr[mid] <= value) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }\n}"
      ]
    },
    {
      "number": 265,
      "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
      "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
      ]
    },
    {
      "number": 266,
      "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
      "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 267,
      "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
      ]
    },
    {
      "number": 268,
      "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
      ]
    },
    {
      "number": 269,
      "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
      "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
      ]
    },
    {
      "number": 270,
      "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
      "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
      ]
    },
    {
      "number": 271,
      "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
      "solution": [
        "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
        "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
      ]
    },
    {
      "number": 272,
      "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
        "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
      ]
    },
    {
      "number": 273,
      "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
      ]
    },
    {
      "number": 274,
      "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
      "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
      ]
    },
    {
      "number": 275,
      "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
      ]
    },
    {
      "number": 276,
      "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
      "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
        "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 277,
      "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
      "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
      ]
    },
    {
      "number": 278,
      "question": "Can you solve this real interview question? Minimum Insertion Steps to Make a String Palindrome - Given a string s. In one step you can insert any character at any index of the string.\n\nReturn the minimum number of steps to make s palindrome.\n\nA Palindrome String is one that reads the same backward as well as forward.\n\n \n\nExample 1:\n\n\nInput: s = \"zzazz\"\nOutput: 0\nExplanation: The string \"zzazz\" is already palindrome we do not need any insertions.\n\n\nExample 2:\n\n\nInput: s = \"mbadm\"\nOutput: 2\nExplanation: String can be \"mbdadbm\" or \"mdbabdm\".\n\n\nExample 3:\n\n\nInput: s = \"leetcode\"\nOutput: 5\nExplanation: Inserting 5 characters the string becomes \"leetcodocteel\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 500\n * s consists of lowercase English letters.",
      "code": "class Solution {\npublic:\n    int minInsertions(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int lcs(string& s1, string& s2, int m, int n, vector<vector<int>>& memo) {\n        if (m == 0 || n == 0) {\n            return 0;\n        }\n        if (memo[m][n] != -1) {\n            return memo[m][n];\n        }\n        if (s1[m - 1] == s2[n - 1]) {\n            return memo[m][n] = 1 + lcs(s1, s2, m - 1, n - 1, memo);\n        }\n        return memo[m][n] = max(lcs(s1, s2, m - 1, n, memo), lcs(s1, s2, m, n - 1, memo));\n    }\n\n    int minInsertions(string s) {\n        int n = s.length();\n        string sReverse = s;\n        reverse(sReverse.begin(), sReverse.end());\n        vector<vector<int>> memo(n + 1, vector<int>(n + 1));\n\n        for (int i = 0; i <= n; i++) {\n            for (int j = 0; j <= n; j++) {\n                memo[i][j] = -1;\n            }\n        }\n\n        return n - lcs(s, sReverse, n, n, memo);\n    }\n};",
        "class Solution {\npublic:\n    int lcs(string& s1, string& s2, int m, int n) {\n        vector<vector<int>> dp(n + 1, vector<int>(n + 1));\n\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 || j == 0) {\n                    // One of the two strings is empty.\n                    dp[i][j] = 0;\n                } else if (s1[i - 1] == s2[j - 1]) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n\n    int minInsertions(string s) {\n        int n = s.length();\n        string sReverse = s;\n        reverse(sReverse.begin(), sReverse.end());\n\n        return n - lcs(s, sReverse, n, n);\n    }\n};",
        "class Solution {\npublic:\n    int lcs(string& s1, string& s2, int m, int n) {\n        vector<int> dp(n + 1), dpPrev(n + 1);\n\n        for (int i = 0; i <= m; i++) {\n            for (int j = 0; j <= n; j++) {\n                if (i == 0 || j == 0) {\n                    // One of the two strings is empty.\n                    dp[j] = 0;\n                } else if (s1[i - 1] == s2[j - 1]) {\n                    dp[j] = 1 + dpPrev[j - 1];\n                } else {\n                    dp[j] = max(dpPrev[j], dp[j - 1]);\n                }\n            }\n            dpPrev = dp;\n        }\n\n        return dp[n];\n    }\n\n    int minInsertions(string s) {\n        int n = s.length();\n        string sReverse = s;\n        reverse(sReverse.begin(), sReverse.end());\n\n        return n - lcs(s, sReverse, n, n);\n    }\n};"
      ]
    },
    {
      "number": 279,
      "question": "Can you solve this real interview question? Sum of Nodes with Even-Valued Grandparent - Given the root of a binary tree, return the sum of values of nodes with an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0.\n\nA grandparent of a node is the parent of its parent if it exists.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/08/10/even1-tree.jpg]\n\n\nInput: root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]\nOutput: 18\nExplanation: The red nodes are the nodes with even-value grandparent while the blue nodes are the even-value grandparents.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/08/10/even2-tree.jpg]\n\n\nInput: root = [1]\nOutput: 0\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * 1 <= Node.val <= 100",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int sumEvenGrandparent(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int solve(TreeNode* root, int parent, int gParent) {\n        if (!root) {\n            return 0;\n        }\n        \n        // Iterate over the child with updated values of parent and grandparent.\n        return solve(root->left, root->val, parent) \n                + solve(root->right, root->val, parent)\n                + (gParent % 2 ? 0 : root->val);\n    }\n\n    int sumEvenGrandparent(TreeNode* root) {\n        return solve(root, -1, -1);\n    }\n};",
        "class Solution {\npublic:\n    int findVal(TreeNode* root) {\n        return root ? root->val : 0;\n    }\n    \n    int sumEvenGrandparent(TreeNode* root) {\n        if (root == NULL) {\n            return 0;\n        }\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        \n        int sum = 0;\n        while (!q.empty()) {\n            TreeNode* curr = q.front();\n            q.pop();\n            \n            // If the node value is even, then Check the four grandchildren\n            // And add the value.\n            if (curr->val % 2 == 0) {\n                if (curr->left) {\n                    sum += findVal(curr->left->left) + findVal(curr->left->right);\n                }\n                if (curr->right) {\n                    sum += findVal(curr->right->left) + findVal(curr->right->right);\n                }\n            }\n            \n            // Add the non-null child of the current node.\n            if (curr->left) \n                q.push(curr->left);\n            if (curr->right)\n                q.push(curr->right);\n        }\n        \n        return sum;\n    }\n};"
      ]
    },
    {
      "number": 280,
      "question": "Can you solve this real interview question? Jump Game IV - Given an array of integers arr, you are initially positioned at the first index of the array.\n\nIn one step you can jump from index i to index:\n\n * i + 1 where: i + 1 < arr.length.\n * i - 1 where: i - 1 >= 0.\n * j where: arr[i] == arr[j] and i != j.\n\nReturn the minimum number of steps to reach the last index of the array.\n\nNotice that you can not jump outside of the array at any time.\n\n \n\nExample 1:\n\n\nInput: arr = [100,-23,-23,404,100,23,23,23,3,404]\nOutput: 3\nExplanation: You need three jumps from index 0 --> 4 --> 3 --> 9. Note that index 9 is the last index of the array.\n\n\nExample 2:\n\n\nInput: arr = [7]\nOutput: 0\nExplanation: Start index is the last index. You do not need to jump.\n\n\nExample 3:\n\n\nInput: arr = [7,6,9,6,9,6,9,7]\nOutput: 1\nExplanation: You can jump directly from index 0 to index 7 which is last index of the array.\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 5 * 104\n * -108 <= arr[i] <= 108",
      "code": "class Solution {\npublic:\n    int minJumps(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int minJumps(int[] arr) {\n        int n = arr.length;\n        if (n <= 1) {\n            return 0;\n        }\n\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            graph.computeIfAbsent(arr[i], v -> new LinkedList<>()).add(i);\n        }\n\n        List<Integer> curs = new LinkedList<>(); // store current layer\n        curs.add(0);\n        Set<Integer> visited = new HashSet<>();\n        int step = 0;\n\n        // when current layer exists\n        while (!curs.isEmpty()) {\n            List<Integer> nex = new LinkedList<>();\n\n            // iterate the layer\n            for (int node : curs) {\n                // check if reached end\n                if (node == n - 1) {\n                    return step;\n                }\n\n                // check same value\n                for (int child : graph.get(arr[node])) {\n                    if (!visited.contains(child)) {\n                        visited.add(child);\n                        nex.add(child);\n                    }\n                }\n\n                // clear the list to prevent redundant search\n                graph.get(arr[node]).clear();\n\n                // check neighbors\n                if (node + 1 < n && !visited.contains(node + 1)) {\n                    visited.add(node + 1);\n                    nex.add(node + 1);\n                }\n                if (node - 1 >= 0 && !visited.contains(node - 1)) {\n                    visited.add(node - 1);\n                    nex.add(node - 1);\n                }\n            }\n\n            curs = nex;\n            step++;\n        }\n\n        return -1;\n    }\n}",
        "class Solution {\n    public static int minJumps(int[] arr) {\n        int n = arr.length;\n        if (n <= 1) {\n            return 0;\n        }\n\n        Map<Integer, List<Integer>> graph = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            graph.computeIfAbsent(arr[i], v -> new LinkedList<>()).add(i);\n        }\n\n        HashSet<Integer> curs = new HashSet<>(); // store layers from start\n        curs.add(0);\n        Set<Integer> visited = new HashSet<>();\n        visited.add(0);\n        visited.add(n - 1);\n        int step = 0;\n\n        HashSet<Integer> other = new HashSet<>(); // store layers from end\n        other.add(n - 1);\n\n        // when current layer exists\n        while (!curs.isEmpty()) {\n            // search from the side with fewer nodes\n            if (curs.size() > other.size()) {\n                HashSet<Integer> tmp = curs;\n                curs = other;\n                other = tmp;\n            }\n\n            HashSet<Integer> nex = new HashSet<>();\n\n            // iterate the layer\n            for (int node : curs) {\n\n                // check same value\n                for (int child : graph.get(arr[node])) {\n                    if (other.contains(child)) {\n                        return step + 1;\n                    }\n                    if (!visited.contains(child)) {\n                        visited.add(child);\n                        nex.add(child);\n                    }\n                }\n\n                // clear the list to prevent redundant search\n                graph.get(arr[node]).clear();\n\n                // check neighbors\n                if (other.contains(node + 1) || other.contains(node - 1)) {\n                    return step + 1;\n                }\n\n                if (node + 1 < n && !visited.contains(node + 1)) {\n                    visited.add(node + 1);\n                    nex.add(node + 1);\n                }\n                if (node - 1 >= 0 && !visited.contains(node - 1)) {\n                    visited.add(node - 1);\n                    nex.add(node - 1);\n                }\n            }\n\n            curs = nex;\n            step++;\n        }\n\n        return -1;\n    }\n}"
      ]
    },
    {
      "number": 281,
      "question": "Can you solve this real interview question? Activity Participants - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
      "code": "",
      "solution": [
        "import pandas as pd\n\ndef activity_participants(friends: pd.DataFrame, activities: pd.DataFrame) -> pd.DataFrame:\n    df = friends.groupby('activity', as_index=False)['id'].count()\n    \n    max_min = df.agg({'id': ['max', 'min']})\n    \n    df = df[~df['id'].isin(max_min['id'])][['activity']]\n    \n    return df",
        "import pandas as pd\n\ndef activity_participants(friends: pd.DataFrame, activities: pd.DataFrame) -> pd.DataFrame:\n    df = friends.groupby('activity', as_index=False)['id'].count()\n    \n    max_min = df.agg({'id': ['max', 'min']})\n    \n    df = df.merge(max_min, on='id', how='left', indicator=True)\n    \n    df2= df[df['_merge']=='left_only'][['activity']]\n   \n    return df2"
      ]
    },
    {
      "number": 282,
      "question": "Can you solve this real interview question? Sort Integers by The Number of 1 Bits - You are given an integer array arr. Sort the integers in the array in ascending order by the number of 1's in their binary representation and in case of two or more integers have the same number of 1's you have to sort them in ascending order.\n\nReturn the array after sorting it.\n\n \n\nExample 1:\n\n\nInput: arr = [0,1,2,3,4,5,6,7,8]\nOutput: [0,1,2,4,8,3,5,6,7]\nExplantion: [0] is the only integer with 0 bits.\n[1,2,4,8] all have 1 bit.\n[3,5,6] have 2 bits.\n[7] has 3 bits.\nThe sorted array by bits is [0,1,2,4,8,3,5,6,7]\n\n\nExample 2:\n\n\nInput: arr = [1024,512,256,128,64,32,16,8,4,2,1]\nOutput: [1,2,4,8,16,32,64,128,256,512,1024]\nExplantion: All integers have 1 bit in the binary representation, you should just sort them in ascending order.\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 500\n * 0 <= arr[i] <= 104",
      "code": "class Solution {\npublic:\n    vector<int> sortByBits(vector<int>& arr) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    static bool compare(int a, int b) {\n        if (__builtin_popcount(a) == __builtin_popcount(b)) {\n            return a < b;\n        }\n        \n        return __builtin_popcount(a) < __builtin_popcount(b);\n    }\n    \n    vector<int> sortByBits(vector<int>& arr) {\n        sort(arr.begin(), arr.end(), compare);\n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    static int findWeight(int num) {\n        int mask = 1;\n        int weight = 0;\n        \n        while (num > 0) {\n            if ((num & mask) > 0) {\n                weight++;\n                num ^= mask;\n            }\n            \n            mask <<= 1;\n        }\n        \n        return weight;\n    }\n    \n    static bool compare(int a, int b) {\n        if (findWeight(a) == findWeight(b)) {\n            return a < b;\n        }\n        \n        return findWeight(a) < findWeight(b);\n    }\n    \n    vector<int> sortByBits(vector<int>& arr) {\n        sort(arr.begin(), arr.end(), compare);\n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    static int findWeight(int num) {\n        int weight = 0;\n        \n        while (num > 0) {\n            weight++;\n            num &= (num - 1);\n        }\n        \n        return weight;\n    }\n    \n    static bool compare(int a, int b) {\n        if (findWeight(a) == findWeight(b)) {\n            return a < b;\n        }\n        \n        return findWeight(a) < findWeight(b);\n    }\n    \n    vector<int> sortByBits(vector<int>& arr) {\n        sort(arr.begin(), arr.end(), compare);\n        return arr;\n    }\n};"
      ]
    },
    {
      "number": 283,
      "question": "Can you solve this real interview question? Validate Binary Tree Nodes - You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.\n\nIf node i has no left child then leftChild[i] will equal -1, similarly for the right child.\n\nNote that the nodes have no values and that we only use the node numbers in this problem.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/08/23/1503_ex1.png]\n\n\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1]\nOutput: true\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2019/08/23/1503_ex2.png]\n\n\nInput: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1]\nOutput: false\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2019/08/23/1503_ex3.png]\n\n\nInput: n = 2, leftChild = [1,0], rightChild = [-1,-1]\nOutput: false\n\n\n \n\nConstraints:\n\n * n == leftChild.length == rightChild.length\n * 1 <= n <= 104\n * -1 <= leftChild[i], rightChild[i] <= n - 1",
      "code": "class Solution {\npublic:\n    bool validateBinaryTreeNodes(int n, vector<int>& \nleftChild, vector<int>& rightChild) {\n        \n    }\n};",
      "solution": [
        "int findRoot(int n, vector<int>& left, vector<int>& right) {\n    unordered_set<int> children;\n    children.insert(left.begin(), left.end());\n    children.insert(right.begin(), right.end());\n    \n    for (int i = 0; i < n; i++) {\n        if (children.find(i) == children.end()) {\n            return i;\n        }\n    }\n    \n    return -1;\n}",
        "class Solution {\npublic:\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n        int root = findRoot(n, leftChild, rightChild);\n        if (root == -1) {\n            return false;\n        }\n        \n        unordered_set<int> seen;\n        stack<int> stack;\n        seen.insert(root);\n        stack.push(root);\n        \n        while (!stack.empty()) {\n            int node = stack.top();\n            stack.pop();\n            \n            int children[] = {leftChild[node], rightChild[node]};\n            for (int child : children) {\n                if (child != -1) {\n                    if (seen.find(child) != seen.end()) {\n                        return false;\n                    }\n                    \n                    stack.push(child);\n                    seen.insert(child);\n                }\n            }\n        }\n        \n        return seen.size() == n;\n    }\n    \n    int findRoot(int n, vector<int>& left, vector<int>& right) {\n        unordered_set<int> children;\n        children.insert(left.begin(), left.end());\n        children.insert(right.begin(), right.end());\n        \n        for (int i = 0; i < n; i++) {\n            if (children.find(i) == children.end()) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n        int root = findRoot(n, leftChild, rightChild);\n        if (root == -1) {\n            return false;\n        }\n        \n        unordered_set<int> seen;\n        queue<int> queue;\n        seen.insert(root);\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            int node = queue.front();\n            queue.pop();\n            \n            int children[] = {leftChild[node], rightChild[node]};\n            for (int child : children) {\n                if (child != -1) {\n                    if (seen.find(child) != seen.end()) {\n                        return false;\n                    }\n                    \n                    queue.push(child);\n                    seen.insert(child);\n                }\n            }\n        }\n        \n        return seen.size() == n;\n    }\n    \n    int findRoot(int n, vector<int>& left, vector<int>& right) {\n        unordered_set<int> children;\n        children.insert(left.begin(), left.end());\n        children.insert(right.begin(), right.end());\n        \n        for (int i = 0; i < n; i++) {\n            if (children.find(i) == children.end()) {\n                return i;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "class UnionFind {   \npublic:\n    int components;\n    int n;\n    vector<int> parents;\n    vector<int> ranks;\n\n    UnionFind(int n) {\n        this->n = n;\n        parents = vector(n, 0);\n        components = n;\n        \n        for (int i = 0; i < n; i++) {\n            parents[i] = i;\n        }\n    }\n    \n    bool join(int parent, int child) {\n        int parentParent = find(parent);\n        int childParent = find(child);\n        \n        if (childParent != child || parentParent == childParent) {\n            return false;\n        }\n        \n        components--;\n        parents[childParent] = parentParent;\n\n        return true;\n    }\n    \n    int find(int node) {\n        if (parents[node] != node) {\n            parents[node] = find(parents[node]);\n        }\n        \n        return parents[node];\n    }\n};\n\nclass Solution {\npublic:\n    bool validateBinaryTreeNodes(int n, vector<int>& leftChild, vector<int>& rightChild) {\n        UnionFind uf(n);\n        for (int node = 0; node < n; node++) {\n            int children[] = {leftChild[node], rightChild[node]};\n            for (int child : children) {\n                if (child == -1) {\n                    continue;\n                }\n                \n                if (!uf.join(node, child)) {\n                    return false;\n                }\n            }\n        }\n        \n        return uf.components == 1;\n    }\n};"
      ]
    },
    {
      "number": 284,
      "question": "Can you solve this real interview question? Longest ZigZag Path in a Binary Tree - You are given the root of a binary tree.\n\nA ZigZag path for a binary tree is defined as follow:\n\n * Choose any node in the binary tree and a direction (right or left).\n * If the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n * Change the direction from right to left or from left to right.\n * Repeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\n\nReturn the longest ZigZag path contained in that tree.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/01/22/sample_1_1702.png]\n\n\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/01/22/sample_2_1702.png]\n\n\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\n\nExample 3:\n\n\nInput: root = [1]\nOutput: 0\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 5 * 104].\n * 1 <= Node.val <= 100",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int longestZigZag(TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int pathLength = 0;\n    void dfs(TreeNode* node, bool goLeft, int steps) {\n        if (node == nullptr) {\n            return;\n        }\n        pathLength = max(pathLength, steps);\n        if (goLeft) {\n            dfs(node->left, false, steps + 1);\n            dfs(node->right, true, 1);\n        } else {\n            dfs(node->left, false, 1);\n            dfs(node->right, true, steps + 1);\n        }\n    }\n\n    int longestZigZag(TreeNode* root) {\n        dfs(root, false, 0);\n        dfs(root, true, 0);\n        return pathLength;\n    }\n};"
      ]
    },
    {
      "number": 285,
      "question": "Can you solve this real interview question? Find a Corresponding Node of a Binary Tree in a Clone of That Tree - Given two binary trees original and cloned and given a reference to a node target in the original tree.\n\nThe cloned tree is a copy of the original tree.\n\nReturn a reference to the same node in the cloned tree.\n\nNote that you are not allowed to change any of the two trees or the target node and the answer must be a reference to a node in the cloned tree.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/02/21/e1.png]\n\n\nInput: tree = [7,4,3,null,null,6,19], target = 3\nOutput: 3\nExplanation: In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/02/21/e2.png]\n\n\nInput: tree = [7], target =  7\nOutput: 7\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2020/02/21/e3.png]\n\n\nInput: tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\nOutput: 4\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * The values of the nodes of the tree are unique.\n * target node is a node from the original tree and is not null.\n\n \n\nFollow up: Could you solve the problem if repeated values on the tree are allowed?",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* \ncloned, TreeNode* target) {\n        \n    }\n};",
      "solution": [
        "if (node_o.val == target.val) {\n    // TODO\n}",
        "if (node_o == target) {\n    // TODO\n}",
        "class Solution {\n    TreeNode ans, target;\n    \n    public void inorder(TreeNode o, TreeNode c) {\n        if (o != null) {\n            inorder(o.left, c.left);\n            if (o == target) {\n                ans = c;    \n            }\n            inorder(o.right, c.right);    \n        }\n    }\n    \n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n        this.target = target;\n        inorder(original, cloned);\n        return ans;\n    }\n}",
        "class Solution {\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n        Deque<TreeNode> stack_o = new ArrayDeque();\n        Deque<TreeNode> stack_c = new ArrayDeque();\n        TreeNode node_o = original, node_c = cloned;\n\n        while (!stack_o.isEmpty() || node_o != null) {\n            while (node_o != null) {\n                stack_o.add(node_o);\n                stack_c.add(node_c);\n\n                node_o = node_o.left;\n                node_c = node_c.left;\n            }\n            node_o = stack_o.removeLast();\n            node_c = stack_c.removeLast();\n            if (node_o == target) {\n                return node_c;\n            }\n            node_o = node_o.right;\n            node_c = node_c.right;\n        }\n        return null;\n    }\n}",
        "class Solution {\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\n        Deque<TreeNode> queue_o = new ArrayDeque();\n        queue_o.offer(original);\n        \n        Deque<TreeNode> queue_c = new ArrayDeque();\n        queue_c.offer(cloned);\n\n        while (!queue_o.isEmpty()) {\n            TreeNode node_o = queue_o.poll();\n            TreeNode node_c = queue_c.poll();\n            \n            if (node_o == target) {\n                return node_c;   \n            }\n            \n            if (node_o.left != null) {\n                queue_o.offer(node_o.left);\n                queue_c.offer(node_c.left);\n            }\n            if (node_o.right != null) {\n                queue_o.offer(node_o.right);\n                queue_c.offer(node_c.right);\n            }\n        }\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 286,
      "question": "Can you solve this real interview question? Capital Gain/Loss - Table: Stocks\n\n\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| stock_name    | varchar |\n| operation     | enum    |\n| operation_day | int     |\n| price         | int     |\n+---------------+---------+\n(stock_name, operation_day) is the primary key (combination of columns with unique values) for this table.\nThe operation column is an ENUM (category) of type ('Sell', 'Buy')\nEach row of this table indicates that the stock which has stock_name had an operation on the day operation_day with the price.\nIt is guaranteed that each 'Sell' operation for a stock has a corresponding 'Buy' operation in a previous day. It is also guaranteed that each 'Buy' operation for a stock has a corresponding 'Sell' operation in an upcoming day.\n\n\n \n\nWrite a solution to report the Capital gain/loss for each stock.\n\nThe Capital gain/loss of a stock is the total gain or loss after buying and selling the stock one or many times.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nStocks table:\n+---------------+-----------+---------------+--------+\n| stock_name    | operation | operation_day | price  |\n+---------------+-----------+---------------+--------+\n| Leetcode      | Buy       | 1             | 1000   |\n| Corona Masks  | Buy       | 2             | 10     |\n| Leetcode      | Sell      | 5             | 9000   |\n| Handbags      | Buy       | 17            | 30000  |\n| Corona Masks  | Sell      | 3             | 1010   |\n| Corona Masks  | Buy       | 4             | 1000   |\n| Corona Masks  | Sell      | 5             | 500    |\n| Corona Masks  | Buy       | 6             | 1000   |\n| Handbags      | Sell      | 29            | 7000   |\n| Corona Masks  | Sell      | 10            | 10000  |\n+---------------+-----------+---------------+--------+\nOutput: \n+---------------+-------------------+\n| stock_name    | capital_gain_loss |\n+---------------+-------------------+\n| Corona Masks  | 9500              |\n| Leetcode      | 8000              |\n| Handbags      | -23000            |\n+---------------+-------------------+\nExplanation: \nLeetcode stock was bought at day 1 for 1000$ and was sold at day 5 for 9000$. Capital gain = 9000 - 1000 = 8000$.\nHandbags stock was bought at day 17 for 30000$ and was sold at day 29 for 7000$. Capital loss = 7000 - 30000 = -23000$.\nCorona Masks stock was bought at day 1 for 10$ and was sold at day 3 for 1010$. It was bought again at day 4 for 1000$ and was sold at day 5 for 500$. At last, it was bought at day 6 for 1000$ and was sold at day 10 for 10000$. Capital gain/loss is the sum of capital gains/losses for each ('Buy' --> 'Sell') operation = (1010 - 10) + (500 - 1000) + (10000 - 1000) = 1000 - 500 + 9000 = 9500$.\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "def solution(stocks: pd.DataFrame) -> pd.DataFrame:\n    # Approach: groupby, apply\n    # Helper function to update prices in stocks DataFrame\n    def helper(operation, price):\n        if operation == \"Buy\":\n            return -int(price)\n        elif operation == \"Sell\":\n            return int(price)\n        \n    # Update 'price' column based on if 'operation' is 'Buy' or 'Sell'\n    Stocks['price'] = Stocks.apply(lambda x: helper(x['operation'], x['price']), axis=1)\n    \n    # Groupby 'stock_name' and sum over 'price' column\n    # Rename summed column to 'capital_gain_loss'\n    df = Stocks.groupby(by='stock_name')['price'].sum().reset_index(name='capital_gain_loss')\n    \n    return df"
      ]
    },
    {
      "number": 287,
      "question": "Can you solve this real interview question? Maximum Score After Splitting a String - Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\n\nThe score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.\n\n \n\nExample 1:\n\n\nInput: s = \"011101\"\nOutput: 5 \nExplanation: \nAll possible ways of splitting s into two non-empty substrings are:\nleft = \"0\" and right = \"11101\", score = 1 + 4 = 5 \nleft = \"01\" and right = \"1101\", score = 1 + 3 = 4 \nleft = \"011\" and right = \"101\", score = 1 + 2 = 3 \nleft = \"0111\" and right = \"01\", score = 1 + 1 = 2 \nleft = \"01110\" and right = \"1\", score = 2 + 1 = 3\n\n\nExample 2:\n\n\nInput: s = \"00111\"\nOutput: 5\nExplanation: When left = \"00\" and right = \"111\", we get the maximum score = 2 + 3 = 5\n\n\nExample 3:\n\n\nInput: s = \"1111\"\nOutput: 3\n\n\n \n\nConstraints:\n\n * 2 <= s.length <= 500\n * The string s consists of characters '0' and '1' only.",
      "code": "class Solution {\npublic:\n    int maxScore(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int maxScore(string s) {\n        int ans = 0;\n        for (int i = 0; i < s.size() - 1; i++) {\n            int curr = 0;\n            for (int j = 0; j <= i; j++) {\n                if (s[j] == '0') {\n                    curr++;\n                }\n            }\n            \n            for (int j = i + 1; j < s.size(); j++) {\n                if (s[j] == '1') {\n                    curr++;\n                }\n            }\n            \n            ans = max(ans, curr);\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int maxScore(string s) {\n        int ones = count(s.begin(), s.end(), '1');\n        \n        int ans = 0;\n        int zeros = 0;\n        for (int i = 0; i < s.size() - 1; i++) {\n            if (s[i] == '1') {\n                ones--;\n            } else {\n                zeros++;\n            }\n            \n            ans = max(ans, zeros + ones);\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int maxScore(string s) {\n        int ones = 0;\n        int zeros = 0;\n        int best = INT_MIN;\n\n        for (int i = 0; i < s.size() - 1; i++) {\n            if (s[i] == '1') {\n                ones++;\n            } else {\n                zeros++;\n            }\n            \n            best = max(best, zeros - ones);\n        }\n        \n        if (s[s.size() - 1] == '1') {\n            ones++;\n        }\n        \n        return best + ones;\n    }\n};"
      ]
    },
    {
      "number": 288,
      "question": "Can you solve this real interview question? Diagonal Traverse II - Given a 2D integer array nums, return all elements of nums in diagonal order as shown in the below images.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/04/08/sample_1_1784.png]\n\n\nInput: nums = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,4,2,7,5,3,8,6,9]\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/04/08/sample_2_1784.png]\n\n\nInput: nums = [[1,2,3,4,5],[6,7],[8],[9,10,11],[12,13,14,15,16]]\nOutput: [1,6,2,8,7,3,9,4,12,10,5,13,11,14,15,16]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 1 <= nums[i].length <= 105\n * 1 <= sum(nums[i].length) <= 105\n * 1 <= nums[i][j] <= 105",
      "code": "class Solution {\npublic:\n    vector<int> findDiagonalOrder(vector<vector<int>>& nums) \n{\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findDiagonalOrder(vector<vector<int>>& nums) {\n        unordered_map<int, vector<int>> groups;\n        for (int row = nums.size() - 1; row >= 0; row--) {\n            for (int col = 0; col < nums[row].size(); col++) {\n                int diagonal = row + col;\n                groups[diagonal].push_back(nums[row][col]);\n            }\n        }\n        \n        vector<int> ans;\n        int curr = 0;\n        \n        while (groups.find(curr) != groups.end()) {\n            for (int num : groups[curr]) {\n                ans.push_back(num);\n            }\n            \n            curr++;\n        }\n        \n        return ans;\n    }\n};\n",
        "class Solution {\npublic:\n    vector<int> findDiagonalOrder(vector<vector<int>>& nums) {\n        queue<pair<int, int>> queue;\n        queue.push({0, 0});\n        vector<int> ans;\n        \n        while (!queue.empty()) {\n            auto [row, col] = queue.front();\n            queue.pop();\n            ans.push_back(nums[row][col]);\n            \n            if (col == 0 && row + 1 < nums.size()) {\n                queue.push({row + 1, col});\n            }\n            \n            if (col + 1 < nums[row].size()) {\n                queue.push({row, col + 1});\n            }\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 289,
      "question": "Can you solve this real interview question? Constrained Subsequence Sum - Given an integer array nums and an integer k, return the maximum sum of a non-empty subsequence of that array such that for every two consecutive integers in the subsequence, nums[i] and nums[j], where i < j, the condition j - i <= k is satisfied.\n\nA subsequence of an array is obtained by deleting some number of elements (can be zero) from the array, leaving the remaining elements in their original order.\n\n \n\nExample 1:\n\n\nInput: nums = [10,2,-10,5,20], k = 2\nOutput: 37\nExplanation: The subsequence is [10, 2, 5, 20].\n\n\nExample 2:\n\n\nInput: nums = [-1,-2,-3], k = 1\nOutput: -1\nExplanation: The subsequence must be non-empty, so we choose the largest number.\n\n\nExample 3:\n\n\nInput: nums = [10,-2,-10,-5,20], k = 2\nOutput: 23\nExplanation: The subsequence is [10, -2, -5, 20].\n\n\n \n\nConstraints:\n\n * 1 <= k <= nums.length <= 105\n * -104 <= nums[i] <= 104",
      "code": "class Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        priority_queue<pair<int, int>> heap;\n        heap.push({nums[0], 0});\n        int ans = nums[0];\n        \n        for (int i = 1; i < nums.size(); i++) {\n            while (i - heap.top().second > k) {\n                heap.pop();\n            }\n\n            int curr = max(0, heap.top().first) + nums[i];\n            ans = max(ans, curr);\n            heap.push({curr, i});\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        map<int, int> window;\n        window[0] = 0;\n        vector<int> dp(nums.size());\n        \n        for (int i = 0; i < nums.size(); i++) {\n            dp[i] = nums[i] + window.rbegin()->first;\n            window[dp[i]]++;\n            \n            if (i >= k) {\n                window[dp[i - k]]--;\n                if (window[dp[i - k]] == 0) {\n                    window.erase(dp[i - k]);\n                }\n            }\n        }\n        \n        return *max_element(dp.begin(), dp.end());\n    }\n};",
        "class Solution {\npublic:\n    int constrainedSubsetSum(vector<int>& nums, int k) {\n        deque<int> queue;\n        vector<int> dp(nums.size());\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (!queue.empty() && i - queue.front() > k) {\n                queue.pop_front();\n            }\n            \n            dp[i] = (!queue.empty() ? dp[queue.front()] : 0) + nums[i];\n            while (!queue.empty() && dp[queue.back()] < dp[i]) {\n                queue.pop_back();\n            }\n            \n            if (dp[i] > 0) {\n                queue.push_back(i);\n            }\n        }\n        \n        return *max_element(dp.begin(), dp.end());\n    }\n};"
      ]
    },
    {
      "number": 290,
      "question": "Can you solve this real interview question? Kids With the Greatest Number of Candies - There are n kids with candies. You are given an integer array candies, where each candies[i] represents the number of candies the ith kid has, and an integer extraCandies, denoting the number of extra candies that you have.\n\nReturn a boolean array result of length n, where result[i] is true if, after giving the ith kid all the extraCandies, they will have the greatest number of candies among all the kids, or false otherwise.\n\nNote that multiple kids can have the greatest number of candies.\n\n \n\nExample 1:\n\n\nInput: candies = [2,3,5,1,3], extraCandies = 3\nOutput: [true,true,true,false,true] \nExplanation: If you give all extraCandies to:\n- Kid 1, they will have 2 + 3 = 5 candies, which is the greatest among the kids.\n- Kid 2, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n- Kid 3, they will have 5 + 3 = 8 candies, which is the greatest among the kids.\n- Kid 4, they will have 1 + 3 = 4 candies, which is not the greatest among the kids.\n- Kid 5, they will have 3 + 3 = 6 candies, which is the greatest among the kids.\n\n\nExample 2:\n\n\nInput: candies = [4,2,1,1,2], extraCandies = 1\nOutput: [true,false,false,false,false] \nExplanation: There is only 1 extra candy.\nKid 1 will always have the greatest number of candies, even if a different kid is given the extra candy.\n\n\nExample 3:\n\n\nInput: candies = [12,1,12], extraCandies = 10\nOutput: [true,false,true]\n\n\n \n\nConstraints:\n\n * n == candies.length\n * 2 <= n <= 100\n * 1 <= candies[i] <= 100\n * 1 <= extraCandies <= 50",
      "code": "class Solution {\npublic:\n    vector<bool> kidsWithCandies(vector<int>& candies, int \nextraCandies) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {\n        // Find out the greatest number of candies among all the kids.\n        int maxCandies = 0;\n        for (int candy : candies) {\n            maxCandies = max(maxCandies, candy);\n        }\n        // For each kid, check if they will have greatest number of candies\n        // among all the kids.\n        vector<bool> result;\n        for (int candy : candies) {\n            result.push_back(candy + extraCandies >= maxCandies);\n        }\n\n        return result;\n    }\n};"
      ]
    },
    {
      "number": 291,
      "question": "Can you solve this real interview question? Number of Ways to Wear Different Hats to Each Other - There are n people and 40 types of hats labeled from 1 to 40.\n\nGiven a 2D integer array hats, where hats[i] is a list of all hats preferred by the ith person.\n\nReturn the number of ways that the n people wear different hats to each other.\n\nSince the answer may be too large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: hats = [[3,4],[4,5],[5]]\nOutput: 1\nExplanation: There is only one way to choose hats given the conditions. \nFirst person choose hat 3, Second person choose hat 4 and last one hat 5.\n\n\nExample 2:\n\n\nInput: hats = [[3,5,1],[3,5]]\nOutput: 4\nExplanation: There are 4 ways to choose hats:\n(3,5), (5,3), (1,3) and (1,5)\n\n\nExample 3:\n\n\nInput: hats = [[1,2,3,4],[1,2,3,4],[1,2,3,4],[1,2,3,4]]\nOutput: 24\nExplanation: Each person can choose hats labeled from 1 to 4.\nNumber of Permutations of (1,2,3,4) = 24.\n\n\n \n\nConstraints:\n\n * n == hats.length\n * 1 <= n <= 10\n * 1 <= hats[i].length <= 40\n * 1 <= hats[i][j] <= 40\n * hats[i] contains a list of unique integers.",
      "code": "class Solution {\npublic:\n    int numberWays(vector<vector<int>>& hats) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    int[][] memo;\n    int done;\n    int n;\n    int MOD = 1000000007;\n    Map<Integer, ArrayList<Integer>> hatsToPeople;\n    \n    public int numberWays(List<List<Integer>> hats) {\n        n = hats.size();\n        \n        hatsToPeople = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int hat: hats.get(i)) {\n                if (!hatsToPeople.containsKey(hat)) {\n                    hatsToPeople.put(hat, new ArrayList<>());\n                }\n                \n                hatsToPeople.get(hat).add(i);\n            }\n        }\n        \n        done = (int) Math.pow(2, n) - 1;\n        memo = new int[41][done];\n        \n        for (int i = 0; i < memo.length; i++) {\n            for (int j = 0; j < memo[i].length; j++) {\n                memo[i][j] = -1;\n            }\n        }\n        \n        return dp(1, 0);\n    }\n    \n    private int dp(int hat, int mask) {\n        if (mask == done) {\n            return 1;\n        }\n        \n        if (hat > 40) {\n            return 0;\n        }\n        \n        if (memo[hat][mask] != -1) {\n            return memo[hat][mask];\n        }\n        \n        int ans = dp(hat + 1, mask);\n        \n        if (hatsToPeople.containsKey(hat)) {\n            for (int person: hatsToPeople.get(hat)) {\n                if ((mask & (1 << person)) == 0) {\n                    ans = (ans + dp(hat + 1, mask | (1 << person))) % MOD;\n                }\n            }\n        }\n        \n        memo[hat][mask] = ans;\n        return ans;\n    }\n}",
        "class Solution {\n    public int numberWays(List<List<Integer>> hats) {\n        int n = hats.size();\n        Map<Integer, ArrayList<Integer>> hatsToPeople = new HashMap<>();\n        \n        hatsToPeople = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            for (int hat: hats.get(i)) {\n                if (!hatsToPeople.containsKey(hat)) {\n                    hatsToPeople.put(hat, new ArrayList<>());\n                }\n                \n                hatsToPeople.get(hat).add(i);\n            }\n        }\n        \n        int done = (int) Math.pow(2, n) - 1;\n        int MOD = 1000000007;\n        \n        int[][] dp = new int[42][done + 1];\n        for (int i = 0; i < dp.length; i++) {\n            dp[i][done] = 1;\n        }\n        \n        for (int hat = 40; hat > 0; hat--) {\n            for (int mask = done; mask >= 0; mask--) {\n                int ans = dp[hat + 1][mask];\n                if (hatsToPeople.containsKey(hat)) {\n                    for (int person: hatsToPeople.get(hat)) {\n                        if ((mask & (1 << person)) == 0) {\n                            ans = (ans + dp[hat + 1][mask | (1 << person)]) % MOD;\n                        }\n                    }\n                }\n                \n                dp[hat][mask] = ans;\n            }\n        }\n\n        return dp[1][0];\n    }\n}"
      ]
    },
    {
      "number": 292,
      "question": "Can you solve this real interview question? Destination City - You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\n\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.\n\n \n\nExample 1:\n\n\nInput: paths = [[\"London\",\"New York\"],[\"New York\",\"Lima\"],[\"Lima\",\"Sao Paulo\"]]\nOutput: \"Sao Paulo\" \nExplanation: Starting at \"London\" city you will reach \"Sao Paulo\" city which is the destination city. Your trip consist of: \"London\" -> \"New York\" -> \"Lima\" -> \"Sao Paulo\".\n\n\nExample 2:\n\n\nInput: paths = [[\"B\",\"C\"],[\"D\",\"B\"],[\"C\",\"A\"]]\nOutput: \"A\"\nExplanation: All possible trips are: \n\"D\" -> \"B\" -> \"C\" -> \"A\". \n\"B\" -> \"C\" -> \"A\". \n\"C\" -> \"A\". \n\"A\". \nClearly the destination city is \"A\".\n\n\nExample 3:\n\n\nInput: paths = [[\"A\",\"Z\"]]\nOutput: \"Z\"\n\n\n \n\nConstraints:\n\n * 1 <= paths.length <= 100\n * paths[i].length == 2\n * 1 <= cityAi.length, cityBi.length <= 10\n * cityAi != cityBi\n * All strings consist of lowercase and uppercase English letters and the space character.",
      "code": "class Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        for (int i = 0; i < paths.size(); i++) {\n            string candidate = paths[i][1];\n            bool good = true;\n            \n            for (int j = 0; j < paths.size(); j++) {\n                if (paths[j][0] == candidate) {\n                    good = false;\n                    break;\n                }\n            }\n\n            if (good) {\n                return candidate;\n            }\n        }\n        \n        return \"\";\n    }\n};",
        "class Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        unordered_set<string> hasOutgoing;\n        for (int i = 0; i < paths.size(); i++) {\n            hasOutgoing.insert(paths[i][0]);\n        }\n        \n        for (int i = 0; i < paths.size(); i++) {\n            string candidate = paths[i][1];\n            if (hasOutgoing.find(candidate) == hasOutgoing.end()) {\n                return candidate;\n            }\n        }\n        \n        return \"\";\n    }\n};"
      ]
    },
    {
      "number": 293,
      "question": "Can you solve this real interview question? Build an Array With Stack Operations - You are given an integer array target and an integer n.\n\nYou have an empty stack with the two following operations:\n\n * \"Push\": pushes an integer to the top of the stack.\n * \"Pop\": removes the integer on the top of the stack.\n\nYou also have a stream of the integers in the range [1, n].\n\nUse the two stack operations to make the numbers in the stack (from the bottom to the top) equal to target. You should follow the following rules:\n\n * If the stream of the integers is not empty, pick the next integer from the stream and push it to the top of the stack.\n * If the stack is not empty, pop the integer at the top of the stack.\n * If, at any moment, the elements in the stack (from the bottom to the top) are equal to target, do not read new integers from the stream and do not do more operations on the stack.\n\nReturn the stack operations needed to build target following the mentioned rules. If there are multiple valid answers, return any of them.\n\n \n\nExample 1:\n\n\nInput: target = [1,3], n = 3\nOutput: [\"Push\",\"Push\",\"Pop\",\"Push\"]\nExplanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nPop the integer on the top of the stack. s = [1].\nRead 3 from the stream and push it to the stack. s = [1,3].\n\n\nExample 2:\n\n\nInput: target = [1,2,3], n = 3\nOutput: [\"Push\",\"Push\",\"Push\"]\nExplanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nRead 3 from the stream and push it to the stack. s = [1,2,3].\n\n\nExample 3:\n\n\nInput: target = [1,2], n = 4\nOutput: [\"Push\",\"Push\"]\nExplanation: Initially the stack s is empty. The last element is the top of the stack.\nRead 1 from the stream and push it to the stack. s = [1].\nRead 2 from the stream and push it to the stack. s = [1,2].\nSince the stack (from the bottom to the top) is equal to target, we stop the stack operations.\nThe answers that read integer 3 from the stream are not accepted.\n\n\n \n\nConstraints:\n\n * 1 <= target.length <= 100\n * 1 <= n <= 100\n * 1 <= target[i] <= n\n * target is strictly increasing.",
      "code": "class Solution {\npublic:\n    vector<string> buildArray(vector<int>& target, int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<string> buildArray(vector<int>& target, int n) {\n        vector<string> ans;\n        int i = 0;\n        \n        for (int num : target) {\n            while (i < num - 1) {\n                ans.push_back(\"Push\");\n                ans.push_back(\"Pop\");\n                i++;\n            }\n            \n            ans.push_back(\"Push\");\n            i++;\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 294,
      "question": "Can you solve this real interview question? Consecutive Characters - The power of the string is the maximum length of a non-empty substring that contains only one unique character.\n\nGiven a string s, return the power of s.\n\n \n\nExample 1:\n\n\nInput: s = \"leetcode\"\nOutput: 2\nExplanation: The substring \"ee\" is of length 2 with the character 'e' only.\n\n\nExample 2:\n\n\nInput: s = \"abbcccddddeeeeedcba\"\nOutput: 5\nExplanation: The substring \"eeeee\" is of length 5 with the character 'e' only.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 500\n * s consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    int maxPower(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int maxPower(String s) {\n        int count = 0;\n        int maxCount = 0;\n        char previous = ' ';\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == previous) {\n                // if same as previous one, increase the count\n                count++;\n            } else {\n                // else, reset the count\n                count = 1;\n                previous = c;\n            }\n            maxCount = Math.max(maxCount, count);\n        }\n        return maxCount;\n    }\n}"
      ]
    },
    {
      "number": 295,
      "question": "Can you solve this real interview question? Pseudo-Palindromic Paths in a Binary Tree - Given a binary tree where node values are digits from 1 to 9. A path in the binary tree is said to be pseudo-palindromic if at least one permutation of the node values in the path is a palindrome.\n\nReturn the number of pseudo-palindromic paths going from the root node to leaf nodes.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/05/06/palindromic_paths_1.png]\n\n\nInput: root = [2,3,1,3,1,null,1]\nOutput: 2 \nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the red path [2,3,3], the green path [2,1,1], and the path [2,3,1]. Among these paths only red path and green path are pseudo-palindromic paths since the red path [2,3,3] can be rearranged in [3,2,3] (palindrome) and the green path [2,1,1] can be rearranged in [1,2,1] (palindrome).\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/05/07/palindromic_paths_2.png]\n\n\nInput: root = [2,1,1,1,3,null,null,null,null,null,1]\nOutput: 1 \nExplanation: The figure above represents the given binary tree. There are three paths going from the root node to leaf nodes: the green path [2,1,1], the path [2,1,3,1], and the path [2,1]. Among these paths only the green path is pseudo-palindromic since [2,1,1] can be rearranged in [1,2,1] (palindrome).\n\n\nExample 3:\n\n\nInput: root = [9]\nOutput: 1\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 105].\n * 1 <= Node.val <= 9",
      "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int pseudoPalindromicPaths (TreeNode* root) {\n        \n    }\n};",
      "solution": [
        "public boolean checkPalindrom(ArrayList<Integer> nums) {\n    int isPalindrom = 0;\n\n    for (int i = 1; i < 10; ++i) {\n        if (Collections.frequency(nums, i) % 2 == 1) {\n            ++isPalindrom;\n            if (isPalindrom > 1) {\n                return false;    \n            }     \n        }   \n    }\n    return true;    \n}",
        "// compute occurences of each digit \n// in the corresponding bit\npath = path ^ (1 << node.val);",
        "// if it's a leaf, \n// check that at most one digit has an odd frequency\nif ((path & (path - 1)) == 0) {\n    ++count;\n}",
        "class Solution {\n    public int pseudoPalindromicPaths (TreeNode root) {\n        int count = 0, path = 0;\n        \n        Deque<Pair<TreeNode, Integer>> stack = new ArrayDeque();\n        stack.push(new Pair(root, 0));\n        while (!stack.isEmpty()) {\n            Pair<TreeNode, Integer> p = stack.pop();\n            TreeNode node = p.getKey();\n            path = p.getValue();\n\n            if (node != null) {\n                // compute occurences of each digit \n                // in the corresponding register\n                path = path ^ (1 << node.val);\n                // if it's a leaf check if the path is pseudo-palindromic\n                if (node.left == null && node.right == null) {\n                    // check if at most one digit has an odd frequency\n                    if ((path & (path - 1)) == 0) {\n                        ++count;\n                    }\n                } else {\n                    stack.push(new Pair(node.right, path));\n                    stack.push(new Pair(node.left, path));\n                }\n            }\n        }\n        return count;\n    }\n}",
        "class Solution {\n    int count = 0;\n        \n    public void preorder(TreeNode node, int path) {\n        if (node != null) {\n            // compute occurences of each digit \n            // in the corresponding register\n            path = path ^ (1 << node.val);\n            // if it's a leaf check if the path is pseudo-palindromic\n            if (node.left == null && node.right == null) {\n                // check if at most one digit has an odd frequency\n                if ((path & (path - 1)) == 0) {\n                    ++count;\n                }\n            }\n            preorder(node.left, path);\n            preorder(node.right, path) ;\n        }\n    }\n\n    public int pseudoPalindromicPaths (TreeNode root) {\n        preorder(root, 0);\n        return count;\n    }\n}"
      ]
    },
    {
      "number": 296,
      "question": "Can you solve this real interview question? Maximum Product of Two Elements in an Array - Given the array of integers nums, you will choose two different indices i and j of that array. Return the maximum value of (nums[i]-1)*(nums[j]-1).\n\n \n\nExample 1:\n\n\nInput: nums = [3,4,5,2]\nOutput: 12 \nExplanation: If you choose the indices i=1 and j=2 (indexed from 0), you will get the maximum value, that is, (nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12. \n\n\nExample 2:\n\n\nInput: nums = [1,5,4,5]\nOutput: 16\nExplanation: Choosing the indices i=1 and j=3 (indexed from 0), you will get the maximum value of (5-1)*(5-1) = 16.\n\n\nExample 3:\n\n\nInput: nums = [3,7]\nOutput: 12\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 500\n * 1 <= nums[i] <= 10^3",
      "code": "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                ans = max(ans, (nums[i] - 1) * (nums[j] - 1));\n            }\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int x = nums[nums.size() - 1];\n        int y = nums[nums.size() - 2];\n        return (x - 1) * (y - 1);\n    }\n};",
        "class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int biggest = 0;\n        int secondBiggest = 0;\n        for (int num : nums) {\n            if (num > biggest) {\n                secondBiggest = biggest;\n                biggest = num;\n            } else {\n                secondBiggest = max(secondBiggest, num);\n            }\n        }\n        \n        return (biggest - 1) * (secondBiggest - 1);\n    }\n};"
      ]
    },
    {
      "number": 297,
      "question": "Can you solve this real interview question? Reorder Routes to Make All Paths Lead to the City Zero - There are n cities numbered from 0 to n - 1 and n - 1 roads such that there is only one way to travel between two different cities (this network form a tree). Last year, The ministry of transport decided to orient the roads in one direction because they are too narrow.\n\nRoads are represented by connections where connections[i] = [ai, bi] represents a road from city ai to city bi.\n\nThis year, there will be a big event in the capital (city 0), and many people want to travel to this city.\n\nYour task consists of reorienting some roads such that each city can visit the city 0. Return the minimum number of edges changed.\n\nIt's guaranteed that each city can reach city 0 after reorder.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/05/13/sample_1_1819.png]\n\n\nInput: n = 6, connections = [[0,1],[1,3],[2,3],[4,0],[4,5]]\nOutput: 3\nExplanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/05/13/sample_2_1819.png]\n\n\nInput: n = 5, connections = [[1,0],[1,2],[3,2],[3,4]]\nOutput: 2\nExplanation: Change the direction of edges show in red such that each node can reach the node 0 (capital).\n\n\nExample 3:\n\n\nInput: n = 3, connections = [[1,0],[2,0]]\nOutput: 0\n\n\n \n\nConstraints:\n\n * 2 <= n <= 5 * 104\n * connections.length == n - 1\n * connections[i].length == 2\n * 0 <= ai, bi <= n - 1\n * ai != bi",
      "code": "class Solution {\npublic:\n    int minReorder(int n, vector<vector<int>>& connections) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int count = 0;\n    void dfs(int node, int parent, vector<vector<pair<int, int>>>& adj) {\n        for (auto& [child, sign] : adj[node]) {\n            if (child != parent) {\n                count += sign;\n                dfs(child, node, adj);\n            }\n        }\n    }\n\n    int minReorder(int n, vector<vector<int>>& connections) {\n        vector<vector<pair<int, int>>> adj(n);\n        for (auto& connection : connections) {\n            adj[connection[0]].push_back({connection[1], 1});\n            adj[connection[1]].push_back({connection[0], 0});\n        }\n        dfs(0, -1, adj);\n        return count;\n    }\n};",
        "class Solution {\npublic:\n    int count = 0;\n    void bfs(int node, int n, vector<vector<pair<int, int>>>& adj) {\n        queue<int> q;\n        vector<bool> visit(n);\n        q.push(node);\n        visit[node] = true;\n\n        while (!q.empty()) {\n            node = q.front();\n            q.pop();\n            for (auto& [neighbor, sign] : adj[node]) {\n                if (!visit[neighbor]) {\n                    count += sign;\n                    visit[neighbor] = true;\n                    q.push(neighbor);\n                }\n            }\n        }\n    }\n\n    int minReorder(int n, vector<vector<int>>& connections) {\n        vector<vector<pair<int, int>>> adj(n);\n        for (auto& connection : connections) {\n            adj[connection[0]].push_back({connection[1], 1});\n            adj[connection[1]].push_back({connection[0], 0});\n        }\n        bfs(0, n, adj);\n        return count;\n    }\n};"
      ]
    },
    {
      "number": 298,
      "question": "Can you solve this real interview question? Longest Subarray of 1's After Deleting One Element - Given a binary array nums, you should delete one element from it.\n\nReturn the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,0,1]\nOutput: 3\nExplanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.\n\n\nExample 2:\n\n\nInput: nums = [0,1,1,1,0,1,1,0,1]\nOutput: 5\nExplanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].\n\n\nExample 3:\n\n\nInput: nums = [1,1,1]\nOutput: 2\nExplanation: You must delete one element.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * nums[i] is either 0 or 1.",
      "code": "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int longestSubarray(vector<int>& nums) {\n        // Number of zero's in the window.\n        int zeroCount = 0;\n        int longestWindow = 0;\n        // Left end of the window.\n        int start = 0;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            zeroCount += (nums[i] == 0);\n                          \n            // Shrink the window until the zero counts come under the limit.\n            while (zeroCount > 1) {\n                zeroCount -= (nums[start] == 0);\n                start++;\n            }\n              \n            longestWindow = max(longestWindow, i - start);\n        }\n\n        return longestWindow;\n    }\n};"
      ]
    },
    {
      "number": 299,
      "question": "Can you solve this real interview question? Path Crossing - Given a string path, where path[i] = 'N', 'S', 'E' or 'W', each representing moving one unit north, south, east, or west, respectively. You start at the origin (0, 0) on a 2D plane and walk on the path specified by path.\n\nReturn true if the path crosses itself at any point, that is, if at any time you are on a location you have previously visited. Return false otherwise.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/06/10/screen-shot-2020-06-10-at-123929-pm.png]\n\n\nInput: path = \"NES\"\nOutput: false \nExplanation: Notice that the path doesn't cross any point more than once.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/06/10/screen-shot-2020-06-10-at-123843-pm.png]\n\n\nInput: path = \"NESWW\"\nOutput: true\nExplanation: Notice that the path visits the origin twice.\n\n \n\nConstraints:\n\n * 1 <= path.length <= 104\n * path[i] is either 'N', 'S', 'E', or 'W'.",
      "code": "class Solution {\npublic:\n    bool isPathCrossing(string path) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool isPathCrossing(string path) {\n        unordered_map<char, pair<int, int>> moves;\n        moves['N'] = {0, 1};\n        moves['S'] = {0, -1};\n        moves['W'] = {-1, 0};\n        moves['E'] = {1, 0};\n        \n        unordered_set<string> visited;\n        visited.insert(\"0,0\");\n        \n        int x = 0;\n        int y = 0;\n        \n        for (char c : path) {\n            pair<int, int> curr = moves[c];\n            int dx = curr.first;\n            int dy = curr.second;\n            x += dx;\n            y += dy;\n            \n            string hash = to_string(x) + \",\" + to_string(y);\n            if (visited.find(hash) != visited.end()) {\n                return true;\n            }\n            \n            visited.insert(hash);\n        }\n        \n        return false;\n    }\n};"
      ]
    },
    {
      "number": 300,
      "question": "Can you solve this real interview question? Last Moment Before All Ants Fall Out of a Plank - We have a wooden plank of the length n units. Some ants are walking on the plank, each ant moves with a speed of 1 unit per second. Some of the ants move to the left, the other move to the right.\n\nWhen two ants moving in two different directions meet at some point, they change their directions and continue moving again. Assume changing directions does not take any additional time.\n\nWhen an ant reaches one end of the plank at a time t, it falls out of the plank immediately.\n\nGiven an integer n and two integer arrays left and right, the positions of the ants moving to the left and the right, return the moment when the last ant(s) fall out of the plank.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/06/17/ants.jpg]\n\n\nInput: n = 4, left = [4,3], right = [0,1]\nOutput: 4\nExplanation: In the image above:\n-The ant at index 0 is named A and going to the right.\n-The ant at index 1 is named B and going to the right.\n-The ant at index 3 is named C and going to the left.\n-The ant at index 4 is named D and going to the left.\nThe last moment when an ant was on the plank is t = 4 seconds. After that, it falls immediately out of the plank. (i.e., We can say that at t = 4.0000000001, there are no ants on the plank).\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/06/17/ants2.jpg]\n\n\nInput: n = 7, left = [], right = [0,1,2,3,4,5,6,7]\nOutput: 7\nExplanation: All ants are going to the right, the ant at index 0 needs 7 seconds to fall.\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2020/06/17/ants3.jpg]\n\n\nInput: n = 7, left = [0,1,2,3,4,5,6,7], right = []\nOutput: 7\nExplanation: All ants are going to the left, the ant at index 7 needs 7 seconds to fall.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 104\n * 0 <= left.length <= n + 1\n * 0 <= left[i] <= n\n * 0 <= right.length <= n + 1\n * 0 <= right[i] <= n\n * 1 <= left.length + right.length <= n + 1\n * All values of left and right are unique, and each value can appear only in one of the two arrays.",
      "code": "class Solution {\npublic:\n    int getLastMoment(int n, vector<int>& left, vector<int>& \nright) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int getLastMoment(int n, vector<int>& left, vector<int>& right) {\n        int ans = 0;\n        for (int num : left) {\n            ans = max(ans, num);\n        }\n        \n        for (int num : right) {\n            ans = max(ans, n - num);\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 301,
      "question": "Can you solve this real interview question? Path with Maximum Probability - You are given an undirected weighted graph of n nodes (0-indexed), represented by an edge list where edges[i] = [a, b] is an undirected edge connecting the nodes a and b with a probability of success of traversing that edge succProb[i].\n\nGiven two nodes start and end, find the path with the maximum probability of success to go from start to end and return its success probability.\n\nIf there is no path from start to end, return 0. Your answer will be accepted if it differs from the correct answer by at most 1e-5.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/09/20/1558_ex1.png]\n\n\nInput: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.2], start = 0, end = 2\nOutput: 0.25000\nExplanation: There are two paths from start to end, one having a probability of success = 0.2 and the other has 0.5 * 0.5 = 0.25.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2019/09/20/1558_ex2.png]\n\n\nInput: n = 3, edges = [[0,1],[1,2],[0,2]], succProb = [0.5,0.5,0.3], start = 0, end = 2\nOutput: 0.30000\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2019/09/20/1558_ex3.png]\n\n\nInput: n = 3, edges = [[0,1]], succProb = [0.5], start = 0, end = 2\nOutput: 0.00000\nExplanation: There is no path between 0 and 2.\n\n\n \n\nConstraints:\n\n * 2 <= n <= 10^4\n * 0 <= start, end < n\n * start != end\n * 0 <= a, b < n\n * a != b\n * 0 <= succProb.length == edges.length <= 2*10^4\n * 0 <= succProb[i] <= 1\n * There is at most one edge between every two nodes.",
      "code": "class Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, \nvector<double>& succProb, int start_node, int end_node) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        double[] maxProb = new double[n];\n        maxProb[start] = 1.0;\n\n        for (int i = 0; i < n - 1; i++) {\n            boolean hasUpdate = false;\n            for (int j = 0; j < edges.length; j++) {\n                int u = edges[j][0];\n                int v = edges[j][1];\n                double pathProb = succProb[j];\n                if (maxProb[u] * pathProb > maxProb[v]) {\n                    maxProb[v] = maxProb[u] * pathProb;\n                    hasUpdate = true;\n                }\n                if (maxProb[v] * pathProb > maxProb[u]) {\n                    maxProb[u] = maxProb[v] * pathProb;\n                    hasUpdate = true;\n                }\n            }\n            if (!hasUpdate) {\n                break;\n            }\n        }\n\n        return maxProb[end];\n    }\n}",
        "class Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\n        for (int i = 0; i < edges.length; i++) {\n            int u = edges[i][0], v = edges[i][1];\n            double pathProb = succProb[i];\n            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(new Pair<>(v, pathProb));\n            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(new Pair<>(u, pathProb));\n        }\n        \n        double[] maxProb = new double[n];\n        maxProb[start] = 1d;\n        \n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        while (!queue.isEmpty()) {\n            int curNode = queue.poll();\n            for (Pair<Integer, Double> neighbor : graph.getOrDefault(curNode, new ArrayList<>())) {\n                int nxtNode = neighbor.getKey();\n                double pathProb = neighbor.getValue();\n\n                // Only update maxProb[nxtNode] if the current path increases\n                // the probability of reach nxtNode.\n                if (maxProb[curNode] * pathProb > maxProb[nxtNode]) {\n                    maxProb[nxtNode] = maxProb[curNode] * pathProb;\n                    queue.offer(nxtNode);\n                }\n            }\n        }\n        \n        return maxProb[end];\n    }\n}",
        "class Solution {\n    public double maxProbability(int n, int[][] edges, double[] succProb, int start, int end) {\n        Map<Integer, List<Pair<Integer, Double>>> graph = new HashMap<>();\n        for (int i = 0; i < edges.length; i++) {\n            int u = edges[i][0], v = edges[i][1];\n            double pathProb = succProb[i];\n            graph.computeIfAbsent(u, k -> new ArrayList<>()).add(new Pair<>(v, pathProb));\n            graph.computeIfAbsent(v, k -> new ArrayList<>()).add(new Pair<>(u, pathProb));\n        }\n\n        double[] maxProb = new double[n];\n        maxProb[start] = 1d;\n\n        PriorityQueue<Pair<Double, Integer>> pq = new PriorityQueue<>((a, b) -> -Double.compare(a.getKey(), b.getKey()));\n        pq.add(new Pair<>(1.0, start));\n        while (!pq.isEmpty()) {\n            Pair<Double, Integer> cur = pq.poll();\n            double curProb = cur.getKey();\n            int curNode = cur.getValue();\n            if (curNode == end) {\n                return curProb;\n            }\n            for (Pair<Integer, Double> nxt : graph.getOrDefault(curNode, new ArrayList<>())) {\n                int nxtNode = nxt.getKey();\n                double pathProb = nxt.getValue();\n                if (curProb * pathProb > maxProb[nxtNode]) {\n                    maxProb[nxtNode] = curProb * pathProb;\n                    pq.add(new Pair<>(maxProb[nxtNode], nxtNode));\n                }\n            }\n        }\n\n        return 0d;\n    }\n}"
      ]
    },
    {
      "number": 302,
      "question": "Can you solve this real interview question? Find the Winner of an Array Game - Given an integer array arr of distinct integers and an integer k.\n\nA game will be played between the first two elements of the array (i.e. arr[0] and arr[1]). In each round of the game, we compare arr[0] with arr[1], the larger integer wins and remains at position 0, and the smaller integer moves to the end of the array. The game ends when an integer wins k consecutive rounds.\n\nReturn the integer which will win the game.\n\nIt is guaranteed that there will be a winner of the game.\n\n \n\nExample 1:\n\n\nInput: arr = [2,1,3,5,4,6,7], k = 2\nOutput: 5\nExplanation: Let's see the rounds of the game:\nRound |       arr       | winner | win_count\n  1   | [2,1,3,5,4,6,7] | 2      | 1\n  2   | [2,3,5,4,6,7,1] | 3      | 1\n  3   | [3,5,4,6,7,1,2] | 5      | 1\n  4   | [5,4,6,7,1,2,3] | 5      | 2\nSo we can see that 4 rounds will be played and 5 is the winner because it wins 2 consecutive games.\n\n\nExample 2:\n\n\nInput: arr = [3,2,1], k = 10\nOutput: 3\nExplanation: 3 will win the first 10 rounds consecutively.\n\n\n \n\nConstraints:\n\n * 2 <= arr.length <= 105\n * 1 <= arr[i] <= 106\n * arr contains distinct integers.\n * 1 <= k <= 109",
      "code": "class Solution {\npublic:\n    int getWinner(vector<int>& arr, int k) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int getWinner(vector<int>& arr, int k) {\n        int maxElement = arr[0];\n        queue<int> queue;\n        for (int i = 1; i < arr.size(); i++) {\n            maxElement = max(maxElement, arr[i]);\n            queue.push(arr[i]);\n        }\n        \n        int curr = arr[0];\n        int winstreak = 0;\n        \n        while (!queue.empty()) {\n            int opponent = queue.front();\n            queue.pop();\n            \n            if (curr > opponent) {\n                queue.push(opponent);\n                winstreak++;\n            } else {\n                queue.push(curr);\n                curr = opponent;\n                winstreak = 1;\n            }\n            \n            if (winstreak == k || curr == maxElement) {\n                return curr;\n            }\n        }\n        \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    int getWinner(vector<int>& arr, int k) {\n        int maxElement = arr[0];\n        for (int i = 1; i < arr.size(); i++) {\n            maxElement = max(maxElement, arr[i]);\n        }\n        \n        int curr = arr[0];\n        int winstreak = 0;\n        \n        for (int i = 1; i < arr.size(); i++) {\n            int opponent = arr[i];\n            \n            if (curr > opponent) {\n                winstreak++;\n            } else {\n                curr = opponent;\n                winstreak = 1;\n            }\n            \n            if (winstreak == k || curr == maxElement) {\n                return curr;\n            }\n        }\n        \n        return -1;\n    }\n};"
      ]
    },
    {
      "number": 303,
      "question": "Can you solve this real interview question? Minimum Cost to Cut a Stick - Given a wooden stick of length n units. The stick is labelled from 0 to n. For example, a stick of length 6 is labelled as follows:\n\n[https://assets.leetcode.com/uploads/2020/07/21/statement.jpg]\n\nGiven an integer array cuts where cuts[i] denotes a position you should perform a cut at.\n\nYou should perform the cuts in order, you can change the order of the cuts as you wish.\n\nThe cost of one cut is the length of the stick to be cut, the total cost is the sum of costs of all cuts. When you cut a stick, it will be split into two smaller sticks (i.e. the sum of their lengths is the length of the stick before the cut). Please refer to the first example for a better explanation.\n\nReturn the minimum total cost of the cuts.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/07/23/e1.jpg]\n\n\nInput: n = 7, cuts = [1,3,4,5]\nOutput: 16\nExplanation: Using cuts order = [1, 3, 4, 5] as in the input leads to the following scenario:\n[https://assets.leetcode.com/uploads/2020/07/21/e11.jpg]\nThe first cut is done to a rod of length 7 so the cost is 7. The second cut is done to a rod of length 6 (i.e. the second part of the first cut), the third is done to a rod of length 4 and the last cut is to a rod of length 3. The total cost is 7 + 6 + 4 + 3 = 20.\nRearranging the cuts to be [3, 5, 1, 4] for example will lead to a scenario with total cost = 16 (as shown in the example photo 7 + 4 + 3 + 2 = 16).\n\nExample 2:\n\n\nInput: n = 9, cuts = [5,6,1,4,2]\nOutput: 22\nExplanation: If you try the given cuts ordering the cost will be 25.\nThere are much ordering with total cost <= 25, for example, the order [4, 6, 5, 2, 1] has total cost = 22 which is the minimum possible.\n\n\n \n\nConstraints:\n\n * 2 <= n <= 106\n * 1 <= cuts.length <= min(n - 1, 100)\n * 1 <= cuts[i] <= n - 1\n * All the integers in cuts array are distinct.",
      "code": "class Solution {\npublic:\n    int minCost(int n, vector<int>& cuts) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    int[][] memo;\n    int newCuts[];\n    private int cost(int left, int right) {\n        if (memo[left][right] != -1) {\n            return memo[left][right];\n        }\n        if (right - left == 1) {\n            return 0;\n        }\n        int ans = Integer.MAX_VALUE;\n        for (int mid = left + 1; mid < right; mid++) {\n            int cost = cost(left, mid) + cost(mid, right) + newCuts[right] - newCuts[left];\n            ans = Math.min(ans, cost);\n        }\n        memo[left][right] = ans;\n        return ans;\n    }\n    public int minCost(int n, int[] cuts) {\n        int m = cuts.length;\n        newCuts = new int[m + 2];\n        System.arraycopy(cuts, 0, newCuts, 1, m);\n        newCuts[m + 1] = n;\n        Arrays.sort(newCuts);\n        \n        memo = new int[m + 2][m + 2];\n        for (int r = 0; r < m + 2; ++r) {\n            Arrays.fill(memo[r], -1);\n        }\n        \n        return cost(0, newCuts.length - 1);\n    }    \n}",
        "class Solution {\n    public int minCost(int n, int[] cuts) {\n        int m = cuts.length;\n        int[] newCuts = new int[m + 2];\n        System.arraycopy(cuts, 0, newCuts, 1, m);\n        newCuts[m + 1] = n;\n        Arrays.sort(newCuts);\n        \n        int[][] dp = new int[m + 2][m + 2];\n        \n        for (int diff = 2; diff < m + 2; ++diff) {\n            for (int left = 0; left < m + 2 - diff; ++left) {\n                int right = left + diff;\n                int ans = Integer.MAX_VALUE;\n                for (int mid = left + 1; mid < right; ++mid) {\n                    ans = Math.min(ans, dp[left][mid] + dp[mid][right] + newCuts[right] - newCuts[left]);\n                }\n                dp[left][right] = ans;\n            }\n        } \n        \n        return dp[0][m + 1];\n    }    \n}"
      ]
    },
    {
      "number": 304,
      "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
      "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
      ]
    },
    {
      "number": 305,
      "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
      "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
        "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
      ]
    },
    {
      "number": 306,
      "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
      "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
      ]
    },
    {
      "number": 307,
      "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
      "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
        "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
      ]
    },
    {
      "number": 308,
      "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
      "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
        "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
      ]
    },
    {
      "number": 309,
      "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
      "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
      ]
    },
    {
      "number": 310,
      "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
      "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
      "solution": [
        "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
        "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
        "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
      ]
    },
    {
      "number": 311,
      "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
      "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
      "solution": [
        " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
        "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
        "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
      ]
    },
    {
      "number": 312,
      "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
      "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
        "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
      ]
    },
    {
      "number": 313,
      "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
      "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
      ]
    },
    {
      "number": 314,
      "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
      "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
        "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
      ]
    },
    {
      "number": 315,
      "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
      "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
        "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 316,
      "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
      "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
      "solution": [
        "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
      ]
    },
    {
      "number": 317,
      "question": "Can you solve this real interview question? Maximum Number of Achievable Transfer Requests - We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It's transfer season, and some employees want to change the building they reside in.\n\nYou are given an array requests where requests[i] = [fromi, toi] represents an employee's request to transfer from building fromi to building toi.\n\nAll buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\n\nReturn the maximum number of achievable requests.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/09/10/move1.jpg]\n\n\nInput: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\nOutput: 5\nExplantion: Let's see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don't have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/09/10/move2.jpg]\n\n\nInput: n = 3, requests = [[0,0],[1,2],[2,1]]\nOutput: 3\nExplantion: Let's see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests. \n\nExample 3:\n\n\nInput: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\nOutput: 4\n\n\n \n\nConstraints:\n\n * 1 <= n <= 20\n * 1 <= requests.length <= 16\n * requests[i].length == 2\n * 0 <= fromi, toi < n",
      "code": "class Solution {\npublic:\n    int maximumRequests(int n, vector<vector<int>>& \nrequests) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int answer = 0;\n\n    void maxRequest(vector<vector<int>>& requests, vector<int>& indegree, int n, int index, int count) {\n        if (index == requests.size()) {\n            // Check if all buildings have an in-degree of 0.\n            for (int i = 0; i < n; i++) {\n                if (indegree[i]) {\n                    return;\n                }\n            }\n            \n            answer = max(answer, count);\n            return;\n        }\n        \n        // Consider this request, increment and decrement for the buildings involved.\n        indegree[requests[index][0]]--;\n        indegree[requests[index][1]]++;\n        // Move on to the next request and also increment the count of requests.\n        maxRequest(requests, indegree, n, index + 1, count + 1);\n        // Backtrack to the previous values to move back to the original state before the second recursion.\n        indegree[requests[index][0]]++;\n        indegree[requests[index][1]]--;\n        \n        // Ignore this request and move on to the next request without incrementing the count.\n        maxRequest(requests, indegree, n, index + 1, count);\n    }\n    \n    int maximumRequests(int n, vector<vector<int>>& requests) {\n        vector<int> indegree(n, 0);\n        maxRequest(requests, indegree, n, 0, 0);\n        \n        return answer;\n    }\n};",
        "class Solution {\npublic:\n    int maximumRequests(int n, vector<vector<int>>& requests) {\n        int answer = 0; \n        \n        for (int mask = 0; mask < (1 << requests.size()); mask++) {\n            vector<int> indegree(n, 0);\n            int pos = requests.size() - 1;\n            // Number of set bits representing the requests we will consider.\n            int bitCount = __builtin_popcount(mask);\n            \n            // If the request count we're going to consider is less than the maximum request \n            // We have considered without violating the constraints; then we can return it cannot be the answer.\n            if (bitCount <= answer) {\n                continue;\n            }\n            \n            // For all the 1's in the number, update the array indegree for the building it involves.\n            for (int curr = mask; curr > 0; curr >>= 1, pos--) {\n                if (curr & 1) {\n                    indegree[requests[pos][0]]--;\n                    indegree[requests[pos][1]]++;\n                }\n            }\n            \n            int flag = 1;\n            // Check if it doesn;t violates the constraints\n            for (int i = 0; i < n; i++) {\n                if (indegree[i]) {\n                    flag = 0;\n                    break;\n                }\n            }\n            \n            if (flag)  {\n                answer = bitCount;\n            }\n        }\n        \n        return answer;\n    }\n};"
      ]
    },
    {
      "number": 318,
      "question": "Can you solve this real interview question? Design Parking System - Design a parking system for a parking lot. The parking lot has three kinds of parking spaces: big, medium, and small, with a fixed number of slots for each size.\n\nImplement the ParkingSystem class:\n\n * ParkingSystem(int big, int medium, int small) Initializes object of the ParkingSystem class. The number of slots for each parking space are given as part of the constructor.\n * bool addCar(int carType) Checks whether there is a parking space of carType for the car that wants to get into the parking lot. carType can be of three kinds: big, medium, or small, which are represented by 1, 2, and 3 respectively. A car can only park in a parking space of its carType. If there is no space available, return false, else park the car in that size space and return true.\n\n \n\nExample 1:\n\n\nInput\n[\"ParkingSystem\", \"addCar\", \"addCar\", \"addCar\", \"addCar\"]\n[[1, 1, 0], [1], [2], [3], [1]]\nOutput\n[null, true, true, false, false]\n\nExplanation\nParkingSystem parkingSystem = new ParkingSystem(1, 1, 0);\nparkingSystem.addCar(1); // return true because there is 1 available slot for a big car\nparkingSystem.addCar(2); // return true because there is 1 available slot for a medium car\nparkingSystem.addCar(3); // return false because there is no available slot for a small car\nparkingSystem.addCar(1); // return false because there is no available slot for a big car. It is already occupied.\n\n\n \n\nConstraints:\n\n * 0 <= big, medium, small <= 1000\n * carType is 1, 2, or 3\n * At most 1000 calls will be made to addCar",
      "code": "class ParkingSystem {\npublic:\n    ParkingSystem(int big, int medium, int small) {\n        \n    }\n    \n    bool addCar(int carType) {\n        \n    }\n};\n\n/**\n * Your ParkingSystem object will be instantiated and \ncalled as such:\n * ParkingSystem* obj = new ParkingSystem(big, medium, \nsmall);\n * bool param_1 = obj->addCar(carType);\n */",
      "solution": [
        "class ParkingSystem {\npublic:\n    \n    // Number of empty slots for each type of car\n    vector<int> empty;\n\n    ParkingSystem(int big, int medium, int small) {\n        this->empty = vector<int>{big, medium, small};\n    }\n\n    bool addCar(int carType) {\n\n        // If space is available, allocate and return True\n        if (this->empty[carType - 1] > 0) {\n            this->empty[carType - 1]--;\n            return true;\n        }\n\n        // Else, return False\n        return false;\n    }\n};"
      ]
    },
    {
      "number": 319,
      "question": "Can you solve this real interview question? Minimum One Bit Operations to Make Integers Zero - Given an integer n, you must transform it into 0 using the following operations any number of times:\n\n * Change the rightmost (0th) bit in the binary representation of n.\n * Change the ith bit in the binary representation of n if the (i-1)th bit is set to 1 and the (i-2)th through 0th bits are set to 0.\n\nReturn the minimum number of operations to transform n into 0.\n\n \n\nExample 1:\n\n\nInput: n = 3\nOutput: 2\nExplanation: The binary representation of 3 is \"11\".\n\"11\" -> \"01\" with the 2nd operation since the 0th bit is 1.\n\"01\" -> \"00\" with the 1st operation.\n\n\nExample 2:\n\n\nInput: n = 6\nOutput: 4\nExplanation: The binary representation of 6 is \"110\".\n\"110\" -> \"010\" with the 2nd operation since the 1st bit is 1 and 0th through 0th bits are 0.\n\"010\" -> \"011\" with the 1st operation.\n\"011\" -> \"001\" with the 2nd operation since the 0th bit is 1.\n\"001\" -> \"000\" with the 1st operation.\n\n\n \n\nConstraints:\n\n * 0 <= n <= 109",
      "code": "class Solution {\npublic:\n    int minimumOneBitOperations(int n) {\n        \n    }\n};",
      "solution": [
        "int f(int k) {\n    if (k == 0) {\n        return 1;\n    }\n    \n    return 2 * f(k - 1) + 1;\n}",
        "class Solution {\npublic:\n    int minimumOneBitOperations(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        \n        int k = 0;\n        int curr = 1;\n        while (curr * 2 <= n) {\n            curr *= 2;\n            k++;\n        }\n        \n        return (1 << (k + 1)) - 1 - minimumOneBitOperations(n ^ curr);\n    }\n};",
        "class Solution {\npublic:\n    int minimumOneBitOperations(int n) {\n        int ans = 0;\n        int k = 0;\n        int mask = 1;\n        \n        while (mask <= n) {\n            if ((n & mask) != 0) {\n                ans = (1 << (k + 1)) - 1 - ans;\n            }\n            \n            mask <<= 1;\n            k++;\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int minimumOneBitOperations(int n) {\n        int ans = n;\n        ans ^= ans >> 16;\n        ans ^= ans >> 8;\n        ans ^= ans >> 4;\n        ans ^= ans >> 2;\n        ans ^= ans >> 1;\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 320,
      "question": "Can you solve this real interview question? Largest Substring Between Two Equal Characters - Given a string s, return the length of the longest substring between two equal characters, excluding the two characters. If there is no such substring return -1.\n\nA substring is a contiguous sequence of characters within a string.\n\n \n\nExample 1:\n\n\nInput: s = \"aa\"\nOutput: 0\nExplanation: The optimal substring here is an empty substring between the two 'a's.\n\nExample 2:\n\n\nInput: s = \"abca\"\nOutput: 2\nExplanation: The optimal substring here is \"bc\".\n\n\nExample 3:\n\n\nInput: s = \"cbzxy\"\nOutput: -1\nExplanation: There are no characters that appear twice in s.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 300\n * s contains only lowercase English letters.",
      "code": "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        int ans = -1;\n        for (int left = 0; left < s.size(); left++) {\n            for (int right = left + 1; right < s.size(); right++) {\n                if (s[left] == s[right]) {\n                    ans = max(ans, right - left - 1);\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int maxLengthBetweenEqualCharacters(string s) {\n        unordered_map<char, int> firstIndex;\n        int ans = -1;\n        \n        for (int i = 0; i < s.size(); i++) {\n            if (firstIndex.find(s[i]) != firstIndex.end()) {\n                ans = max(ans, i - firstIndex[s[i]] - 1);\n            } else {\n                firstIndex[s[i]] = i;\n            }\n        }\n\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 321,
      "question": "Can you solve this real interview question? Slowest Key - A newly designed keypad was tested, where a tester pressed a sequence of n keys, one at a time.\n\nYou are given a string keysPressed of length n, where keysPressed[i] was the ith key pressed in the testing sequence, and a sorted list releaseTimes, where releaseTimes[i] was the time the ith key was released. Both arrays are 0-indexed. The 0th key was pressed at the time 0, and every subsequent key was pressed at the exact time the previous key was released.\n\nThe tester wants to know the key of the keypress that had the longest duration. The ith keypress had a duration of releaseTimes[i] - releaseTimes[i - 1], and the 0th keypress had a duration of releaseTimes[0].\n\nNote that the same key could have been pressed multiple times during the test, and these multiple presses of the same key may not have had the same duration.\n\nReturn the key of the keypress that had the longest duration. If there are multiple such keypresses, return the lexicographically largest key of the keypresses.\n\n \n\nExample 1:\n\n\nInput: releaseTimes = [9,29,49,50], keysPressed = \"cbcd\"\nOutput: \"c\"\nExplanation: The keypresses were as follows:\nKeypress for 'c' had a duration of 9 (pressed at time 0 and released at time 9).\nKeypress for 'b' had a duration of 29 - 9 = 20 (pressed at time 9 right after the release of the previous character and released at time 29).\nKeypress for 'c' had a duration of 49 - 29 = 20 (pressed at time 29 right after the release of the previous character and released at time 49).\nKeypress for 'd' had a duration of 50 - 49 = 1 (pressed at time 49 right after the release of the previous character and released at time 50).\nThe longest of these was the keypress for 'b' and the second keypress for 'c', both with duration 20.\n'c' is lexicographically larger than 'b', so the answer is 'c'.\n\n\nExample 2:\n\n\nInput: releaseTimes = [12,23,36,46,62], keysPressed = \"spuda\"\nOutput: \"a\"\nExplanation: The keypresses were as follows:\nKeypress for 's' had a duration of 12.\nKeypress for 'p' had a duration of 23 - 12 = 11.\nKeypress for 'u' had a duration of 36 - 23 = 13.\nKeypress for 'd' had a duration of 46 - 36 = 10.\nKeypress for 'a' had a duration of 62 - 46 = 16.\nThe longest of these was the keypress for 'a' with duration 16.\n\n \n\nConstraints:\n\n * releaseTimes.length == n\n * keysPressed.length == n\n * 2 <= n <= 1000\n * 1 <= releaseTimes[i] <= 109\n * releaseTimes[i] < releaseTimes[i+1]\n * keysPressed contains only lowercase English letters.",
      "code": "class Solution {\npublic:\n    char slowestKey(vector<int>& releaseTimes, string \nkeysPressed) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\n        unordered_map<char, int> durationMap;\n        durationMap[keysPressed[0]] = releaseTimes[0];\n        // find and store the keypress duration for each key in the durationMap\n        for (int i = 1; i < releaseTimes.size(); i++) {\n            int currentDuration = releaseTimes[i] - releaseTimes[i - 1];\n            char currentKey = keysPressed[i];\n            durationMap[currentKey] =\n                max(durationMap[currentKey], currentDuration);\n        }\n        char slowestKey = ' ';\n        int longestPressDuration = 0;\n        // iterate over the map to find the slowest key\n        for (auto mapElement : durationMap) {\n            char key = static_cast<char>(mapElement.first);\n            int duration = static_cast<int>(mapElement.second);\n            if (duration > longestPressDuration) {\n                longestPressDuration = duration;\n                slowestKey = key;\n            } else if (duration == longestPressDuration && key > slowestKey) {\n                slowestKey = key;\n            }\n        }\n        return slowestKey;\n    }\n};",
        "class Solution {\npublic:\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\n        int durationArray[26] = {0};\n        durationArray[keysPressed[0] - 'a'] = releaseTimes[0];\n        // find and store the key pressed duration for each key\n        for (int i = 1; i < releaseTimes.size(); i++) {\n            int currentDuration = releaseTimes[i] - releaseTimes[i - 1];\n            char currentKey = keysPressed[i];\n            durationArray[currentKey - 'a'] =\n                max(durationArray[currentKey - 'a'], currentDuration);\n        }\n        // initialize slowest key as 'z'\n        int slowestKeyIndex = 25;\n        // iterate from 'y' to 'a' to find slowest key\n        for (int currentKey = 24; currentKey >= 0; currentKey--) {\n            if (durationArray[currentKey] > durationArray[slowestKeyIndex]) {\n                slowestKeyIndex = currentKey;\n            }\n        }\n        return slowestKeyIndex + 'a';\n    }\n};",
        "class Solution {\npublic:\n    char slowestKey(vector<int>& releaseTimes, string keysPressed) {\n        int n = releaseTimes.size();\n        int longestPress = releaseTimes[0];\n        char slowestKey = keysPressed[0];\n        for (int i = 1; i < n; i++) {\n            int currentDuration = releaseTimes[i] - releaseTimes[i - 1];\n            // check if we found the key that is slower than slowestKey\n            if (currentDuration > longestPress ||\n                (currentDuration == longestPress &&\n                 keysPressed[i] > slowestKey)) {\n                // update the slowest key and longest press duration\n                longestPress = currentDuration;\n                slowestKey = keysPressed[i];\n            }\n        }\n        return slowestKey;\n    }\n};"
      ]
    },
    {
      "number": 322,
      "question": "Can you solve this real interview question? Arithmetic Subarrays - A sequence of numbers is called arithmetic if it consists of at least two elements, and the difference between every two consecutive elements is the same. More formally, a sequence s is arithmetic if and only if s[i+1] - s[i] == s[1] - s[0] for all valid i.\n\nFor example, these are arithmetic sequences:\n\n\n1, 3, 5, 7, 9\n7, 7, 7, 7\n3, -1, -5, -9\n\nThe following sequence is not arithmetic:\n\n\n1, 1, 2, 5, 7\n\nYou are given an array of n integers, nums, and two arrays of m integers each, l and r, representing the m range queries, where the ith query is the range [l[i], r[i]]. All the arrays are 0-indexed.\n\nReturn a list of boolean elements answer, where answer[i] is true if the subarray nums[l[i]], nums[l[i]+1], ... , nums[r[i]] can be rearranged to form an arithmetic sequence, and false otherwise.\n\n \n\nExample 1:\n\n\nInput: nums = [4,6,5,9,3,7], l = [0,0,2], r = [2,3,5]\nOutput: [true,false,true]\nExplanation:\nIn the 0th query, the subarray is [4,6,5]. This can be rearranged as [6,5,4], which is an arithmetic sequence.\nIn the 1st query, the subarray is [4,6,5,9]. This cannot be rearranged as an arithmetic sequence.\nIn the 2nd query, the subarray is [5,9,3,7]. This can be rearranged as [3,5,7,9], which is an arithmetic sequence.\n\nExample 2:\n\n\nInput: nums = [-12,-9,-3,-12,-6,15,20,-25,-20,-15,-10], l = [0,1,6,4,8,7], r = [4,4,9,7,9,10]\nOutput: [false,true,false,false,true,true]\n\n\n \n\nConstraints:\n\n * n == nums.length\n * m == l.length\n * m == r.length\n * 2 <= n <= 500\n * 1 <= m <= 500\n * 0 <= l[i] < r[i] < n\n * -105 <= nums[i] <= 105",
      "code": "class Solution {\npublic:\n    vector<bool> checkArithmeticSubarrays(vector<int>& nums, \nvector<int>& l, vector<int>& r) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool check(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int diff = arr[1] - arr[0];\n        \n        for (int i = 2; i < arr.size(); i++) {\n            if (arr[i] - arr[i - 1] != diff) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {\n        vector<bool> ans;\n        for (int i = 0; i < l.size(); i++) {\n            vector<int> arr(begin(nums) + l[i], begin(nums) + r[i] + 1);\n            ans.push_back(check(arr));\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    bool check(vector<int>& arr) {\n        int minElement = INT_MAX;\n        int maxElement = INT_MIN;\n        unordered_set<int> arrSet;\n        \n        for (int num : arr) {\n            minElement = min(minElement, num);\n            maxElement = max(maxElement, num);\n            arrSet.insert(num);\n        }\n        \n        if ((maxElement - minElement) % (arr.size() - 1) != 0) {\n            return false;\n        }\n        \n        int diff = (maxElement - minElement) / (arr.size() - 1);\n        int curr = minElement + diff;\n        \n        while (curr < maxElement) {\n            if (arrSet.find(curr) == arrSet.end()) {\n                return false;\n            }\n            \n            curr += diff;\n        }\n        \n        return true;\n    }\n    \n    vector<bool> checkArithmeticSubarrays(vector<int>& nums, vector<int>& l, vector<int>& r) {\n        vector<bool> ans;\n        for (int i = 0; i < l.size(); i++) {\n            vector<int> arr(begin(nums) + l[i], begin(nums) + r[i] + 1);\n            ans.push_back(check(arr));\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 323,
      "question": "Can you solve this real interview question? Hopper Company Queries I - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
      "code": "",
      "solution": [
        "import pandas as pd\n\ndef hopper_company(drivers: pd.DataFrame, rides: pd.DataFrame, accepted_rides: pd.DataFrame) -> pd.DataFrame:\n    # Approach: Subquery Constraint Tables, Left Join on months after\n    # months list for series creation\n    months = pd.DataFrame([num + 1 for num in range(12)], columns=[\"month\"])\n\n    # convert join_date to datetime\n    drivers['join_date'] = pd.to_datetime(drivers['join_date'])\n\n    # driver table - calculate active drivers that joined in 2020 or before\n    driver = drivers[drivers['join_date'] < '2021-01-01']\n\n    # utilize .apply() lambda function\n    # -> if year is 2020 -> return 1, else return month\n    driver['join_date'] = driver['join_date'].apply(lambda x: 1 if x.year != 2020 else x.month)\n\n    # grab count of each active driver per month\n    driver_count = driver.groupby('join_date').size().reset_index(name='active_drivers')\n\n    # join driver with months to create driver_count, aggregate over months\n    driver_months = months.merge(driver_count, how='left', left_on='month', right_on='join_date').fillna(0)\n    driver_months['active_drivers'] = driver_months['active_drivers'].cumsum()\n    \n    # join rides with accepted rides -> left join rides\n    all_rides = accepted_rides.merge(rides, how='left', on='ride_id')\n\n    # convert requested_at to type datetime\n    all_rides['requested_at'] = pd.to_datetime(all_rides['requested_at'])\n\n    # filter for requested year in 2020 and driver_id is currently a driver\n    all_rides = all_rides[(all_rides['requested_at'] > '2019-12-31') & (all_rides['requested_at'] < '2021-01-01')]\n    all_rides = all_rides[all_rides['driver_id'].isin(driver['driver_id'])]\n\n    # convert requested_at back to string & convert to month only using apply()\n    all_rides['requested_at'] = all_rides['requested_at'].apply(lambda x: 1 if x.year != 2020 else x.month)\n\n    # create accepted_rides by left joining driver months & all rides\n    accepted_rides = driver_months.merge(all_rides, how='left', left_on='month', right_on='requested_at')\n\n    # gather count of accepted rides by month\n    accepted_rides = accepted_rides.groupby('month')['requested_at'].count().reset_index(name='accepted_rides')\n  \n    # merge result with accepted_rides - RIGHT JOIN\n    result = driver_months.merge(accepted_rides, how='right', on='month')\n\n    # grab necessary columns, clear NaNs, apply as int\n    result = result[['month', 'active_drivers', 'accepted_rides']].fillna(0).astype(int)\n    \n    return result"
      ]
    },
    {
      "number": 324,
      "question": "Can you solve this real interview question? Number of Ways to Form a Target String Given a Dictionary - You are given a list of strings of the same length words and a string target.\n\nYour task is to form target using the given words under the following rules:\n\n * target should be formed from left to right.\n * To form the ith character (0-indexed) of target, you can choose the kth character of the jth string in words if target[i] = words[j][k].\n * Once you use the kth character of the jth string of words, you can no longer use the xth character of any string in words where x <= k. In other words, all characters to the left of or at index k become unusuable for every string.\n * Repeat the process until you form the string target.\n\nNotice that you can use multiple characters from the same string in words provided the conditions above are met.\n\nReturn the number of ways to form target from words. Since the answer may be too large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: words = [\"acca\",\"bbbb\",\"caca\"], target = \"aba\"\nOutput: 6\nExplanation: There are 6 ways to form target.\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\"aba\" -> index 0 (\"acca\"), index 1 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 0 (\"acca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"acca\")\n\"aba\" -> index 1 (\"caca\"), index 2 (\"bbbb\"), index 3 (\"caca\")\n\n\nExample 2:\n\n\nInput: words = [\"abba\",\"baab\"], target = \"bab\"\nOutput: 4\nExplanation: There are 4 ways to form target.\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 2 (\"abba\")\n\"bab\" -> index 0 (\"baab\"), index 1 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 0 (\"baab\"), index 2 (\"baab\"), index 3 (\"baab\")\n\"bab\" -> index 1 (\"abba\"), index 2 (\"baab\"), index 3 (\"baab\")\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 1000\n * 1 <= words[i].length <= 1000\n * All strings in words have the same length.\n * 1 <= target.length <= 1000\n * words[i] and target contain only lowercase English letters.",
      "code": "class Solution {\npublic:\n    int numWays(vector<string>& words, string target) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int numWays(vector<string>& words, string target) {\n        const int ALPHABET_SIZE = 26;\n        const int MOD = 1000000007;\n        int targetLength = target.size();\n        int wordLength = words[0].size();\n        vector<vector<int>> charOccurrences(ALPHABET_SIZE, vector<int>(wordLength));\n        \n        for (int col = 0; col < wordLength; col++) {\n            for (const string& word : words) {\n                charOccurrences[word[col] - 'a'][col]++;\n            }\n        }\n        \n        vector<vector<long long>> dp(targetLength + 1, vector<long long>(wordLength + 1));\n        dp[0][0] = 1;\n        \n        for (int length = 0; length <= targetLength; length++) {\n            for (int col = 0; col < wordLength; col++) {\n                if (length < targetLength) {\n                    dp[length + 1][col + 1] = (dp[length + 1][col + 1] + \n                        (charOccurrences[target[length] - 'a'][col] * dp[length][col]) % MOD) % MOD;\n                }\n                dp[length][col + 1] = (dp[length][col + 1] + dp[length][col]) % MOD;\n            }\n        }\n        \n        return dp[targetLength][wordLength];\n    }\n};",
        "class Solution {\npublic:\n    int numWays(vector<string>& words, string target) {\n        const int ALPHABET_SIZE = 26;\n        const int MOD = 1000000007;\n        int targetLength = target.size(), wordLength = words[0].size();\n        vector<vector<int>> charOccurrences(ALPHABET_SIZE, vector<int>(wordLength));\n        for (int col = 0; col < wordLength; col++) {\n            for (const string& word : words) {\n                charOccurrences[word[col] - 'a'][col]++;\n            }\n        }\n        \n        function<long long(int, int)> calculateDP = [&](int length, int col) -> long long {\n            if (col == 0) {\n                return length == 0 ? 1 : 0;\n            }\n            long long result = calculateDP(length, col - 1);\n            if (length > 0) {\n                result += charOccurrences[target[length - 1] - 'a'][col - 1] * calculateDP(length - 1, col - 1);\n            }\n            result %= MOD;\n            return result;\n        };\n        \n        return calculateDP(targetLength, wordLength);\n    }\n};",
        "class Solution {\npublic:\n    int numWays(vector<string>& words, string target) {\n        const int ALPHABET_SIZE = 26;\n        const int MOD = 1000000007;\n        int targetLength = target.size(), wordLength = words[0].size();\n        vector<vector<int>> charOccurrences(ALPHABET_SIZE, vector<int>(wordLength));\n        for (int col = 0; col < wordLength; col++) {\n            for (const string& word : words) {\n                charOccurrences[word[col] - 'a'][col]++;\n            }\n        }\n        vector dp(targetLength + 1, vector<long long>(wordLength + 1, -1));\n        \n        function<long long(int, int)> calculateDP = [&](int length, int col) -> long long {\n            if (col == 0) {\n                return length == 0 ? 1 : 0;\n            }\n            if (dp[length][col] != -1) {\n                return dp[length][col];\n            }\n            dp[length][col] = calculateDP(length, col - 1);\n            if (length > 0) {\n                dp[length][col] += charOccurrences[target[length - 1] - 'a'][col - 1] * calculateDP(length - 1, col - 1);\n            }\n            dp[length][col] %= MOD;\n            return dp[length][col];\n        };\n        \n        return calculateDP(targetLength, wordLength);\n    }\n};"
      ]
    },
    {
      "number": 325,
      "question": "Can you solve this real interview question? Average Time of Process per Machine - Table: Activity\n\n\n+----------------+---------+\n| Column Name    | Type    |\n+----------------+---------+\n| machine_id     | int     |\n| process_id     | int     |\n| activity_type  | enum    |\n| timestamp      | float   |\n+----------------+---------+\nThe table shows the user activities for a factory website.\n(machine_id, process_id, activity_type) is the primary key (combination of columns with unique values) of this table.\nmachine_id is the ID of a machine.\nprocess_id is the ID of a process running on the machine with ID machine_id.\nactivity_type is an ENUM (category) of type ('start', 'end').\ntimestamp is a float representing the current time in seconds.\n'start' means the machine starts the process at the given timestamp and 'end' means the machine ends the process at the given timestamp.\nThe 'start' timestamp will always be before the 'end' timestamp for every (machine_id, process_id) pair.\n\n \n\nThere is a factory website that has several machines each running the same number of processes. Write a solution to find the average time each machine takes to complete a process.\n\nThe time to complete a process is the 'end' timestamp minus the 'start' timestamp. The average time is calculated by the total time to complete every process on the machine divided by the number of processes that were run.\n\nThe resulting table should have the machine_id along with the average time as processing_time, which should be rounded to 3 decimal places.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nActivity table:\n+------------+------------+---------------+-----------+\n| machine_id | process_id | activity_type | timestamp |\n+------------+------------+---------------+-----------+\n| 0          | 0          | start         | 0.712     |\n| 0          | 0          | end           | 1.520     |\n| 0          | 1          | start         | 3.140     |\n| 0          | 1          | end           | 4.120     |\n| 1          | 0          | start         | 0.550     |\n| 1          | 0          | end           | 1.550     |\n| 1          | 1          | start         | 0.430     |\n| 1          | 1          | end           | 1.420     |\n| 2          | 0          | start         | 4.100     |\n| 2          | 0          | end           | 4.512     |\n| 2          | 1          | start         | 2.500     |\n| 2          | 1          | end           | 5.000     |\n+------------+------------+---------------+-----------+\nOutput: \n+------------+-----------------+\n| machine_id | processing_time |\n+------------+-----------------+\n| 0          | 0.894           |\n| 1          | 0.995           |\n| 2          | 1.456           |\n+------------+-----------------+\nExplanation: \nThere are 3 machines running 2 processes each.\nMachine 0's average time is ((1.520 - 0.712) + (4.120 - 3.140)) / 2 = 0.894\nMachine 1's average time is ((1.550 - 0.550) + (1.420 - 0.430)) / 2 = 0.995\nMachine 2's average time is ((4.512 - 4.100) + (5.000 - 2.500)) / 2 = 1.456\n",
      "code": "# Write your MySQL query statement below\n",
      "solution": [
        "import pandas as pd\n\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\n\n    activity['timestamp'] = activity.apply(lambda x: x.timestamp * -1 if x.activity_type == 'start' else x.timestamp, axis=1)\n\n    sum_machine_process = activity.groupby(['machine_id', 'process_id'], as_index=False)['timestamp'].sum()\n\n    mean_machine = sum_machine_process.groupby(['machine_id'], as_index=False)['timestamp'].mean().round(3).rename(columns = {'timestamp': 'processing_time'})\n    \n    return mean_machine",
        "import pandas as pd\n\ndef get_average_time(activity: pd.DataFrame) -> pd.DataFrame:\n    \n    start_df = activity[activity['activity_type'] == 'start']\n    \n    end_df = activity[activity['activity_type'] == 'end']\n    \n    merge_df = end_df.merge(start_df, on = ['machine_id', 'process_id'])\n    \n    df = merge_df.assign(processing_time = merge_df['timestamp_x'] - merge_df['timestamp_y']).groupby(['machine_id'], as_index=False)['processing_time'].mean().round(3)\n\n    return df"
      ]
    },
    {
      "number": 326,
      "question": "Can you solve this real interview question? Check If Two String Arrays are Equivalent - Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.\n\nA string is represented by an array if the array elements concatenated in order forms the string.\n\n \n\nExample 1:\n\n\nInput: word1 = [\"ab\", \"c\"], word2 = [\"a\", \"bc\"]\nOutput: true\nExplanation:\nword1 represents string \"ab\" + \"c\" -> \"abc\"\nword2 represents string \"a\" + \"bc\" -> \"abc\"\nThe strings are the same, so return true.\n\nExample 2:\n\n\nInput: word1 = [\"a\", \"cb\"], word2 = [\"ab\", \"c\"]\nOutput: false\n\n\nExample 3:\n\n\nInput: word1  = [\"abc\", \"d\", \"defg\"], word2 = [\"abcddefg\"]\nOutput: true\n\n\n \n\nConstraints:\n\n * 1 <= word1.length, word2.length <= 103\n * 1 <= word1[i].length, word2[i].length <= 103\n * 1 <= sum(word1[i].length), sum(word2[i].length) <= 103\n * word1[i] and word2[i] consist of lowercase letters.",
      "code": "class Solution {\npublic:\n    bool arrayStringsAreEqual(vector<string>& word1, \nvector<string>& word2) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {\n        // Creates a new string by combining all the strings in word1.\n        string word1Combined;\n        for (string s : word1) {\n            word1Combined += s;\n        }\n        // Creates a new string by combining all the strings in word2.\n        string word2Combined;\n        for (string s : word2) {\n            word2Combined += s;\n        }\n        // Returns true if both string are the same.\n        return word1Combined == word2Combined;\n    }\n};",
        "class Solution {\npublic:\n    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {\n        // Pointers to mark the current word in the given two lists.\n        int word1Pointer = 0, word2Pointer = 0;\n        // Pointers to mark the character in the string pointed by the above pointers.\n        int string1Pointer = 0, string2Pointer = 0;\n        \n        // While we still have the string in any of the two given lists.\n        while (word1Pointer < word1.size() && word2Pointer < word2.size()) {\n            // If the characters at the two string are same, increment the string pointers\n            // Otherwise return false.\n            if (word1[word1Pointer][string1Pointer++] != word2[word2Pointer][string2Pointer++]) {\n                return false;\n            }\n            // If the string pointer reaches the end of string in the list word1, \n            // Move to the next string in the list and, reset the string pointer to 0.\n            if (string1Pointer == word1[word1Pointer].size()) {\n                word1Pointer++;\n                string1Pointer = 0;\n            }\n            // If the string pointer reaches the end of string in the list word2, \n            // Move to the next string in the list and, reset the string pointer to 0.\n            if (string2Pointer == word2[word2Pointer].size()) {\n                word2Pointer++;\n                string2Pointer = 0;\n            }\n        }\n        // Strings in both the lists should be traversed.\n        return word1Pointer == word1.size() && word2Pointer == word2.size();\n    }\n};"
      ]
    },
    {
      "number": 327,
      "question": "Can you solve this real interview question? Sum of Absolute Differences in a Sorted Array - You are given an integer array nums sorted in non-decreasing order.\n\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\n\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 <= j < nums.length and j != i (0-indexed).\n\n \n\nExample 1:\n\n\nInput: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.\n\n\nExample 2:\n\n\nInput: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 105\n * 1 <= nums[i] <= nums[i + 1] <= 104",
      "code": "class Solution {\npublic:\n    vector<int> getSumAbsoluteDifferences(vector<int>& nums) \n{\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    vector<int> getSumAbsoluteDifferences(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> prefix = {nums[0]};\n        for (int i = 1; i < n; i++) {\n            prefix.push_back(prefix[i - 1] + nums[i]);\n        }\n        \n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            int leftSum = prefix[i] - nums[i];\n            int rightSum = prefix[n - 1] - prefix[i];\n            \n            int leftCount = i;\n            int rightCount = n - 1 - i;\n            \n            int leftTotal = leftCount * nums[i] - leftSum;\n            int rightTotal = rightSum - rightCount * nums[i];\n            \n            ans.push_back(leftTotal + rightTotal);\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    vector<int> getSumAbsoluteDifferences(vector<int>& nums) {\n        int n = nums.size();\n        int totalSum = accumulate(nums.begin(), nums.end(), 0);\n        \n        int leftSum = 0;\n        vector<int> ans;\n        for (int i = 0; i < n; i++) {\n            int rightSum = totalSum - leftSum - nums[i];\n            \n            int leftCount = i;\n            int rightCount = n - 1 - i;\n            \n            int leftTotal = leftCount * nums[i] - leftSum;\n            int rightTotal = rightSum - rightCount * nums[i];\n            \n            ans.push_back(leftTotal + rightTotal);\n            leftSum += nums[i];\n        }\n        \n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 328,
      "question": "Can you solve this real interview question? Count of Matches in Tournament - You are given an integer n, the number of teams in a tournament that has strange rules:\n\n * If the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.\n * If the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.\n\nReturn the number of matches played in the tournament until a winner is decided.\n\n \n\nExample 1:\n\n\nInput: n = 7\nOutput: 6\nExplanation: Details of the tournament: \n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n\n\nExample 2:\n\n\nInput: n = 14\nOutput: 13\nExplanation: Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 200",
      "code": "class Solution {\npublic:\n    int numberOfMatches(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int numberOfMatches(int n) {\n        int ans = 0;\n        while (n > 1) {\n            if (n % 2 == 0) {\n                ans += n / 2;\n                n = n / 2;\n            } else {\n                ans += (n - 1) / 2;\n                n = (n - 1) / 2 + 1;\n            }\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int numberOfMatches(int n) {\n        return n - 1;\n    }\n};"
      ]
    },
    {
      "number": 329,
      "question": "Can you solve this real interview question? Calculate Money in Leetcode Bank - Hercy wants to save money for his first car. He puts money in the Leetcode bank every day.\n\nHe starts by putting in $1 on Monday, the first day. Every day from Tuesday to Sunday, he will put in $1 more than the day before. On every subsequent Monday, he will put in $1 more than the previous Monday.\n\nGiven n, return the total amount of money he will have in the Leetcode bank at the end of the nth day.\n\n \n\nExample 1:\n\n\nInput: n = 4\nOutput: 10\nExplanation: After the 4th day, the total is 1 + 2 + 3 + 4 = 10.\n\n\nExample 2:\n\n\nInput: n = 10\nOutput: 37\nExplanation: After the 10th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37. Notice that on the 2nd Monday, Hercy only puts in $2.\n\n\nExample 3:\n\n\nInput: n = 20\nOutput: 96\nExplanation: After the 20th day, the total is (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) + (3 + 4 + 5 + 6 + 7 + 8) = 96.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 1000",
      "code": "class Solution {\npublic:\n    int totalMoney(int n) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int totalMoney(int n) {\n        int ans = 0;\n        int monday = 1;\n        \n        while (n > 0) {\n            for (int day = 0; day < min(n, 7); day++) {\n                ans += monday + day;\n            }\n            \n            n -= 7;\n            monday++;\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int totalMoney(int n) {\n        int k = n / 7;\n        int F = 28;\n        int L = 28 + (k - 1) * 7;\n        int arithmeticSum = k * (F + L) / 2;\n        \n        int monday = 1 + k;\n        int finalWeek = 0;\n        for (int day = 0; day < n % 7; day++) {\n            finalWeek += monday + day;\n        }\n        \n        return arithmeticSum + finalWeek;\n    }\n};"
      ]
    },
    {
      "number": 330,
      "question": "Can you solve this real interview question? Largest Submatrix With Rearrangements - You are given a binary matrix matrix of size m x n, and you are allowed to rearrange the columns of the matrix in any order.\n\nReturn the area of the largest submatrix within matrix where every element of the submatrix is 1 after reordering the columns optimally.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40536-pm.png]\n\n\nInput: matrix = [[0,0,1],[1,1,1],[1,0,1]]\nOutput: 4\nExplanation: You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 4.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/12/29/screenshot-2020-12-30-at-40852-pm.png]\n\n\nInput: matrix = [[1,0,1,0,1]]\nOutput: 3\nExplanation: You can rearrange the columns as shown above.\nThe largest submatrix of 1s, in bold, has an area of 3.\n\n\nExample 3:\n\n\nInput: matrix = [[1,1,0],[1,0,1]]\nOutput: 2\nExplanation: Notice that you must rearrange entire columns, and there is no way to make a submatrix of 1s larger than an area of 2.\n\n\n \n\nConstraints:\n\n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m * n <= 105\n * matrix[i][j] is either 0 or 1.",
      "code": "class Solution {\npublic:\n    int largestSubmatrix(vector<vector<int>>& matrix) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int largestSubmatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        int ans = 0;\n        \n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < n; col++) {\n                if (matrix[row][col] != 0 && row > 0) {\n                    matrix[row][col] += matrix[row - 1][col];\n                }\n            }\n            \n            vector<int> currRow = matrix[row];\n            sort(currRow.begin(), currRow.end(), greater());\n            for (int i = 0; i < n; i++) {\n                ans = max(ans, currRow[i] * (i + 1));\n            }\n        }\n        \n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int largestSubmatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<int> prevRow = vector(n, 0);\n        int ans = 0;\n        \n        for (int row = 0; row < m; row++) {\n            vector<int> currRow = matrix[row];\n            for (int col = 0; col < n; col++) {\n                if (currRow[col] != 0) {\n                    currRow[col] += prevRow[col];\n                }\n            }\n            \n            vector<int> sortedRow = currRow;\n            sort(sortedRow.begin(), sortedRow.end(), greater());\n            for (int i = 0; i < n; i++) {\n                ans = max(ans, sortedRow[i] * (i + 1));\n            }\n            \n            prevRow = currRow;\n        }\n\n        return ans;\n    }\n};",
        "class Solution {\npublic:\n    int largestSubmatrix(vector<vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        vector<pair<int,int>> prevHeights;\n        int ans = 0;\n        \n        for (int row = 0; row < m; row++) {\n            vector<pair<int,int>> heights;\n            vector<bool> seen = vector(n, false);\n            \n            for (auto [height, col] : prevHeights) {\n                if (matrix[row][col] == 1) {\n                    heights.push_back({height + 1, col});\n                    seen[col] = true;\n                }\n            }\n            \n            for (int col = 0; col < n; col++) {\n                if (seen[col] == false && matrix[row][col] == 1) {\n                    heights.push_back({1, col});\n                }\n            }\n            \n            for (int i = 0; i < heights.size(); i++) {\n                ans = max(ans, heights[i].first * (i + 1));\n            }\n            \n            prevHeights = heights;\n        }\n\n        return ans;\n    }\n};"
      ]
    },
    {
      "number": 331,
      "question": "Can you solve this real interview question? Find the Highest Altitude - There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\n\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i and i + 1 for all (0 <= i < n). Return the highest altitude of a point.\n\n \n\nExample 1:\n\n\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n\n\nExample 2:\n\n\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n\n\n \n\nConstraints:\n\n * n == gain.length\n * 1 <= n <= 100\n * -100 <= gain[i] <= 100",
      "code": "class Solution {\npublic:\n    int largestAltitude(vector<int>& gain) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    int largestAltitude(vector<int>& gain) {\n        int currentAltitude = 0;\n        // Highest altitude currently is 0.\n        int highestPoint = currentAltitude;\n        \n        for (int altitudeGain : gain) {\n            // Adding the gain in altitude to the current altitude.\n            currentAltitude += altitudeGain;\n            // Update the highest altitude.\n            highestPoint = max(highestPoint, currentAltitude);\n        }\n        \n        return highestPoint;\n    }\n};"
      ]
    },
    {
      "number": 332,
      "question": "Can you solve this real interview question? Restore the Array From Adjacent Pairs - There is an integer array nums that consists of n unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in nums.\n\nYou are given a 2D integer array adjacentPairs of size n - 1 where each adjacentPairs[i] = [ui, vi] indicates that the elements ui and vi are adjacent in nums.\n\nIt is guaranteed that every adjacent pair of elements nums[i] and nums[i+1] will exist in adjacentPairs, either as [nums[i], nums[i+1]] or [nums[i+1], nums[i]]. The pairs can appear in any order.\n\nReturn the original array nums. If there are multiple solutions, return any of them.\n\n \n\nExample 1:\n\n\nInput: adjacentPairs = [[2,1],[3,4],[3,2]]\nOutput: [1,2,3,4]\nExplanation: This array has all its adjacent pairs in adjacentPairs.\nNotice that adjacentPairs[i] may not be in left-to-right order.\n\n\nExample 2:\n\n\nInput: adjacentPairs = [[4,-2],[1,4],[-3,1]]\nOutput: [-2,4,1,-3]\nExplanation: There can be negative numbers.\nAnother solution is [-3,1,4,-2], which would also be accepted.\n\n\nExample 3:\n\n\nInput: adjacentPairs = [[100000,-100000]]\nOutput: [100000,-100000]\n\n\n \n\nConstraints:\n\n * nums.length == n\n * adjacentPairs.length == n - 1\n * adjacentPairs[i].length == 2\n * 2 <= n <= 105\n * -105 <= nums[i], ui, vi <= 105\n * There exists some nums that has adjacentPairs as its pairs.",
      "code": "class Solution {\npublic:\n    vector<int> restoreArray(vector<vector<int>>& \nadjacentPairs) {\n        \n    }\n};",
      "solution": [
        "class Solution {\npublic:\n    unordered_map<int, vector<int>> graph;\n    \n    vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {\n        for (auto& edge : adjacentPairs) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        int root = 0;\n        for (auto& pair : graph) {\n            if (pair.second.size() == 1) {\n                root = pair.first;\n                break;\n            }\n        }\n        \n        vector<int> ans;\n        dfs(root, INT_MAX, ans);\n        return ans;\n    }\n    \n    void dfs(int node, int prev, vector<int>& ans) {\n        ans.push_back(node);\n        for (int neighbor : graph[node]) {\n            if (neighbor != prev) {\n                dfs(neighbor, node, ans);\n            }\n        }\n    }\n};",
        "class Solution {\npublic:\n    vector<int> restoreArray(vector<vector<int>>& adjacentPairs) {\n        unordered_map<int, vector<int>> graph;\n\n        for (auto& edge : adjacentPairs) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        int root = 0;\n        for (auto& pair : graph) {\n            if (pair.second.size() == 1) {\n                root = pair.first;\n                break;\n            }\n        }\n        \n        int curr = root;\n        vector<int> ans = {root};\n        int prev = INT_MAX;\n        \n        while (ans.size() < graph.size()) {\n            for (int neighbor : graph[curr]) {\n                if (neighbor != prev) {\n                    ans.push_back(neighbor);\n                    prev = curr;\n                    curr = neighbor;\n                    break;\n                }\n            }\n        }\n\n        return ans;\n    }\n};"
      ]
    }
  ]