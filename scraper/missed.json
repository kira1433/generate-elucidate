[
  {
    "number": 1,
    "question": "Can you solve this real interview question? Minimum Size Subarray Sum - Given an array of positive integers nums and a positive integer target, return the minimal length of a subarray whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\n \n\nExample 1:\n\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\n\n\nExample 2:\n\n\nInput: target = 4, nums = [1,4,4]\nOutput: 1\n\n\nExample 3:\n\n\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n\n\n \n\nConstraints:\n\n * 1 <= target <= 109\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 104\n\n \n\nFollow up: If you have figured out the O(n) solution, try coding another solution of which the time complexity is O(n log(n)).",
    "code": "class Solution {\npublic:\n    int minSubArrayLen(int target, vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = 0;\n            for (int k = i; k <= j; k++) {\n                sum += nums[k];\n            }\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}",
      "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n);\n    sums[0] = nums[0];\n    for (int i = 1; i < n; i++)\n        sums[i] = sums[i - 1] + nums[i];\n    for (int i = 0; i < n; i++) {\n        for (int j = i; j < n; j++) {\n            int sum = sums[j] - sums[i] + nums[i];\n            if (sum >= s) {\n                ans = min(ans, (j - i + 1));\n                break; //Found the smallest subarray with sum>=s starting with index i, hence move to next index\n            }\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}",
      "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    if (n == 0)\n        return 0;\n    int ans = INT_MAX;\n    vector<int> sums(n + 1, 0); //size = n+1 for easier calculations\n    //sums[0]=0 : Meaning that it is the sum of first 0 elements\n    //sums[1]=A[0] : Sum of first 1 elements\n    //ans so on...\n    for (int i = 1; i <= n; i++)\n        sums[i] = sums[i - 1] + nums[i - 1];\n    for (int i = 1; i <= n; i++) {\n        int to_find = s + sums[i - 1];\n        auto bound = lower_bound(sums.begin(), sums.end(), to_find);\n        if (bound != sums.end()) {\n            ans = min(ans, static_cast<int>(bound - (sums.begin() + i - 1)));\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}",
      "int minSubArrayLen(int s, vector<int>& nums)\n{\n    int n = nums.size();\n    int ans = INT_MAX;\n    int left = 0;\n    int sum = 0;\n    for (int i = 0; i < n; i++) {\n        sum += nums[i];\n        while (sum >= s) {\n            ans = min(ans, i + 1 - left);\n            sum -= nums[left++];\n        }\n    }\n    return (ans != INT_MAX) ? ans : 0;\n}"
    ]
  },
  {
    "number": 2,
    "question": "Can you solve this real interview question? Shortest Palindrome - You are given a string s. You can convert s to a palindrome by adding characters in front of it.\n\nReturn the shortest palindrome you can find by performing this transformation.\n\n \n\nExample 1:\n\nInput: s = \"aacecaaa\"\nOutput: \"aaacecaaa\"\n\n\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"dcbabcd\"\n\n\n \n\nConstraints:\n\n * 0 <= s.length <= 5 * 104\n * s consists of lowercase English letters only.",
    "code": "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int n = s.size();\n        string rev(s);\n        reverse(rev.begin(), rev.end());\n        for (int i = 0; i < n; i++) {\n            if (s.substr(0, n - i) == rev.substr(i))\n                return rev.substr(0, i) + s;\n        }\n        return \"\";\n    }\n};",
      "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int n = s.size();\n        int i = 0;\n        for (int j = n - 1; j >= 0; j--) {\n            if (s[i] == s[j])\n                i++;\n        }\n        if (i == n) {\n            return s;\n        }\n        string remain_rev = s.substr(i, n);\n        reverse(remain_rev.begin(), remain_rev.end());\n        return remain_rev + shortestPalindrome(s.substr(0, i)) + s.substr(i);\n    }\n};",
      "class Solution {\npublic:\n    string shortestPalindrome(string s) {\n        int n = s.size();\n        string rev(s);\n        reverse(rev.begin(), rev.end());\n        string s_new = s + \"#\" + rev;\n        int n_new = s_new.size();\n        vector<int> f(n_new, 0);\n        for (int i = 1; i < n_new; i++) {\n            int t = f[i - 1];\n            while (t > 0 && s_new[i] != s_new[t]) {\n                t = f[t - 1];\n            }\n            if (s_new[i] == s_new[t]) {\n                ++t;\n            }\n            f[i] = t;\n        }\n        return rev.substr(0, n - f[n_new - 1]) + s;\n    }\n};"
    ]
  },
  {
    "number": 3,
    "question": "Can you solve this real interview question? Basic Calculator II - Given a string s which represents an expression, evaluate this expression and return its value. \n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-231, 231 - 1].\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\nExample 1:\n\nInput: s = \"3+2*2\"\nOutput: 7\n\n\nExample 2:\n\nInput: s = \" 3/2 \"\nOutput: 1\n\n\nExample 3:\n\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 3 * 105\n * s consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.\n * s represents a valid expression.\n * All the integers in the expression are non-negative integers in the range [0, 231 - 1].\n * The answer is guaranteed to fit in a 32-bit integer.",
    "code": "class Solution {\npublic:\n    int calculate(string s) {\n        \n    }\n};",
    "solution": [
      "\nclass Solution {\npublic:\n    int calculate(string s) {\n        int len = s.length();\n        if (len == 0) return 0;\n        stack<int> stack;\n        int currentNumber = 0;\n        char operation = '+';\n        for (int i = 0; i < len; i++) {\n            char currentChar = s[i];\n            if (isdigit(currentChar)) {\n                currentNumber = (currentNumber * 10) + (currentChar - '0');\n            }\n            if (!isdigit(currentChar) && !iswspace(currentChar) || i == len - 1) {\n                if (operation == '-') {\n                    stack.push(-currentNumber);\n                } else if (operation == '+') {\n                    stack.push(currentNumber);\n                } else if (operation == '*') {\n                    int stackTop = stack.top();\n                    stack.pop();\n                    stack.push(stackTop * currentNumber);\n                } else if (operation == '/') {\n                    int stackTop = stack.top();\n                    stack.pop();\n                    stack.push(stackTop / currentNumber);\n                }\n                operation = currentChar;\n                currentNumber = 0;\n            }\n        }\n        int result = 0;\n        while (stack.size() != 0) {\n            result += stack.top();\n            stack.pop();\n        }\n        return result;\n    }\n};\n",
      "class Solution {\npublic:\n    int calculate(string s) {\n        int length = s.length();\n        if (length == 0) return 0;\n        int currentNumber = 0, lastNumber = 0, result = 0;\n        char sign = '+';\n        for (int i = 0; i < length; i++) {\n            char currentChar = s[i];\n            if (isdigit(currentChar)) {\n                currentNumber = (currentNumber * 10) + (currentChar - '0');\n            }\n            if (!isdigit(currentChar) && !iswspace(currentChar) || i == length - 1) {\n                if (sign == '+' || sign == '-') {\n                    result += lastNumber;\n                    lastNumber = (sign == '+') ? currentNumber : -currentNumber;\n                } else if (sign == '*') {\n                    lastNumber = lastNumber * currentNumber;\n                } else if (sign == '/') {\n                    lastNumber = lastNumber / currentNumber;\n                }\n                sign = currentChar;\n                currentNumber = 0;\n            }\n        }\n        result += lastNumber;\n        return result;  \n    }\n};"
    ]
  },
  {
    "number": 4,
    "question": "Can you solve this real interview question? Implement Queue using Stacks - Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\n\nImplement the MyQueue class:\n\n * void push(int x) Pushes element x to the back of the queue.\n * int pop() Removes the element from the front of the queue and returns it.\n * int peek() Returns the element at the front of the queue.\n * boolean empty() Returns true if the queue is empty, false otherwise.\n\nNotes:\n\n * You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\n * Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n\n \n\nExample 1:\n\n\nInput\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n\nExplanation\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n\n\n \n\nConstraints:\n\n * 1 <= x <= 9\n * At most 100 calls will be made to push, pop, peek, and empty.\n * All the calls to pop and peek are valid.\n\n \n\nFollow-up: Can you implement the queue such that each operation is amortized [https://en.wikipedia.org/wiki/Amortized_analysis] O(1) time complexity? In other words, performing n operations will take overall O(n) time even if one of those operations may take longer.",
    "code": "class MyQueue {\npublic:\n    MyQueue() {\n        \n    }\n    \n    void push(int x) {\n        \n    }\n    \n    int pop() {\n        \n    }\n    \n    int peek() {\n        \n    }\n    \n    bool empty() {\n        \n    }\n};\n\n/**\n * Your MyQueue object will be instantiated and called as ",
    "solution": [
      "private int front;\n\npublic void push(int x) {\n    if (s1.empty())\n        front = x;\n    while (!s1.isEmpty())\n        s2.push(s1.pop());\n    s2.push(x);\n    while (!s2.isEmpty())\n        s1.push(s2.pop());\n}",
      "public int pop() {\n    int res = s1.pop();\n    if (!s1.empty())\n        front = s1.peek();\n    return res;\n}",
      "// Return whether the queue is empty.\npublic boolean empty() {\n    return s1.isEmpty();\n}",
      "// Get the front element.\npublic int peek() {\n  return front;\n}",
      "\nprivate Stack<Integer> s1 = new Stack<>();\nprivate Stack<Integer> s2 = new Stack<>();\n\n// Push element x to the back of queue.\npublic void push(int x) {\n    if (s1.empty())\n        front = x;\n    s1.push(x);\n}",
      "    public int pop() {\n        if (s2.isEmpty()) {\n            while (!s1.isEmpty())\n                s2.push(s1.pop());\n        }\n        return s2.pop();\n    }",
      "\n// Return whether the queue is empty.\npublic boolean empty() {\n    return s1.isEmpty() && s2.isEmpty();\n}",
      "// Get the front element.\npublic int peek() {\n    if (!s2.isEmpty()) {\n            return s2.peek();\n    }\n    return front;\n}"
    ]
  },
  {
    "number": 5,
    "question": "Can you solve this real interview question? Number of Digit One - Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n\n \n\nExample 1:\n\n\nInput: n = 13\nOutput: 6\n\n\nExample 2:\n\n\nInput: n = 0\nOutput: 0\n\n\n \n\nConstraints:\n\n * 0 <= n <= 109",
    "code": "class Solution {\npublic:\n    int countDigitOne(int n) {\n        \n    }\n};",
    "solution": [
      "int countDigitOne(int n)\n{\n    int countr = 0;\n    for (int i = 1; i <= n; i++) {\n        string str = to_string(i);\n        countr += count(str.begin(), str.end(), '1');\n    }\n    return countr;\n}",
      "int countDigitOne(int n)\n{\n    int countr = 0;\n    for (long long i = 1; i <= n; i *= 10) {\n        long long divider = i * 10;\n        countr += (n / divider) * i + min(max(n % divider - i + 1, 0LL), i);\n    }\n    return countr;\n}"
    ]
  },
  {
    "number": 6,
    "question": "Can you solve this real interview question? Delete Node in a Linked List - There is a singly-linked list head and we want to delete a node node in it.\n\nYou are given the node to be deleted node. You will not be given access to the first node of head.\n\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\n\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\n\n * The value of the given node should not exist in the linked list.\n * The number of nodes in the linked list should decrease by one.\n * All the values before node should be in the same order.\n * All the values after node should be in the same order.\n\nCustom testing:\n\n * For the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\n * We will build the linked list and pass the node to your function.\n * The output will be the entire list after calling your function.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/09/01/node1.jpg]\n\n\nInput: head = [4,5,1,9], node = 5\nOutput: [4,1,9]\nExplanation: You are given the second node with value 5, the linked list should become 4 -> 1 -> 9 after calling your function.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/09/01/node2.jpg]\n\n\nInput: head = [4,5,1,9], node = 1\nOutput: [4,5,9]\nExplanation: You are given the third node with value 1, the linked list should become 4 -> 5 -> 9 after calling your function.\n\n\n \n\nConstraints:\n\n * The number of the nodes in the given list is in the range [2, 1000].\n * -1000 <= Node.val <= 1000\n * The value of each node in the list is unique.\n * The node to be deleted is in the list and is not a tail node.",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        // Since we know input node is not last node, so nextNode will not be null\n        ListNode *nextNode = node->next;\n        // Step 2\n        node->val = nextNode->val;\n        // Step 3\n        node->next = nextNode->next;\n        nextNode->next = nullptr;\n        delete(nextNode);\n    }\n};"
    ]
  },
  {
    "number": 7,
    "question": "Can you solve this real interview question? Maximum Binary Tree - You are given an integer array nums with no duplicates. A maximum binary tree can be built recursively from nums using the following algorithm:\n\n 1. Create a root node whose value is the maximum value in nums.\n 2. Recursively build the left subtree on the subarray prefix to the left of the maximum value.\n 3. Recursively build the right subtree on the subarray suffix to the right of the maximum value.\n\nReturn the maximum binary tree built from nums.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/12/24/tree1.jpg]\n\n\nInput: nums = [3,2,1,6,0,5]\nOutput: [6,3,5,null,2,0,null,null,1]\nExplanation: The recursive calls are as follow:\n- The largest value in [3,2,1,6,0,5] is 6. Left prefix is [3,2,1] and right suffix is [0,5].\n    - The largest value in [3,2,1] is 3. Left prefix is [] and right suffix is [2,1].\n        - Empty array, so no child.\n        - The largest value in [2,1] is 2. Left prefix is [] and right suffix is [1].\n            - Empty array, so no child.\n            - Only one element, so child is a node with value 1.\n    - The largest value in [0,5] is 5. Left prefix is [0] and right suffix is [].\n        - Only one element, so child is a node with value 0.\n        - Empty array, so no child.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/12/24/tree2.jpg]\n\n\nInput: nums = [3,2,1]\nOutput: [3,null,2,null,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 1000\n * 0 <= nums[i] <= 1000\n * All integers in nums are unique.",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* constructMaximumBinaryTree(vector<int>& nums) \n{\n        \n    }\n};",
    "solution": [
      "public class Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return construct(nums, 0, nums.length);\n    }\n    public TreeNode construct(int[] nums, int l, int r) {\n        if (l == r)\n            return null;\n        int max_i = max(nums, l, r);\n        TreeNode root = new TreeNode(nums[max_i]);\n        root.left = construct(nums, l, max_i);\n        root.right = construct(nums, max_i + 1, r);\n        return root;\n    }\n    public int max(int[] nums, int l, int r) {\n        int max_i = l;\n        for (int i = l; i < r; i++) {\n            if (nums[max_i] < nums[i])\n                max_i = i;\n        }\n        return max_i;\n    }\n}"
    ]
  },
  {
    "number": 8,
    "question": "Can you solve this real interview question? Robot Return to Origin - There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.\n\nYou are given a string moves that represents the move sequence of the robot where moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up), and 'D' (down).\n\nReturn true if the robot returns to the origin after it finishes all of its moves, or false otherwise.\n\nNote: The way that the robot is \"facing\" is irrelevant. 'R' will always make the robot move to the right once, 'L' will always make it move left, etc. Also, assume that the magnitude of the robot's movement is the same for each move.\n\n \n\nExample 1:\n\n\nInput: moves = \"UD\"\nOutput: true\nExplanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true.\n\n\nExample 2:\n\n\nInput: moves = \"LL\"\nOutput: false\nExplanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves.\n\n\n \n\nConstraints:\n\n * 1 <= moves.length <= 2 * 104\n * moves only contains the characters 'U', 'D', 'L' and 'R'.",
    "code": "class Solution {\npublic:\n    bool judgeCircle(string moves) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public boolean judgeCircle(String moves) {\n        int x = 0, y = 0;\n        for (char move: moves.toCharArray()) {\n            if (move == 'U') y--;\n            else if (move == 'D') y++;\n            else if (move == 'L') x--;\n            else if (move == 'R') x++;\n        }\n        return x == 0 && y == 0;\n    }\n}"
    ]
  },
  {
    "number": 9,
    "question": "Can you solve this real interview question? Image Smoother - An image smoother is a filter of the size 3 x 3 that can be applied to each cell of an image by rounding down the average of the cell and the eight surrounding cells (i.e., the average of the nine cells in the blue smoother). If one or more of the surrounding cells of a cell is not present, we do not consider it in the average (i.e., the average of the four cells in the red smoother).\n\n[https://assets.leetcode.com/uploads/2021/05/03/smoother-grid.jpg]\n\nGiven an m x n integer matrix img representing the grayscale of an image, return the image after applying the smoother on each cell of it.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/05/03/smooth-grid.jpg]\n\n\nInput: img = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: [[0,0,0],[0,0,0],[0,0,0]]\nExplanation:\nFor the points (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0\nFor the points (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0\nFor the point (1,1): floor(8/9) = floor(0.88888889) = 0\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/05/03/smooth2-grid.jpg]\n\n\nInput: img = [[100,200,100],[200,50,200],[100,200,100]]\nOutput: [[137,141,137],[141,138,141],[137,141,137]]\nExplanation:\nFor the points (0,0), (0,2), (2,0), (2,2): floor((100+200+200+50)/4) = floor(137.5) = 137\nFor the points (0,1), (1,0), (1,2), (2,1): floor((200+200+50+200+100+100)/6) = floor(141.666667) = 141\nFor the point (1,1): floor((50+200+200+200+200+100+100+100+100)/9) = floor(138.888889) = 138\n\n\n \n\nConstraints:\n\n * m == img.length\n * n == img[i].length\n * 1 <= m, n <= 200\n * 0 <= img[i][j] <= 255",
    "code": "class Solution {\npublic:\n    vector<vector<int>> imageSmoother(vector<vector<int>>& \nimg) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int[][] imageSmoother(int[][] M) {\n        int R = M.length, C = M[0].length;\n        int[][] ans = new int[R][C];\n\n        for (int r = 0; r < R; ++r)\n            for (int c = 0; c < C; ++c) {\n                int count = 0;\n                for (int nr = r-1; nr <= r+1; ++nr)\n                    for (int nc = c-1; nc <= c+1; ++nc) {\n                        if (0 <= nr && nr < R && 0 <= nc && nc < C) {\n                            ans[r][c] += M[nr][nc];\n                            count++;\n                        }\n                    }\n                ans[r][c] /= count;\n            }\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 10,
    "question": "Can you solve this real interview question? Strange Printer - There is a strange printer with the following two special properties:\n\n * The printer can only print a sequence of the same character each time.\n * At each turn, the printer can print new characters starting from and ending at any place and will cover the original existing characters.\n\nGiven a string s, return the minimum number of turns the printer needed to print it.\n\n \n\nExample 1:\n\n\nInput: s = \"aaabbb\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"bbb\".\n\n\nExample 2:\n\n\nInput: s = \"aba\"\nOutput: 2\nExplanation: Print \"aaa\" first and then print \"b\" from the second place of the string, which will cover the existing character 'a'.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 100\n * s consists of lowercase English letters.",
    "code": "class Solution {\npublic:\n    int strangePrinter(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int strangePrinter(string s) {\n        int n = s.size();\n        vector dp(n, vector<int>(n, -1));\n\n        function<int(int, int)> solve = [&](int left, int right) -> int {\n            if (dp[left][right] != -1) {\n                return dp[left][right];\n            }\n            \n            dp[left][right] = n;\n            int j = -1;\n            \n            for (int i = left; i < right; i++) {\n                if (s[i] != s[right] && j == -1) {\n                    j = i;\n                }\n                \n                if (j != -1) {\n                    dp[left][right] = min(dp[left][right], 1 + solve(j, i) + solve(i + 1, right));\n                }\n            }\n            \n            if (j == -1) {\n                dp[left][right] = 0;\n            }\n            \n            return dp[left][right];\n        };\n\n        return solve(0, n - 1) + 1;\n    }\n};",
      "class Solution {\npublic:\n    int strangePrinter(string s) {\n        int n = s.size();\n        vector dp(n, vector<int>(n, n));\n        for (int length = 1; length <= n; length++) {\n            for (int left = 0; left <= n - length; left++) {\n                int right = left + length - 1;\n                int j = -1;\n                for (int i = left; i < right; i++) {\n                    if (s[i] != s[right] && j == -1) {\n                        j = i;\n                    }\n                    if (j != -1) {\n                        dp[left][right] = min(dp[left][right], 1 + dp[j][i] + dp[i + 1][right]);\n                    }\n                }\n                \n                if (j == -1) {\n                    dp[left][right] = 0;\n                }\n            }\n        }\n        \n        return dp[0][n - 1] + 1;\n    }\n};"
    ]
  },
  {
    "number": 11,
    "question": "Can you solve this real interview question? Beautiful Arrangement II - Given two integers n and k, construct a list answer that contains n different positive integers ranging from 1 to n and obeys the following requirement:\n\n * Suppose this list is answer = [a1, a2, a3, ... , an], then the list [|a1 - a2|, |a2 - a3|, |a3 - a4|, ... , |an-1 - an|] has exactly k distinct integers.\n\nReturn the list answer. If there multiple valid answers, return any of them.\n\n \n\nExample 1:\n\n\nInput: n = 3, k = 1\nOutput: [1,2,3]\nExplanation: The [1,2,3] has three different positive integers ranging from 1 to 3, and the [1,1] has exactly 1 distinct integer: 1\n\n\nExample 2:\n\n\nInput: n = 3, k = 2\nOutput: [1,3,2]\nExplanation: The [1,3,2] has three different positive integers ranging from 1 to 3, and the [2,1] has exactly 2 distinct integers: 1 and 2.\n\n\n \n\nConstraints:\n\n * 1 <= k < n <= 104",
    "code": "class Solution {\npublic:\n    vector<int> constructArray(int n, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    private ArrayList<ArrayList<Integer>> permutations(int[] nums) {\n        ArrayList<ArrayList<Integer>> ans = new ArrayList<ArrayList<Integer>>();\n        permute(ans, nums, 0);\n        return ans;\n    }\n\n    private void permute(ArrayList<ArrayList<Integer>> ans, int[] nums, int start) {\n        if (start >= nums.length) {\n            ArrayList<Integer> cur = new ArrayList<Integer>();\n            for (int x : nums) cur.add(x);\n            ans.add(cur);\n        } else {\n            for (int i = start; i < nums.length; i++) {\n                swap(nums, start, i);\n                permute(ans, nums, start+1);\n                swap(nums, start, i);\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    private int numUniqueDiffs(ArrayList<Integer> arr) {\n        boolean[] seen = new boolean[arr.size()];\n        int ans = 0;\n\n        for (int i = 0; i < arr.size() - 1; i++) {\n            int delta = Math.abs(arr.get(i) - arr.get(i+1));\n            if (!seen[delta]) {\n                ans++;\n                seen[delta] = true;\n            }\n        }\n        return ans;\n    }\n\n    public int[] constructArray(int n, int k) {\n        int[] nums = new int[n];\n        for (int i = 0; i < n; i++) {\n            nums[i] = i+1;\n        }\n        for (ArrayList<Integer> cand : permutations(nums)) {\n            if (numUniqueDiffs(cand) == k) {\n                int[] ans = new int[n];\n                int i = 0;\n                for (int x : cand) ans[i++] = x;\n                return ans;\n            }\n        }\n        return null;\n    }\n}",
      "class Solution {\n    public int[] constructArray(int n, int k) {\n        int[] ans = new int[n];\n        int c = 0;\n        for (int v = 1; v < n-k; v++) {\n            ans[c++] = v;\n        }\n        for (int i = 0; i <= k; i++) {\n            ans[c++] = (i%2 == 0) ? (n-k + i/2) : (n - i/2);\n        }\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 12,
    "question": "Can you solve this real interview question? Kth Smallest Number in Multiplication Table - Nearly everyone has used the Multiplication Table [https://en.wikipedia.org/wiki/Multiplication_table]. The multiplication table of size m x n is an integer matrix mat where mat[i][j] == i * j (1-indexed).\n\nGiven three integers m, n, and k, return the kth smallest element in the m x n multiplication table.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/05/02/multtable1-grid.jpg]\n\n\nInput: m = 3, n = 3, k = 5\nOutput: 3\nExplanation: The 5th smallest number is 3.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/05/02/multtable2-grid.jpg]\n\n\nInput: m = 2, n = 3, k = 6\nOutput: 6\nExplanation: The 6th smallest number is 6.\n\n\n \n\nConstraints:\n\n * 1 <= m, n <= 3 * 104\n * 1 <= k <= m * n",
    "code": "class Solution {\npublic:\n    int findKthNumber(int m, int n, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int findKthNumber(int m, int n, int k) {\n        int[] table = new int[m*n];\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                table[(i - 1) * n + j - 1] = i * j;\n            }\n        }\n        Arrays.sort(table);\n        return table[k-1];\n    }\n}",
      "class Solution {\n    public int findKthNumber(int m, int n, int k) {\n        PriorityQueue<Node> heap = new PriorityQueue<Node>(m,\n            Comparator.<Node> comparingInt(node -> node.val));\n\n        for (int i = 1; i <= m; i++) {\n            heap.offer(new Node(i, i));\n        }\n\n        Node node = null;\n        for (int i = 0; i < k; i++) {\n            node = heap.poll();\n            int nxt = node.val + node.root;\n            if (nxt <= node.root * n) {\n                heap.offer(new Node(nxt, node.root));\n            }\n        }\n        return node.val;\n    }\n}\n\nclass Node {\n    int val;\n    int root;\n    public Node(int v, int r) {\n        val = v;\n        root = r;\n    }\n}",
      "class Solution {\n    public boolean enough(int x, int m, int n, int k) {\n        int count = 0;\n        for (int i = 1; i <= m; i++) {\n            count += Math.min(x / i, n);\n        }\n        return count >= k;\n    }\n\n    public int findKthNumber(int m, int n, int k) {\n        int lo = 1, hi = m * n;\n        while (lo < hi) {\n            int mi = lo + (hi - lo) / 2;\n            if (!enough(mi, m, n, k)) lo = mi + 1;\n            else hi = mi;\n        }\n        return lo;\n    }\n}"
    ]
  },
  {
    "number": 13,
    "question": "Can you solve this real interview question? Second Minimum Node In a Binary Tree - Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node's value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.\n\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes' value in the whole tree.\n\nIf no such second minimum value exists, output -1 instead.\n\n \n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/15/smbt1.jpg]\n\n\nInput: root = [2,2,5,null,null,5,7]\nOutput: 5\nExplanation: The smallest value is 2, the second smallest value is 5.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/10/15/smbt2.jpg]\n\n\nInput: root = [2,2,2]\nOutput: -1\nExplanation: The smallest value is 2, but there isn't any second smallest value.\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 25].\n * 1 <= Node.val <= 231 - 1\n * root.val == min(root.left.val, root.right.val) for each internal node of the tree.",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int findSecondMinimumValue(TreeNode* root) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public void dfs(TreeNode root, Set<Integer> uniques) {\n        if (root != null) {\n            uniques.add(root.val);\n            dfs(root.left, uniques);\n            dfs(root.right, uniques);\n        }\n    }\n    public int findSecondMinimumValue(TreeNode root) {\n        Set<Integer> uniques = new HashSet<Integer>();\n        dfs(root, uniques);\n\n        int min1 = root.val;\n        long ans = Long.MAX_VALUE;\n        for (int v : uniques) {\n            if (min1 < v && v < ans) ans = v;\n        }\n        return ans < Long.MAX_VALUE ? (int) ans : -1;\n    }\n}",
      "class Solution {\n    int min1;\n    long ans = Long.MAX_VALUE;\n\n    public void dfs(TreeNode root) {\n        if (root != null) {\n            if (min1 < root.val && root.val < ans) {\n                ans = root.val;\n            } else if (min1 == root.val) {\n                dfs(root.left);\n                dfs(root.right);\n            }\n        }\n    }\n    public int findSecondMinimumValue(TreeNode root) {\n        min1 = root.val;\n        dfs(root);\n        return ans < Long.MAX_VALUE ? (int) ans : -1;\n    }\n}"
    ]
  },
  {
    "number": 14,
    "question": "Can you solve this real interview question? Number of Longest Increasing Subsequence - Given an integer array nums, return the number of longest increasing subsequences.\n\nNotice that the sequence has to be strictly increasing.\n\n \n\nExample 1:\n\n\nInput: nums = [1,3,5,4,7]\nOutput: 2\nExplanation: The two longest increasing subsequences are [1, 3, 4, 7] and [1, 3, 5, 7].\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2]\nOutput: 5\nExplanation: The length of the longest increasing subsequence is 1, and there are 5 increasing subsequences of length 1, so output 5.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 2000\n * -106 <= nums[i] <= 106",
    "code": "class Solution {\npublic:\n    int findNumberOfLIS(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int findNumberOfLIS(std::vector<int>& nums) {\n        int n = nums.size();\n        vector<int> length(n, 1);\n        vector<int> count(n, 1);\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    if (length[j] + 1 > length[i]) {\n                        length[i] = length[j] + 1;\n                        count[i] = 0;\n                    }\n                    if (length[j] + 1 == length[i]) {\n                        count[i] += count[j];\n                    }\n                }\n            }\n        }\n\n        int maxLength = *max_element(length.begin(), length.end());\n        int result = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (length[i] == maxLength) {\n                result += count[i];\n            }\n        }\n\n        return result;\n    }\n};",
      "class Solution {\npublic:\n    int findNumberOfLIS(std::vector<int>& nums) {\n        int n = nums.size();\n        vector<int> length(n, 0);\n        vector<int> count(n, 0);\n\n        function<void(int)> calculateDP = [&](int i) {\n            if (length[i] != 0)\n                return;\n\n            length[i] = 1;\n            count[i] = 1;\n            for (int j = 0; j < i; j++) {\n                if (nums[j] < nums[i]) {\n                    calculateDP(j);\n                    if (length[j] + 1 > length[i]) {\n                        length[i] = length[j] + 1;\n                        count[i] = 0;\n                    }\n                    if (length[j] + 1 == length[i]) {\n                        count[i] += count[j];\n                    }\n                }\n            }\n        };\n\n\tint maxLength = 0;\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            calculateDP(i);\n            if (length[i] > maxLength)\n                maxLength = length[i];\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (length[i] == maxLength)\n                result += count[i];\n        }\n\n        return result;\n    }\n};"
    ]
  },
  {
    "number": 15,
    "question": "Can you solve this real interview question? Longest Continuous Increasing Subsequence - Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.\n\nA continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].\n\n \n\nExample 1:\n\n\nInput: nums = [1,3,5,4,7]\nOutput: 3\nExplanation: The longest continuous increasing subsequence is [1,3,5] with length 3.\nEven though [1,3,5,7] is an increasing subsequence, it is not continuous as elements 5 and 7 are separated by element\n4.\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2]\nOutput: 1\nExplanation: The longest continuous increasing subsequence is [2] with length 1. Note that it must be strictly\nincreasing.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 104\n * -109 <= nums[i] <= 109",
    "code": "class Solution {\npublic:\n    int findLengthOfLCIS(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        int ans = 0, anchor = 0;\n        for (int i = 0; i < nums.length; ++i) {\n            if (i > 0 && nums[i-1] >= nums[i]) anchor = i;\n            ans = Math.max(ans, i - anchor + 1);\n        }\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 16,
    "question": "Can you solve this real interview question? Map Sum Pairs - Design a map that allows you to do the following:\n\n * Maps a string key to a given value.\n * Returns the sum of the values that have a key with a prefix equal to a given string.\n\nImplement the MapSum class:\n\n * MapSum() Initializes the MapSum object.\n * void insert(String key, int val) Inserts the key-val pair into the map. If the key already existed, the original key-value pair will be overridden to the new one.\n * int sum(string prefix) Returns the sum of all the pairs' value whose key starts with the prefix.\n\n \n\nExample 1:\n\n\nInput\n[\"MapSum\", \"insert\", \"sum\", \"insert\", \"sum\"]\n[[], [\"apple\", 3], [\"ap\"], [\"app\", 2], [\"ap\"]]\nOutput\n[null, null, 3, null, 5]\n\nExplanation\nMapSum mapSum = new MapSum();\nmapSum.insert(\"apple\", 3);  \nmapSum.sum(\"ap\");           // return 3 (apple = 3)\nmapSum.insert(\"app\", 2);    \nmapSum.sum(\"ap\");           // return 5 (apple + app = 3 + 2 = 5)\n\n\n \n\nConstraints:\n\n * 1 <= key.length, prefix.length <= 50\n * key and prefix consist of only lowercase English letters.\n * 1 <= val <= 1000\n * At most 50 calls will be made to insert and sum.",
    "code": "class MapSum {\npublic:\n    MapSum() {\n        \n    }\n    \n    void insert(string key, int val) {\n        \n    }\n    \n    int sum(string prefix) {\n        \n    }\n};\n\n/**\n * Your MapSum object will be instantiated and called as \nsuch:\n * MapSum* obj = new MapSum();\n * obj->insert(key,val);\n * int param_2 = obj->sum(prefix);\n */",
    "solution": [
      "class MapSum {\n    HashMap<String, Integer> map;\n    public MapSum() {\n        map = new HashMap<>();\n    }\n    public void insert(String key, int val) {\n        map.put(key, val);\n    }\n    public int sum(String prefix) {\n        int ans = 0;\n        for (String key: map.keySet()) {\n            if (key.startsWith(prefix)) {\n                ans += map.get(key);\n            }\n        }\n        return ans;\n    }\n}",
      "class MapSum {\n    Map<String, Integer> map;\n    Map<String, Integer> score;\n    public MapSum() {\n        map = new HashMap();\n        score = new HashMap();\n    }\n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        String prefix = \"\";\n        for (char c: key.toCharArray()) {\n            prefix += c;\n            score.put(prefix, score.getOrDefault(prefix, 0) + delta);\n        }\n    }\n    public int sum(String prefix) {\n        return score.getOrDefault(prefix, 0);\n    }\n}",
      "class MapSum {\n    HashMap<String, Integer> map;\n    TrieNode root;\n    public MapSum() {\n        map = new HashMap();\n        root = new TrieNode();\n    }\n    public void insert(String key, int val) {\n        int delta = val - map.getOrDefault(key, 0);\n        map.put(key, val);\n        TrieNode cur = root;\n        cur.score += delta;\n        for (char c: key.toCharArray()) {\n            cur.children.putIfAbsent(c, new TrieNode());\n            cur = cur.children.get(c);\n            cur.score += delta;\n        }\n    }\n    public int sum(String prefix) {\n        TrieNode cur = root;\n        for (char c: prefix.toCharArray()) {\n            cur = cur.children.get(c);\n            if (cur == null) return 0;\n        }\n        return cur.score;\n    }\n}\nclass TrieNode {\n    Map<Character, TrieNode> children = new HashMap();\n    int score;\n}"
    ]
  },
  {
    "number": 17,
    "question": "Can you solve this real interview question? Valid Parenthesis String - Given a string s containing only three types of characters: '(', ')' and '*', return true if s is valid.\n\nThe following rules define a valid string:\n\n * Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n * Any right parenthesis ')' must have a corresponding left parenthesis '('.\n * Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n * '*' could be treated as a single right parenthesis ')' or a single left parenthesis '(' or an empty string \"\".\n\n \n\nExample 1:\n\nInput: s = \"()\"\nOutput: true\n\n\nExample 2:\n\nInput: s = \"(*)\"\nOutput: true\n\n\nExample 3:\n\nInput: s = \"(*))\"\nOutput: true\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 100\n * s[i] is '(', ')' or '*'.",
    "code": "class Solution {\npublic:\n    bool checkValidString(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    boolean ans = false;\n\n    public boolean checkValidString(String s) {\n        solve(new StringBuilder(s), 0);\n        return ans;\n    }\n\n    public void solve(StringBuilder sb, int i) {\n        if (i == sb.length()) {\n            ans |= valid(sb);\n        } else if (sb.charAt(i) == '*') {\n            for (char c: \"() \".toCharArray()) {\n                sb.setCharAt(i, c);\n                solve(sb, i+1);\n                if (ans) return;\n            }\n            sb.setCharAt(i, '*');\n        } else\n            solve(sb, i + 1);\n    }\n\n    public boolean valid(StringBuilder sb) {\n        int bal = 0;\n        for (int i = 0; i < sb.length(); i++) {\n            char c = sb.charAt(i);\n            if (c == '(') bal++;\n            if (c == ')') bal--;\n            if (bal < 0) break;\n        }\n        return bal == 0;\n    }\n}",
      "class Solution {\n    public boolean checkValidString(String s) {\n        int n = s.length();\n        if (n == 0) return true;\n        boolean[][] dp = new boolean[n][n];\n\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == '*') dp[i][i] = true;\n            if (i < n-1 &&\n                    (s.charAt(i) == '(' || s.charAt(i) == '*') &&\n                    (s.charAt(i+1) == ')' || s.charAt(i+1) == '*')) {\n                dp[i][i+1] = true;\n            }\n        }\n\n        for (int size = 2; size < n; size++) {\n            for (int i = 0; i + size < n; i++) {\n                if (s.charAt(i) == '*' && dp[i+1][i+size] == true) {\n                    dp[i][i+size] = true;\n                } else if (s.charAt(i) == '(' || s.charAt(i) == '*') {\n                    for (int k = i+1; k <= i+size; k++) {\n                        if ((s.charAt(k) == ')' || s.charAt(k) == '*') &&\n                                (k == i+1 || dp[i+1][k-1]) &&\n                                (k == i+size || dp[k+1][i+size])) {\n                            dp[i][i+size] = true;\n                        }\n                    }\n                }\n            }\n        }\n        return dp[0][n-1];\n    }\n}",
      "class Solution {\n    public boolean checkValidString(String s) {\n       int lo = 0, hi = 0;\n       for (char c: s.toCharArray()) {\n           lo += c == '(' ? 1 : -1;\n           hi += c != ')' ? 1 : -1;\n           if (hi < 0) break;\n           lo = Math.max(lo, 0);\n       }\n       return lo == 0;\n    }\n}"
    ]
  },
  {
    "number": 18,
    "question": "Can you solve this real interview question? Baseball Game - You are keeping the scores for a baseball game with strange rules. At the beginning of the game, you start with an empty record.\n\nYou are given a list of strings operations, where operations[i] is the ith operation you must apply to the record and is one of the following:\n\n * An integer x.\n   * Record a new score of x.\n * '+'.\n   * Record a new score that is the sum of the previous two scores.\n * 'D'.\n   * Record a new score that is the double of the previous score.\n * 'C'.\n   * Invalidate the previous score, removing it from the record.\n\nReturn the sum of all the scores on the record after applying all the operations.\n\nThe test cases are generated such that the answer and all intermediate calculations fit in a 32-bit integer and that all operations are valid.\n\n \n\nExample 1:\n\n\nInput: ops = [\"5\",\"2\",\"C\",\"D\",\"+\"]\nOutput: 30\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"2\" - Add 2 to the record, record is now [5, 2].\n\"C\" - Invalidate and remove the previous score, record is now [5].\n\"D\" - Add 2 * 5 = 10 to the record, record is now [5, 10].\n\"+\" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].\nThe total sum is 5 + 10 + 15 = 30.\n\n\nExample 2:\n\n\nInput: ops = [\"5\",\"-2\",\"4\",\"C\",\"D\",\"9\",\"+\",\"+\"]\nOutput: 27\nExplanation:\n\"5\" - Add 5 to the record, record is now [5].\n\"-2\" - Add -2 to the record, record is now [5, -2].\n\"4\" - Add 4 to the record, record is now [5, -2, 4].\n\"C\" - Invalidate and remove the previous score, record is now [5, -2].\n\"D\" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].\n\"9\" - Add 9 to the record, record is now [5, -2, -4, 9].\n\"+\" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].\n\"+\" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].\nThe total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.\n\n\nExample 3:\n\n\nInput: ops = [\"1\",\"C\"]\nOutput: 0\nExplanation:\n\"1\" - Add 1 to the record, record is now [1].\n\"C\" - Invalidate and remove the previous score, record is now [].\nSince the record is empty, the total sum is 0.\n\n\n \n\nConstraints:\n\n * 1 <= operations.length <= 1000\n * operations[i] is \"C\", \"D\", \"+\", or a string representing an integer in the range [-3 * 104, 3 * 104].\n * For operation \"+\", there will always be at least two previous scores on the record.\n * For operations \"C\" and \"D\", there will always be at least one previous score on the record.",
    "code": "class Solution {\npublic:\n    int calPoints(vector<string>& operations) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int calPoints(String[] ops) {\n        Stack<Integer> stack = new Stack();\n\n        for(String op : ops) {\n            if (op.equals(\"+\")) {\n                int top = stack.pop();\n                int newtop = top + stack.peek();\n                stack.push(top);\n                stack.push(newtop);\n            } else if (op.equals(\"C\")) {\n                stack.pop();\n            } else if (op.equals(\"D\")) {\n                stack.push(2 * stack.peek());\n            } else {\n                stack.push(Integer.valueOf(op));\n            }\n        }\n\n        int ans = 0;\n        for(int score : stack) ans += score;\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 19,
    "question": "Can you solve this real interview question? Redundant Connection - In this problem, a tree is an undirected graph that is connected and has no cycles.\n\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\n\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/05/02/reduntant1-1-graph.jpg]\n\n\nInput: edges = [[1,2],[1,3],[2,3]]\nOutput: [2,3]\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/05/02/reduntant1-2-graph.jpg]\n\n\nInput: edges = [[1,2],[2,3],[3,4],[1,4],[1,5]]\nOutput: [1,4]\n\n\n \n\nConstraints:\n\n * n == edges.length\n * 3 <= n <= 1000\n * edges[i].length == 2\n * 1 <= ai < bi <= edges.length\n * ai != bi\n * There are no repeated edges.\n * The given graph is connected.",
    "code": "class Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& \nedges) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    Set<Integer> seen = new HashSet();\n    int MAX_EDGE_VAL = 1000;\n\n    public int[] findRedundantConnection(int[][] edges) {\n        ArrayList<Integer>[] graph = new ArrayList[MAX_EDGE_VAL + 1];\n        for (int i = 0; i <= MAX_EDGE_VAL; i++) {\n            graph[i] = new ArrayList();\n        }\n\n        for (int[] edge: edges) {\n            seen.clear();\n            if (!graph[edge[0]].isEmpty() && !graph[edge[1]].isEmpty() &&\n                    dfs(graph, edge[0], edge[1])) {\n                return edge;\n            }\n            graph[edge[0]].add(edge[1]);\n            graph[edge[1]].add(edge[0]);\n        }\n        throw new AssertionError();\n    }\n    public boolean dfs(ArrayList<Integer>[] graph, int source, int target) {\n        if (!seen.contains(source)) {\n            seen.add(source);\n            if (source == target) return true;\n            for (int nei: graph[source]) {\n                if (dfs(graph, nei, target)) return true;\n            }\n        }\n        return false;\n    }\n}",
      "# parent initialized as (x -> x)\nfunction find(x):\n    while parent[x] != x: #While x isn't the leader\n        x = parent[x]\n    return x\n\nfunction union(x, y):\n    parent[find(x)] = find(y)",
      "class DSU(object):\n    def __init__(self):\n        self.par = range(1001)\n        self.rnk = [0] * 1001\n\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n\n    def union(self, x, y):\n        xr, yr = self.find(x), self.find(y)\n        if xr == yr:\n            return False\n        elif self.rnk[xr] < self.rnk[yr]:\n            self.par[xr] = yr\n        elif self.rnk[xr] > self.rnk[yr]:\n            self.par[yr] = xr\n        else:\n            self.par[yr] = xr\n            self.rnk[xr] += 1\n        return True\n\nclass Solution(object):\n    def findRedundantConnection(self, edges):\n        dsu = DSU()\n        for edge in edges:\n            if not dsu.union(*edge):\n                return edge",
      "class DSU:\n    def __init__(self):\n        self.par = range(1001)\n    def find(self, x):\n        if self.par[x] != x:\n            self.par[x] = self.find(self.par[x])\n        return self.par[x]\n    def union(self, x, y):\n        self.par[self.find(x)] = self.find(y)",
      "class Solution {\n    int MAX_EDGE_VAL = 1000;\n\n    public int[] findRedundantConnection(int[][] edges) {\n        DSU dsu = new DSU(MAX_EDGE_VAL + 1);\n        for (int[] edge: edges) {\n            if (!dsu.union(edge[0], edge[1])) return edge;\n        }\n        throw new AssertionError();\n    }\n}\n\nclass DSU {\n    int[] parent;\n    int[] rank;\n\n    public DSU(int size) {\n        parent = new int[size];\n        for (int i = 0; i < size; i++) parent[i] = i;\n        rank = new int[size];\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public boolean union(int x, int y) {\n        int xr = find(x), yr = find(y);\n        if (xr == yr) {\n            return false;\n        } else if (rank[xr] < rank[yr]) {\n            parent[xr] = yr;\n        } else if (rank[xr] > rank[yr]) {\n            parent[yr] = xr;\n        } else {\n            parent[yr] = xr;\n            rank[xr]++;\n        }\n        return true;\n    }\n}"
    ]
  },
  {
    "number": 20,
    "question": "Can you solve this real interview question? Knight Probability in Chessboard - On an n x n chessboard, a knight starts at the cell (row, column) and attempts to make exactly k moves. The rows and columns are 0-indexed, so the top-left cell is (0, 0), and the bottom-right cell is (n - 1, n - 1).\n\nA chess knight has eight possible moves it can make, as illustrated below. Each move is two cells in a cardinal direction, then one cell in an orthogonal direction.\n\n[https://assets.leetcode.com/uploads/2018/10/12/knight.png]\n\nEach time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.\n\nThe knight continues moving until it has made exactly k moves or has moved off the chessboard.\n\nReturn the probability that the knight remains on the board after it has stopped moving.\n\n \n\nExample 1:\n\n\nInput: n = 3, k = 2, row = 0, column = 0\nOutput: 0.06250\nExplanation: There are two moves (to (1,2), (2,1)) that will keep the knight on the board.\nFrom each of those positions, there are also two moves that will keep the knight on the board.\nThe total probability the knight stays on the board is 0.0625.\n\n\nExample 2:\n\n\nInput: n = 1, k = 0, row = 0, column = 0\nOutput: 1.00000\n\n\n \n\nConstraints:\n\n * 1 <= n <= 25\n * 0 <= k <= 100\n * 0 <= row, column <= n - 1",
    "code": "class Solution {\npublic:\n    double knightProbability(int n, int k, int row, int \ncolumn) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    double knightProbability(int n, int k, int row, int column) {\n        // Define possible directions for the knight's moves\n        vector<pair<int, int>> directions = {{1, 2}, {1, -2}, {-1, 2}, {-1, -2},\n                                            {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};\n\n        // Initialize the dynamic programming table\n        vector dp(k + 1, vector (n, vector<double>(n, 0.0)));\n        dp[0][row][column] = 1;\n\n        // Iterate over the number of moves\n        for (int moves = 1; moves <= k; moves++) {\n            // Iterate over the cells on the chessboard\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    // Iterate over possible directions\n                    for (const auto& direction : directions) {\n                        int prevI = i - direction.first;\n                        int prevJ = j - direction.second;\n                        // Check if the previous cell is within the chessboard\n                        if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\n                            // Add the previous probability divided by 8\n                            dp[moves][i][j] += dp[moves - 1][prevI][prevJ] / 8;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Calculate total probability by summing probabilities for all cells\n        double totalProbability = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                totalProbability += dp[k][i][j];\n            }\n        }\n\n        return totalProbability;\n    }\n};",
      "class Solution {\npublic:\n    double knightProbability(int n, int k, int row, int column) {\n        // Define possible directions for the knight's moves\n        vector<pair<int, int>> directions = {\n            {1, 2}, {1, -2}, {-1, 2}, {-1, -2},\n            {2, 1}, {2, -1}, {-2, 1}, {-2, -1}\n        };\n\n        // Initialize the previous and current DP tables\n        vector prevDp(n, vector<double>(n, 0));\n        vector currDp(n, vector<double>(n, 0));\n\n        // Set the probability of the starting cell to 1\n        prevDp[row][column] = 1;\n\n        // Iterate over the number of moves\n        for (int moves = 1; moves <= k; moves++) {\n            // Iterate over the cells on the chessboard\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    currDp[i][j] = 0;\n\n                    // Iterate over possible directions\n                    for (const auto& direction : directions) {\n                        int prevI = i - direction.first;\n                        int prevJ = j - direction.second;\n\n                        // Check if the previous cell is within the chessboard\n                        if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\n                            // Update the probability by adding the previous probability divided by 8\n                            currDp[i][j] += prevDp[prevI][prevJ] / 8;\n                        }\n                    }\n                }\n            }\n\n            // Swap the previous and current DP tables\n            prevDp.swap(currDp);\n        }\n\n        // Calculate the total probability by summing up the probabilities for all cells\n        double totalProbability = 0;\n        for (const auto& row : prevDp) {\n            for (const auto& cell : row) {\n                totalProbability += cell;\n            }\n        }\n\n        // Return the total probability\n        return totalProbability;\n    }\n};",
      "class Solution {\npublic:\n    double knightProbability(int n, int k, int row, int column) {\n        vector<pair<int, int>> directions = {{1, 2}, {1, -2}, {-1, 2}, {-1, -2}, {2, 1}, {2, -1}, {-2, 1}, {-2, -1}};\n        vector dp(k + 1, vector (n, vector<double>(n, -1)));\n\n        function<double(int, int, int)> calculateDP = [&](int moves, int i, int j) -> double {\n            // Base case\n            if (moves == 0) {\n                if (i == row && j == column) {\n                    return 1;\n                } else {\n                    return 0;\n                }\n            }\n\n            // Check if value has already been calculated\n            if (dp[moves][i][j] != -1) {\n                return dp[moves][i][j];\n            }\n\n            dp[moves][i][j] = 0;\n\n            // Iterate over possible directions\n            for (const auto& direction : directions) {\n                int prevI = i - direction.first;\n                int prevJ = j - direction.second;\n\n                // Boundary check\n                if (prevI >= 0 && prevI < n && prevJ >= 0 && prevJ < n) {\n                    dp[moves][i][j] += calculateDP(moves - 1, prevI, prevJ) / 8.0;\n                }\n            }\n\n            return dp[moves][i][j];\n        };\n\n        // Calculate the total probability by summing up the probabilities for all cells\n        double totalProbability = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                totalProbability += calculateDP(k, i, j);\n            }\n        }\n\n        return totalProbability;\n    }\n};"
    ]
  },
  {
    "number": 21,
    "question": "Can you solve this real interview question? Maximum Sum of 3 Non-Overlapping Subarrays - Given an integer array nums and an integer k, find three non-overlapping subarrays of length k with maximum sum and return them.\n\nReturn the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,1,2,6,7,5,1], k = 2\nOutput: [0,3,5]\nExplanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].\nWe could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.\n\n\nExample 2:\n\n\nInput: nums = [1,2,1,2,1,2,1,2,1], k = 2\nOutput: [0,2,4]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 2 * 104\n * 1 <= nums[i] < 216\n * 1 <= k <= floor(nums.length / 3)",
    "code": "class Solution {\npublic:\n    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, \nint k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int[] maxSumOfThreeSubarrays(int[] nums, int k) {\n        // W is an array of sums of windows\n        int[] W = new int[nums.length - k + 1];\n        int currSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            currSum += nums[i];\n            if (i >= k) {\n                currSum -= nums[i - k];\n            }\n            if (i >= k - 1) {\n                W[i - k + 1] = currSum;\n            }\n        }\n\n        int[] left = new int[W.length];\n        int best = 0;\n        for (int i = 0; i < W.length; i++) {\n            if (W[i] > W[best]) best = i;\n            left[i] = best;\n        }\n\n        int[] right = new int[W.length];\n        best = W.length - 1;\n        for (int i = W.length - 1; i >= 0; i--) {\n            if (W[i] >= W[best]) {\n                best = i;\n            }\n            right[i] = best;\n        }\n        \n        int[] ans = new int[]{-1, -1, -1};\n        for (int j = k; j < W.length - k; j++) {\n            int i = left[j - k], l = right[j + k];\n            if (ans[0] == -1 || W[i] + W[j] + W[l] > W[ans[0]] + W[ans[1]] + W[ans[2]]) {\n                ans[0] = i;\n                ans[1] = j;\n                ans[2] = l;\n            }\n        }\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 22,
    "question": "Can you solve this real interview question? Employee Importance - You have a data structure of employee information, including the employee's unique ID, importance value, and direct subordinates' IDs.\n\nYou are given an array of employees employees where:\n\n * employees[i].id is the ID of the ith employee.\n * employees[i].importance is the importance value of the ith employee.\n * employees[i].subordinates is a list of the IDs of the direct subordinates of the ith employee.\n\nGiven an integer id that represents an employee's ID, return the total importance value of this employee and all their direct and indirect subordinates.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/05/31/emp1-tree.jpg]\n\n\nInput: employees = [[1,5,[2,3]],[2,3,[]],[3,3,[]]], id = 1\nOutput: 11\nExplanation: Employee 1 has an importance value of 5 and has two direct subordinates: employee 2 and employee 3.\nThey both have an importance value of 3.\nThus, the total importance value of employee 1 is 5 + 3 + 3 = 11.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/05/31/emp2-tree.jpg]\n\n\nInput: employees = [[1,2,[5]],[5,-3,[]]], id = 5\nOutput: -3\nExplanation: Employee 5 has an importance value of -3 and has no direct subordinates.\nThus, the total importance value of employee 5 is -3.\n\n\n \n\nConstraints:\n\n * 1 <= employees.length <= 2000\n * 1 <= employees[i].id <= 2000\n * All employees[i].id are unique.\n * -100 <= employees[i].importance <= 100\n * One employee has at most one direct leader and may have several subordinates.\n * The IDs in employees[i].subordinates are valid IDs.",
    "code": "/*\n// Definition for Employee.\nclass Employee {\npublic:\n    int id;\n    int importance;\n    vector<int> subordinates;\n};\n*/\n\nclass Solution {\npublic:\n    int getImportance(vector<Employee*> employees, int id) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    Map<Integer, Employee> emap;\n    public int getImportance(List<Employee> employees, int queryid) {\n        emap = new HashMap();\n        for (Employee e: employees) emap.put(e.id, e);\n        return dfs(queryid);\n    }\n    public int dfs(int eid) {\n        Employee employee = emap.get(eid);\n        int ans = employee.importance;\n        for (Integer subid: employee.subordinates)\n            ans += dfs(subid);\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 23,
    "question": "Can you solve this real interview question? Binary Number with Alternating Bits - Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.\n\n \n\nExample 1:\n\n\nInput: n = 5\nOutput: true\nExplanation: The binary representation of 5 is: 101\n\n\nExample 2:\n\n\nInput: n = 7\nOutput: false\nExplanation: The binary representation of 7 is: 111.\n\nExample 3:\n\n\nInput: n = 11\nOutput: false\nExplanation: The binary representation of 11 is: 1011.\n\n \n\nConstraints:\n\n * 1 <= n <= 231 - 1",
    "code": "class Solution {\npublic:\n    bool hasAlternatingBits(int n) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public boolean hasAlternatingBits(int n) {\n        String bits = Integer.toBinaryString(n);\n        for (int i = 0; i < bits.length() - 1; i++) {\n            if (bits.charAt(i) == bits.charAt(i+1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
      "class Solution {\n    public boolean hasAlternatingBits(int n) {\n        int cur = n % 2;\n        n /= 2;\n        while (n > 0) {\n            if (cur == n % 2) return false;\n            cur = n % 2;\n            n /= 2;\n        }\n        return true;\n    }\n}"
    ]
  },
  {
    "number": 24,
    "question": "Can you solve this real interview question? Max Area of Island - You are given an m x n binary matrix grid. An island is a group of 1's (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.\n\nThe area of an island is the number of cells with a value 1 in the island.\n\nReturn the maximum area of an island in grid. If there is no island, return 0.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/05/01/maxarea1-grid.jpg]\n\n\nInput: grid = [[0,0,1,0,0,0,0,1,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,1,1,0,1,0,0,0,0,0,0,0,0],[0,1,0,0,1,1,0,0,1,0,1,0,0],[0,1,0,0,1,1,0,0,1,1,1,0,0],[0,0,0,0,0,0,0,0,0,0,1,0,0],[0,0,0,0,0,0,0,1,1,1,0,0,0],[0,0,0,0,0,0,0,1,1,0,0,0,0]]\nOutput: 6\nExplanation: The answer is not 11, because the island must be connected 4-directionally.\n\n\nExample 2:\n\n\nInput: grid = [[0,0,0,0,0,0,0,0]]\nOutput: 0\n\n\n \n\nConstraints:\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 50\n * grid[i][j] is either 0 or 1.",
    "code": "class Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    int[][] grid;\n    boolean[][] seen;\n\n    public int area(int r, int c) {\n        if (r < 0 || r >= grid.length || c < 0 || c >= grid[0].length ||\n                seen[r][c] || grid[r][c] == 0)\n            return 0;\n        seen[r][c] = true;\n        return (1 + area(r+1, c) + area(r-1, c)\n                  + area(r, c-1) + area(r, c+1));\n    }\n\n    public int maxAreaOfIsland(int[][] grid) {\n        this.grid = grid;\n        seen = new boolean[grid.length][grid[0].length];\n        int ans = 0;\n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                ans = Math.max(ans, area(r, c));\n            }\n        }\n        return ans;\n    }\n}",
      "class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\n        int[] dr = new int[]{1, -1, 0, 0};\n        int[] dc = new int[]{0, 0, 1, -1};\n\n        int ans = 0;\n        for (int r0 = 0; r0 < grid.length; r0++) {\n            for (int c0 = 0; c0 < grid[0].length; c0++) {\n                if (grid[r0][c0] == 1 && !seen[r0][c0]) {\n                    int shape = 0;\n                    Stack<int[]> stack = new Stack();\n                    stack.push(new int[]{r0, c0});\n                    seen[r0][c0] = true;\n                    while (!stack.empty()) {\n                        int[] node = stack.pop();\n                        int r = node[0], c = node[1];\n                        shape++;\n                        for (int k = 0; k < 4; k++) {\n                            int nr = r + dr[k];\n                            int nc = c + dc[k];\n                            if (0 <= nr && nr < grid.length &&\n                                    0 <= nc && nc < grid[0].length &&\n                                    grid[nr][nc] == 1 && !seen[nr][nc]) {\n                                stack.push(new int[]{nr, nc});\n                                seen[nr][nc] = true;\n                            }\n                        }\n                    }\n                    ans = Math.max(ans, shape);\n                }\n            }\n        }\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 25,
    "question": "Can you solve this real interview question? Falling Squares - There are several squares being dropped onto the X-axis of a 2D plane.\n\nYou are given a 2D integer array positions where positions[i] = [lefti, sideLengthi] represents the ith square with a side length of sideLengthi that is dropped with its left edge aligned with X-coordinate lefti.\n\nEach square is dropped one at a time from a height above any landed squares. It then falls downward (negative Y direction) until it either lands on the top side of another square or on the X-axis. A square brushing the left/right side of another square does not count as landing on it. Once it lands, it freezes in place and cannot be moved.\n\nAfter each square is dropped, you must record the height of the current tallest stack of squares.\n\nReturn an integer array ans where ans[i] represents the height described above after dropping the ith square.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/04/28/fallingsq1-plane.jpg]\n\n\nInput: positions = [[1,2],[2,3],[6,1]]\nOutput: [2,5,5]\nExplanation:\nAfter the first drop, the tallest stack is square 1 with a height of 2.\nAfter the second drop, the tallest stack is squares 1 and 2 with a height of 5.\nAfter the third drop, the tallest stack is still squares 1 and 2 with a height of 5.\nThus, we return an answer of [2, 5, 5].\n\n\nExample 2:\n\n\nInput: positions = [[100,100],[200,100]]\nOutput: [100,100]\nExplanation:\nAfter the first drop, the tallest stack is square 1 with a height of 100.\nAfter the second drop, the tallest stack is either square 1 or square 2, both with heights of 100.\nThus, we return an answer of [100, 100].\nNote that square 2 only brushes the right side of square 1, which does not count as landing on it.\n\n\n \n\nConstraints:\n\n * 1 <= positions.length <= 1000\n * 1 <= lefti <= 108\n * 1 <= sideLengthi <= 106",
    "code": "class Solution {\npublic:\n    vector<int> fallingSquares(vector<vector<int>>& \npositions) {\n        \n    }\n};",
    "solution": [
      "Set<Integer> coords = new HashSet();\nfor (int[] pos: positions) {\n    coords.add(pos[0]);\n    coords.add(pos[0] + pos[1] - 1);\n}\nList<Integer> sortedCoords = new ArrayList(coords);\nCollections.sort(sortedCoords);\n\nMap<Integer, Integer> index = new HashMap();\nint t = 0;\nfor (int coord: sortedCoords) index.put(coord, t++);",
      "class Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        int[] qans = new int[positions.length];\n        for (int i = 0; i < positions.length; i++) {\n            int left = positions[i][0];\n            int size = positions[i][1];\n            int right = left + size;\n            qans[i] += size;\n\n            for (int j = i+1; j < positions.length; j++) {\n                int left2 = positions[j][0];\n                int size2 = positions[j][1];\n                int right2 = left2 + size2;\n                if (left2 < right && left < right2) { //intersect\n                    qans[j] = Math.max(qans[j], qans[i]);\n                }\n            }\n        }\n\n        List<Integer> ans = new ArrayList();\n        int cur = -1;\n        for (int x: qans) {\n            cur = Math.max(cur, x);\n            ans.add(cur);\n        }\n        return ans;\n    }\n}",
      "class Solution {\n    int[] heights;\n\n    public int query(int L, int R) {\n        int ans = 0;\n        for (int i = L; i <= R; i++) {\n            ans = Math.max(ans, heights[i]);\n        }\n        return ans;\n    }\n\n    public void update(int L, int R, int h) {\n        for (int i = L; i <= R; i++) {\n            heights[i] = Math.max(heights[i], h);\n        }\n    }\n\n    public List<Integer> fallingSquares(int[][] positions) {\n        //Coordinate Compression\n        //HashMap<Integer, Integer> index = ...;\n        //int t = ...;\n\n        heights = new int[t];\n        int best = 0;\n        List<Integer> ans = new ArrayList();\n\n        for (int[] pos: positions) {\n            int L = index.get(pos[0]);\n            int R = index.get(pos[0] + pos[1] - 1);\n            int h = query(L, R) + pos[1];\n            update(L, R, h);\n            best = Math.max(best, h);\n            ans.add(best);\n        }\n        return ans;\n    }\n}",
      "class Solution {\n    int[] heights;\n    int[] blocks;\n    int[] blocks_read;\n    int B;\n\n    public int query(int left, int right) {\n        int ans = 0;\n        while (left % B > 0 && left <= right) {\n            ans = Math.max(ans, heights[left]);\n            ans = Math.max(ans, blocks[left / B]);\n            left++;\n        }\n        while (right % B != B - 1 && left <= right) {\n            ans = Math.max(ans, heights[right]);\n            ans = Math.max(ans, blocks[right / B]);\n            right--;\n        }\n        while (left <= right) {\n            ans = Math.max(ans, blocks[left / B]);\n            ans = Math.max(ans, blocks_read[left / B]);\n            left += B;\n        }\n        return ans;\n    }\n\n    public void update(int left, int right, int h) {\n        while (left % B > 0 && left <= right) {\n            heights[left] = Math.max(heights[left], h);\n            blocks_read[left / B] = Math.max(blocks_read[left / B], h);\n            left++;\n        }\n        while (right % B != B - 1 && left <= right) {\n            heights[right] = Math.max(heights[right], h);\n            blocks_read[right / B] = Math.max(blocks_read[right / B], h);\n            right--;\n        }\n        while (left <= right) {\n            blocks[left / B] = Math.max(blocks[left / B], h);\n            left += B;\n        }\n    }\n\n    public List<Integer> fallingSquares(int[][] positions) {\n        //Coordinate Compression\n        //HashMap<Integer, Integer> index = ...;\n        //int t = ...;\n\n        heights = new int[t];\n        B = (int) Math.sqrt(t);\n        blocks = new int[B+2];\n        blocks_read = new int[B+2];\n\n        int best = 0;\n        List<Integer> ans = new ArrayList();\n\n        for (int[] pos: positions) {\n            int L = index.get(pos[0]);\n            int R = index.get(pos[0] + pos[1] - 1);\n            int h = query(L, R) + pos[1];\n            update(L, R, h);\n            best = Math.max(best, h);\n            ans.add(best);\n        }\n        return ans;\n    }\n}",
      "class Solution {\n    public List<Integer> fallingSquares(int[][] positions) {\n        //Coordinate Compression\n        //HashMap<Integer, Integer> index = ...;\n\n        SegmentTree tree = new SegmentTree(sortedCoords.size());\n        int best = 0;\n        List<Integer> ans = new ArrayList();\n\n        for (int[] pos: positions) {\n            int L = index.get(pos[0]);\n            int R = index.get(pos[0] + pos[1] - 1);\n            int h = tree.query(L, R) + pos[1];\n            tree.update(L, R, h);\n            best = Math.max(best, h);\n            ans.add(best);\n        }\n        return ans;\n    }\n}\n\nclass SegmentTree {\n    int N, H;\n    int[] tree, lazy;\n\n    SegmentTree(int N) {\n        this.N = N;\n        H = 1;\n        while ((1 << H) < N) H++;\n        tree = new int[2 * N];\n        lazy = new int[N];\n    }\n\n    private void apply(int x, int val) {\n        tree[x] = Math.max(tree[x], val);\n        if (x < N) lazy[x] = Math.max(lazy[x], val);\n    }\n\n    private void pull(int x) {\n        while (x > 1) {\n            x >>= 1;\n            tree[x] = Math.max(tree[x * 2], tree[x * 2 + 1]);\n            tree[x] = Math.max(tree[x], lazy[x]);\n        }\n    }\n\n    private void push(int x) {\n        for (int h = H; h > 0; h--) {\n            int y = x >> h;\n            if (lazy[y] > 0) {\n                apply(y * 2, lazy[y]);\n                apply(y * 2 + 1, lazy[y]);\n                lazy[y] = 0;\n            }\n        }\n    }\n\n    public void update(int L, int R, int h) {\n        L += N; R += N;\n        int L0 = L, R0 = R, ans = 0;\n        while (L <= R) {\n            if ((L & 1) == 1) apply(L++, h);\n            if ((R & 1) == 0) apply(R--, h);\n            L >>= 1; R >>= 1;\n        }\n        pull(L0); pull(R0);\n    }\n\n    public int query(int L, int R) {\n        L += N; R += N;\n        int ans = 0;\n        push(L); push(R);\n        while (L <= R) {\n            if ((L & 1) == 1) ans = Math.max(ans, tree[L++]);\n            if ((R & 1) == 0) ans = Math.max(ans, tree[R--]);\n            L >>= 1; R >>= 1;\n        }\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 26,
    "question": "Can you solve this real interview question? Smallest Integer Divisible by K - Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1.\n\nReturn the length of n. If there is no such n, return -1.\n\nNote: n may not fit in a 64-bit signed integer.\n\n \n\nExample 1:\n\n\nInput: k = 1\nOutput: 1\nExplanation: The smallest answer is n = 1, which has length 1.\n\n\nExample 2:\n\n\nInput: k = 2\nOutput: -1\nExplanation: There is no such positive integer n divisible by 2.\n\n\nExample 3:\n\n\nInput: k = 3\nOutput: 3\nExplanation: The smallest answer is n = 111, which has length 3.\n\n\n \n\nConstraints:\n\n * 1 <= k <= 105",
    "code": "class Solution {\npublic:\n    int smallestRepunitDivByK(int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int smallestRepunitDivByK(int K) {\n        int remainder = 0;\n        for (int length_N = 1; length_N <= K; length_N++) {\n            remainder = (remainder * 10 + 1) % K;\n            if (remainder == 0) {\n                return length_N;\n            }\n        }\n        return -1;\n    }\n}"
    ]
  },
  {
    "number": 27,
    "question": "Can you solve this real interview question? Next Greater Node In Linked List - You are given the head of a linked list with n nodes.\n\nFor each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.\n\nReturn an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext1.jpg]\n\n\nInput: head = [2,1,5]\nOutput: [5,5,0]\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/08/05/linkedlistnext2.jpg]\n\n\nInput: head = [2,7,4,3,5]\nOutput: [7,0,5,5,0]\n\n\n \n\nConstraints:\n\n * The number of nodes in the list is n.\n * 1 <= n <= 104\n * 1 <= Node.val <= 109",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        \n    }\n};",
    "solution": [
      "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        vector<int> values;\n        while (head != nullptr) {\n            values.push_back(head->val);\n            head = head->next;\n        }\n        \n        int n = int(values.size());\n        stack<int> iStack;\n        vector<int> answer(n);\n        \n        for (int i = 0; i < n; ++i) {\n            while (!iStack.empty() && values[iStack.top()] < values[i]) {\n                int smaller = iStack.top();\n                iStack.pop();\n                answer[smaller] = values[i];\n            }\n            iStack.push(i);\n        }\n        \n        return answer;\n    }\n};",
      "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        vector<int> answer;\n        vector<pair<int, int>> stk;\n        // We use an integer 'cnt' to represent the index.\n        int cnt = 0;\n\n        while(head != nullptr){\n            // Set the next greate value of the current value 'head.val' as 0 by default.\n            answer.push_back(0);\n            while(stk.size() && head->val > stk.back().second){\n                auto [id, val] = stk.back();\n                stk.pop_back();\n                answer[id] = head->val;\n            }\n            // Add both the index and the value to stack.\n            stk.push_back({cnt++, head->val});\n            head = head->next;\n        }\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 28,
    "question": "Can you solve this real interview question? Uncrossed Lines - You are given two integer arrays nums1 and nums2. We write the integers of nums1 and nums2 (in the order they are given) on two separate horizontal lines.\n\nWe may draw connecting lines: a straight line connecting two numbers nums1[i] and nums2[j] such that:\n\n * nums1[i] == nums2[j], and\n * the line we draw does not intersect any other connecting (non-horizontal) line.\n\nNote that a connecting line cannot intersect even at the endpoints (i.e., each number can only belong to one connecting line).\n\nReturn the maximum number of connecting lines we can draw in this way.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2019/04/26/142.png]\n\n\nInput: nums1 = [1,4,2], nums2 = [1,2,4]\nOutput: 2\nExplanation: We can draw 2 uncrossed lines as in the diagram.\nWe cannot draw 3 uncrossed lines, because the line from nums1[1] = 4 to nums2[2] = 4 will intersect the line from nums1[2]=2 to nums2[1]=2.\n\n\nExample 2:\n\n\nInput: nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2]\nOutput: 3\n\n\nExample 3:\n\n\nInput: nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1]\nOutput: 2\n\n\n \n\nConstraints:\n\n * 1 <= nums1.length, nums2.length <= 500\n * 1 <= nums1[i], nums2[j] <= 2000",
    "code": "class Solution {\npublic:\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& \nnums2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int solve(int i, int j, vector<int>& nums1, vector<int>& nums2, vector<vector<int>>& memo) {\n        if (i <= 0 || j <= 0) {\n            return 0;\n        }\n\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n\n        if (nums1[i - 1] == nums2[j - 1]) {\n            memo[i][j] = 1 + solve(i - 1, j - 1, nums1, nums2, memo);\n        } else {\n            memo[i][j] =\n                max(solve(i, j - 1, nums1, nums2, memo), solve(i - 1, j, nums1, nums2, memo));\n        }\n        return memo[i][j];\n    }\n\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n        int n1 = nums1.size();\n        int n2 = nums2.size();\n\n        vector<vector<int>> memo(n1 + 1, vector<int>(n2 + 1, -1));\n\n        return solve(n1, n2, nums1, nums2, memo);\n    }\n};",
      "class Solution {\npublic:\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n        int n1 = nums1.size();\n        int n2 = nums2.size();\n\n        vector<vector<int>> dp(n1 + 1, vector<int>(n2 + 1, 0));\n\n        for (int i = 1; i <= n1; i++) {\n            for (int j = 1; j <= n2; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) {\n                    dp[i][j] = 1 + dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = max(dp[i][j - 1], dp[i - 1][j]);\n                }\n            }\n        }\n\n        return dp[n1][n2];\n    }\n};",
      "class Solution {\npublic:\n    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {\n        int n1 = nums1.size();\n        int n2 = nums2.size();\n\n        vector<int> dp(n2 + 1), dpPrev(n2 + 1);\n\n        for (int i = 1; i <= n1; i++) {\n            for (int j = 1; j <= n2; j++) {\n                if (nums1[i - 1] == nums2[j - 1]) {\n                    dp[j] = 1 + dpPrev[j - 1];\n                } else {\n                    dp[j] = max(dp[j - 1], dpPrev[j]);\n                }\n            }\n            dpPrev = dp;\n        }\n\n        return dp[n2];\n    }\n};"
    ]
  },
  {
    "number": 29,
    "question": "Can you solve this real interview question? Find Mode in Binary Search Tree - Given the root of a binary search tree (BST) with duplicates, return all the mode(s) [https://en.wikipedia.org/wiki/Mode_(statistics)] (i.e., the most frequently occurred element) in it.\n\nIf the tree has more than one mode, return them in any order.\n\nAssume a BST is defined as follows:\n\n * The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n * The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n * Both the left and right subtrees must also be binary search trees.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg]\n\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\n\nExample 2:\n\n\nInput: root = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * -105 <= Node.val <= 105\n\n \n\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        dfs(root, counter);\n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, unordered_map<int, int>& counter) {\n        if (node == nullptr) {\n            return;\n        }\n\n        counter[node->val]++;\n        dfs(node->left, counter);\n        dfs(node->right, counter);\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        vector<TreeNode*> stack;\n        stack.push_back(root);\n        \n        while (!stack.empty()) {\n            TreeNode* node = stack.back();\n            stack.pop_back();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                stack.push_back(node->left);\n            }\n            if (node->right != nullptr) {\n                stack.push_back(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        queue<TreeNode*> queue;\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            TreeNode* node = queue.front();\n            queue.pop();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                queue.push(node->left);\n            }\n            if (node->right != nullptr) {\n                queue.push(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        vector<int> values;\n        dfs(root, values);\n        \n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        vector<int> ans;\n        \n        for (int num : values) {\n            if (num == currNum) {\n                currStreak++;\n            } else {\n                currStreak = 1;\n                currNum = num;\n            }\n            \n            if (currStreak > maxStreak) {\n                ans = {};\n                maxStreak = currStreak;\n            }\n            \n            if (currStreak == maxStreak) {\n                ans.push_back(num);\n            }\n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, vector<int>& values) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        // Inorder traversal visits nodes in sorted order\n        dfs(node->left, values);\n        values.push_back(node->val);\n        dfs(node->right, values);\n    }\n};",
      "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n    \n    vector<int> findMode(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n    \n    void dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n\n        dfs(node->left);\n        \n        int num = node->val;\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n\n        \n        dfs(node->right);\n    }\n};",
      "class Solution {\npublic:   \n    vector<int> findMode(TreeNode* root) {\n        vector<int> ans;\n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        \n        TreeNode* curr = root;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                // Find the friend\n                TreeNode* friendNode = curr->left;\n                while (friendNode->right != nullptr) {\n                    friendNode = friendNode->right;\n                }\n                \n                friendNode->right = curr;\n                \n                // Delete the edge after using it\n                TreeNode* left = curr->left;\n                curr->left = nullptr;\n                curr = left;\n            } else {\n                // Handle the current node\n                int num = curr->val;\n                if (num == currNum) {\n                    currStreak++;\n                } else {\n                    currStreak = 1;\n                    currNum = num;\n                }\n\n                if (currStreak > maxStreak) {\n                    ans = {};\n                    maxStreak = currStreak;\n                }\n\n                if (currStreak == maxStreak) {\n                    ans.push_back(num);\n                }\n                \n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n\n    void add(int num) {\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n    }\n    \n    vector<int> findMode(TreeNode* root) {\n        TreeNode* curr = root;\n        TreeNode* friendNode;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                friendNode = curr->left;\n                while (friendNode->right != nullptr && friendNode->right != curr) {\n                    friendNode = friendNode->right;\n                }\n                \n                if (friendNode->right == nullptr) {\n                    friendNode->right = curr;\n                    curr = curr->left;\n                } else {\n                    friendNode->right = nullptr;\n                    add(curr->val);\n                    curr = curr->right;\n                }\n            } else {\n                add(curr->val);\n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 30,
    "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
    "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
    ]
  },
  {
    "number": 31,
    "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
    ]
  },
  {
    "number": 32,
    "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
    "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
    ]
  },
  {
    "number": 33,
    "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
    "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
    ]
  },
  {
    "number": 34,
    "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
    "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
    ]
  },
  {
    "number": 35,
    "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
    "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
    "solution": [
      "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
      "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
    ]
  },
  {
    "number": 36,
    "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
    "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
    "solution": [
      " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
      "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
    ]
  },
  {
    "number": 37,
    "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
    "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
    ]
  },
  {
    "number": 38,
    "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
    "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
    ]
  },
  {
    "number": 39,
    "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
    "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
    ]
  },
  {
    "number": 40,
    "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
    "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
      "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 41,
    "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
    "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
    ]
  },
  {
    "number": 42,
    "question": "Can you solve this real interview question? Maximum Number of Coins You Can Get - There are 3n piles of coins of varying size, you and your friends will take piles of coins as follows:\n\n * In each step, you will choose any 3 piles of coins (not necessarily consecutive).\n * Of your choice, Alice will pick the pile with the maximum number of coins.\n * You will pick the next pile with the maximum number of coins.\n * Your friend Bob will pick the last pile.\n * Repeat until there are no more piles of coins.\n\nGiven an array of integers piles where piles[i] is the number of coins in the ith pile.\n\nReturn the maximum number of coins that you can have.\n\n \n\nExample 1:\n\n\nInput: piles = [2,4,1,2,7,8]\nOutput: 9\nExplanation: Choose the triplet (2, 7, 8), Alice Pick the pile with 8 coins, you the pile with 7 coins and Bob the last one.\nChoose the triplet (1, 2, 4), Alice Pick the pile with 4 coins, you the pile with 2 coins and Bob the last one.\nThe maximum number of coins which you can have are: 7 + 2 = 9.\nOn the other hand if we choose this arrangement (1, 2, 8), (2, 4, 7) you only get 2 + 4 = 6 coins which is not optimal.\n\n\nExample 2:\n\n\nInput: piles = [2,4,5]\nOutput: 4\n\n\nExample 3:\n\n\nInput: piles = [9,8,7,6,5,1,2,3,4]\nOutput: 18\n\n\n \n\nConstraints:\n\n * 3 <= piles.length <= 105\n * piles.length % 3 == 0\n * 1 <= piles[i] <= 104",
    "code": "class Solution {\npublic:\n    int maxCoins(vector<int>& piles) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int maxCoins(vector<int>& piles) {\n        sort(piles.begin(), piles.end());\n        deque<int> queue;\n        for (int num : piles) {\n            queue.push_back(num);\n        }\n        \n        int ans = 0;\n        while (!queue.empty()) {\n            queue.pop_back(); // alice\n            ans += queue.back(); // us\n            queue.pop_back();\n            queue.pop_front(); // bob\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int maxCoins(vector<int>& piles) {\n        sort(piles.begin(), piles.end());\n        int ans = 0;\n        \n        for (int i = piles.size() / 3; i < piles.size(); i += 2) {\n            ans += piles[i];\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 43,
    "question": "Can you solve this real interview question? Number of Ways to Reorder Array to Get Same BST - Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.\n\n * For example, given nums = [2,1,3], we will have 2 as the root, 1 as a left child, and 3 as a right child. The array [2,3,1] also yields the same BST but [3,2,1] yields a different BST.\n\nReturn the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.\n\nSince the answer may be very large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/08/12/bb.png]\n\n\nInput: nums = [2,1,3]\nOutput: 1\nExplanation: We can reorder nums to be [2,3,1] which will yield the same BST. There are no other ways to reorder nums which will yield the same BST.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2020/08/12/ex1.png]\n\n\nInput: nums = [3,4,5,1,2]\nOutput: 5\nExplanation: The following 5 arrays will yield the same BST: \n[3,1,2,4,5]\n[3,1,4,2,5]\n[3,1,4,5,2]\n[3,4,1,2,5]\n[3,4,1,5,2]\n\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2020/08/12/ex4.png]\n\n\nInput: nums = [1,2,3]\nOutput: 0\nExplanation: There are no other orderings of nums that will yield the same BST.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= nums.length\n * All integers in nums are distinct.",
    "code": "class Solution {\npublic:\n    int numOfWays(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int numOfWays(vector<int>& nums) {\n        int m = nums.size();\n        // Table of Pascal's triangle\n        table.resize(m + 1);\n        for(int i = 0; i < m + 1; ++i) {\n            table[i] = vector<long long>(i + 1, 1);\n            for(int j = 1; j < i; ++j) {\n                table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % mod;\n            }\n        }\n        \n        return (dfs(nums) - 1) % mod;\n    }\n    \nprivate:\n    vector<vector<long long>> table;\n    long long mod = 1e9 + 7;\n    \n    long long dfs(vector<int> &nums){\n        int m = nums.size();\n        if(m < 3) {\n            return 1;\n        }\n\n        vector<int> leftNodes, rightNodes;\n        for(int i = 1; i < m; ++i){\n            if (nums[i] < nums[0]) {\n                leftNodes.push_back(nums[i]);\n            } else {\n                rightNodes.push_back(nums[i]);\n            }\n        }\n\t\t\n        long long leftWays = dfs(leftNodes) % mod;\n        long long rightWays = dfs(rightNodes) % mod;\n\t\t\n        return (((leftWays * rightWays) % mod) * table[m - 1][leftNodes.size()]) % mod;\n    }\n};"
    ]
  },
  {
    "number": 44,
    "question": "Can you solve this real interview question? Matrix Diagonal Sum - Given a square matrix mat, return the sum of the matrix diagonals.\n\nOnly include the sum of all the elements on the primary diagonal and all the elements on the secondary diagonal that are not part of the primary diagonal.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/08/14/sample_1911.png]\n\n\nInput: mat = [[1,2,3],\n              [4,5,6],\n              [7,8,9]]\nOutput: 25\nExplanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25\nNotice that element mat[1][1] = 5 is counted only once.\n\n\nExample 2:\n\n\nInput: mat = [[1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1],\n              [1,1,1,1]]\nOutput: 8\n\n\nExample 3:\n\n\nInput: mat = [[5]]\nOutput: 5\n\n\n \n\nConstraints:\n\n * n == mat.length == mat[i].length\n * 1 <= n <= 100\n * 1 <= mat[i][j] <= 100",
    "code": "class Solution {\npublic:\n    int diagonalSum(vector<vector<int>>& mat) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int diagonalSum(vector<vector<int>>& mat) {\n        int n = mat.size();\n        int ans = 0;\n\n        for (int i = 0; i < n; i++) {\n            // Add elements from primary diagonal.\n            ans += mat[i][i];\n            // Addd elements from secondary diagonal.\n            ans += mat[n - 1 - i][i];\n        }\n        // If n is odd, subtract the middle element as its added twice.\n        if (n % 2 != 0) {\n            ans -= mat[n / 2][n / 2];\n        }\n\n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 45,
    "question": "Can you solve this real interview question? Special Positions in a Binary Matrix - Given an m x n binary matrix mat, return the number of special positions in mat.\n\nA position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/12/23/special1.jpg]\n\n\nInput: mat = [[1,0,0],[0,0,1],[1,0,0]]\nOutput: 1\nExplanation: (1, 2) is a special position because mat[1][2] == 1 and all other elements in row 1 and column 2 are 0.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/12/24/special-grid.jpg]\n\n\nInput: mat = [[1,0,0],[0,1,0],[0,0,1]]\nOutput: 3\nExplanation: (0, 0), (1, 1) and (2, 2) are special positions.\n\n\n \n\nConstraints:\n\n * m == mat.length\n * n == mat[i].length\n * 1 <= m, n <= 100\n * mat[i][j] is either 0 or 1.",
    "code": "class Solution {\npublic:\n    int numSpecial(vector<vector<int>>& mat) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int numSpecial(vector<vector<int>>& mat) {\n        int ans = 0;\n        int m = mat.size();\n        int n = mat[0].size();\n        \n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < n; col++) {\n                if (mat[row][col] == 0) {\n                    continue;\n                }\n                \n                bool good = true;\n                for (int r = 0; r < m; r++) {\n                    if (r != row && mat[r][col] == 1) {\n                        good = false;\n                        break;\n                    }\n                }\n                \n                for (int c = 0; c < n; c++) {\n                    if (c != col && mat[row][c] == 1) {\n                        good = false;\n                        break;\n                    }\n                }\n                \n                if (good) {\n                    ans++;\n                }\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int numSpecial(vector<vector<int>>& mat) {\n        int m = mat.size();\n        int n = mat[0].size();\n        vector<int> rowCount(m, 0);\n        vector<int> colCount(n, 0);\n        \n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < n; col++) {\n                if (mat[row][col] == 1) {\n                    rowCount[row]++;\n                    colCount[col]++;\n                }\n            }\n        }\n        \n        int ans = 0;\n        for (int row = 0; row < m; row++) {\n            for (int col = 0; col < n; col++) {\n                if (mat[row][col] == 1) {\n                    if (rowCount[row] == 1 && colCount[col] == 1) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 46,
    "question": "Can you solve this real interview question? Sum of All Odd Length Subarrays - Given an array of positive integers arr, return the sum of all possible odd-length subarrays of arr.\n\nA subarray is a contiguous subsequence of the array.\n\n \n\nExample 1:\n\n\nInput: arr = [1,4,2,5,3]\nOutput: 58\nExplanation: The odd-length subarrays of arr and their sums are:\n[1] = 1\n[4] = 4\n[2] = 2\n[5] = 5\n[3] = 3\n[1,4,2] = 7\n[4,2,5] = 11\n[2,5,3] = 10\n[1,4,2,5,3] = 15\nIf we add all these together we get 1 + 4 + 2 + 5 + 3 + 7 + 11 + 10 + 15 = 58\n\nExample 2:\n\n\nInput: arr = [1,2]\nOutput: 3\nExplanation: There are only 2 subarrays of odd length, [1] and [2]. Their sum is 3.\n\nExample 3:\n\n\nInput: arr = [10,11,12]\nOutput: 66\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 100\n * 1 <= arr[i] <= 1000\n\n \n\nFollow up:\n\nCould you solve this problem in O(n) time complexity?",
    "code": "class Solution {\npublic:\n    int sumOddLengthSubarrays(vector<int>& arr) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int sumOddLengthSubarrays(vector<int>& arr) {\n        int n = int(arr.size()), answer = 0;\n        \n        for (int left = 0; left < n; ++left) {\n            for (int right = left; right < n; ++right) {\n                if ((right - left + 1) % 2 == 1) {\n                    int currentSum = 0;\n                    for (int index = left; index < right + 1; ++index) {\n                        currentSum += arr[index];    \n                    }\n                    answer += currentSum;\n                }\n            }\n        }\n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    int sumOddLengthSubarrays(vector<int>& arr) {\n        int n = int(arr.size()), answer = 0;\n\n        \n        for (int left = 0; left < n; ++left) {\n            int currentSum = 0; \n            for (int right = left; right < n; ++right) {\n                currentSum += arr[right];\n                answer += (right - left + 1) % 2 == 1 ? currentSum : 0;\n            }\n        }\n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    int sumOddLengthSubarrays(vector<int>& arr) {\n        int n = int(arr.size()), answer = 0;\n        \n        for (int i = 0; i < n; ++i) {\n            int left = i, right = n - i - 1;\n            answer += arr[i] * (left / 2 + 1) * (right / 2 + 1);\n            answer += arr[i] * ((left + 1) / 2) * ((right + 1) / 2);\n        }\n        \n        return answer;\n    }\n};"
    ]
  }
]