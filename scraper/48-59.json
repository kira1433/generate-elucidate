[
  {
    "number": 1,
    "question": "Can you solve this real interview question? Find Closest Node to Given Two Nodes - You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\n\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\n\nYou are also given two integers node1 and node2.\n\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\n\nNote that edges may contain cycles.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-2.png]\n\n\nInput: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2022/06/07/graph4drawio-4.png]\n\n\nInput: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n\n \n\nConstraints:\n\n * n == edges.length\n * 2 <= n <= 105\n * -1 <= edges[i] < n\n * edges[i] != i\n * 0 <= node1, node2 < n",
    "code": "class Solution {\npublic:\n    int closestMeetingNode(vector<int>& edges, int node1, \nint node2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    void bfs(int startNode, vector<int>& edges, vector<int>& dist) {\n        int n = edges.size();\n        queue<int> q;\n        q.push(startNode);\n\n        vector<bool> visit(n);\n        dist[startNode] = 0;\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            if (visit[node]) {\n                continue;\n            }\n\n            visit[node] = true;\n            int neighbor = edges[node];\n            if (neighbor != -1 && !visit[neighbor]) {\n                dist[neighbor] = 1 + dist[node];\n                q.push(neighbor);\n            }\n        }\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n = edges.size();\n        vector<int> dist1(n, numeric_limits<int>::max()), dist2(n, numeric_limits<int>::max());\n\n        bfs(node1, edges, dist1);\n        bfs(node2, edges, dist2);\n\n        int minDistNode = -1, minDistTillNow = numeric_limits<int>::max();\n        for (int currNode = 0; currNode < n; currNode++) {\n            if (minDistTillNow > max(dist1[currNode], dist2[currNode])) {\n                minDistNode = currNode;\n                minDistTillNow = max(dist1[currNode], dist2[currNode]);\n            }\n        }\n\n        return minDistNode;\n    }\n};",
      "class Solution {\npublic:\n    void dfs(int node, vector<int>& edges, vector<int>& dist, vector<bool>& visit) {\n        visit[node] = true;\n        int neighbor = edges[node];\n        if (neighbor != -1 && !visit[neighbor]) {\n            dist[neighbor] = 1 + dist[node];\n            dfs(neighbor, edges, dist, visit);\n        }\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n = edges.size();\n        vector<int> dist1(n, numeric_limits<int>::max()), dist2(n, numeric_limits<int>::max());\n        vector<bool> visit1(n), visit2(n);\n        dist1[node1] = 0, dist2[node2] = 0;\n\n        dfs(node1, edges, dist1, visit1);\n        dfs(node2, edges, dist2, visit2);\n\n        int minDistNode = -1, minDistTillNow = numeric_limits<int>::max();\n        for (int currNode = 0; currNode < n; currNode++) {\n            if (minDistTillNow > max(dist1[currNode], dist2[currNode])) {\n                minDistNode = currNode;\n                minDistTillNow = max(dist1[currNode], dist2[currNode]);\n            }\n        }\n\n        return minDistNode;\n    }\n};"
    ]
  },
  {
    "number": 2,
    "question": "Can you solve this real interview question? Minimum Amount of Time to Collect Garbage - You are given a 0-indexed array of strings garbage where garbage[i] represents the assortment of garbage at the ith house. garbage[i] consists only of the characters 'M', 'P' and 'G' representing one unit of metal, paper and glass garbage respectively. Picking up one unit of any type of garbage takes 1 minute.\n\nYou are also given a 0-indexed integer array travel where travel[i] is the number of minutes needed to go from house i to house i + 1.\n\nThere are three garbage trucks in the city, each responsible for picking up one type of garbage. Each garbage truck starts at house 0 and must visit each house in order; however, they do not need to visit every house.\n\nOnly one garbage truck may be used at any given moment. While one truck is driving or picking up garbage, the other two trucks cannot do anything.\n\nReturn the minimum number of minutes needed to pick up all the garbage.\n\n \n\nExample 1:\n\n\nInput: garbage = [\"G\",\"P\",\"GP\",\"GG\"], travel = [2,4,3]\nOutput: 21\nExplanation:\nThe paper garbage truck:\n1. Travels from house 0 to house 1\n2. Collects the paper garbage at house 1\n3. Travels from house 1 to house 2\n4. Collects the paper garbage at house 2\nAltogether, it takes 8 minutes to pick up all the paper garbage.\nThe glass garbage truck:\n1. Collects the glass garbage at house 0\n2. Travels from house 0 to house 1\n3. Travels from house 1 to house 2\n4. Collects the glass garbage at house 2\n5. Travels from house 2 to house 3\n6. Collects the glass garbage at house 3\nAltogether, it takes 13 minutes to pick up all the glass garbage.\nSince there is no metal garbage, we do not need to consider the metal garbage truck.\nTherefore, it takes a total of 8 + 13 = 21 minutes to collect all the garbage.\n\n\nExample 2:\n\n\nInput: garbage = [\"MMM\",\"PGM\",\"GP\"], travel = [3,10]\nOutput: 37\nExplanation:\nThe metal garbage truck takes 7 minutes to pick up all the metal garbage.\nThe paper garbage truck takes 15 minutes to pick up all the paper garbage.\nThe glass garbage truck takes 15 minutes to pick up all the glass garbage.\nIt takes a total of 7 + 15 + 15 = 37 minutes to collect all the garbage.\n\n\n \n\nConstraints:\n\n * 2 <= garbage.length <= 105\n * garbage[i] consists of only the letters 'M', 'P', and 'G'.\n * 1 <= garbage[i].length <= 10\n * travel.length == garbage.length - 1\n * 1 <= travel[i] <= 100",
    "code": "class Solution {\npublic:\n    int garbageCollection(vector<string>& garbage, \nvector<int>& travel) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        // Vector to store the prefix sum in travel.\n        vector<int> prefixSum(travel.size() + 1, 0);\n        prefixSum[1] = travel[0];\n        for (int i = 1; i < travel.size(); i++) {\n            prefixSum[i + 1] = prefixSum[i] + travel[i];\n        }\n        \n        // Map to store garbage type to the last house index.\n        unordered_map<char, int> garbageLastPos;\n\n        // Map to store the total count of each type of garbage in all houses.\n        unordered_map<char, int> garbageCount;\n        for (int i = 0; i < garbage.size(); i++) {\n            for (char c : garbage[i]) {\n                garbageLastPos[c] = i;\n                garbageCount[c]++;\n            }\n        }\n        \n        char garbageTypes[3] = {'M', 'P', 'G'};\n        int ans = 0;\n        for (char c : garbageTypes) {\n            // Add only if there is at least one unit of this garbage.\n            if (garbageCount[c]) {\n                ans += prefixSum[garbageLastPos[c]] + garbageCount[c];\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int garbageCollection(vector<string>& garbage, vector<int>& travel) {\n        // Store the prefix sum in travel itself.\n        for (int i = 1; i < travel.size(); i++) {\n            travel[i] = travel[i - 1] + travel[i];\n        }\n        \n        // Map to store garbage type to the last house index.\n        unordered_map<char, int> garbageLastPos;\n        int ans = 0;\n        for (int i = 0; i < garbage.size(); i++) {\n            for (char c : garbage[i]) {\n                garbageLastPos[c] = i;\n            }\n            ans +=  garbage[i].size();\n        }\n        \n        string garbageTypes = \"MPG\";\n        for (char c : garbageTypes) {\n            // No travel time is required if the last house is at index 0.\n            ans += (garbageLastPos[c] == 0 ? 0 : travel[garbageLastPos[c] - 1]);\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 3,
    "question": "Can you solve this real interview question? Find The Original Array of Prefix Xor - You are given an integer array pref of size n. Find and return the array arr of size n that satisfies:\n\n * pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i].\n\nNote that ^ denotes the bitwise-xor operation.\n\nIt can be proven that the answer is unique.\n\n \n\nExample 1:\n\n\nInput: pref = [5,2,0,3,1]\nOutput: [5,7,2,3,2]\nExplanation: From the array [5,7,2,3,2] we have the following:\n- pref[0] = 5.\n- pref[1] = 5 ^ 7 = 2.\n- pref[2] = 5 ^ 7 ^ 2 = 0.\n- pref[3] = 5 ^ 7 ^ 2 ^ 3 = 3.\n- pref[4] = 5 ^ 7 ^ 2 ^ 3 ^ 2 = 1.\n\n\nExample 2:\n\n\nInput: pref = [13]\nOutput: [13]\nExplanation: We have pref[0] = arr[0] = 13.\n\n\n \n\nConstraints:\n\n * 1 <= pref.length <= 105\n * 0 <= pref[i] <= 106",
    "code": "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        vector<int> arr;\n        arr.push_back(pref[0]);\n        for (int i = 1; i < n; i++) {\n            arr.push_back(pref[i] ^ pref[i - 1]);\n        }\n        \n        return arr;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findArray(vector<int>& pref) {\n        int n = pref.size();\n        \n        for (int i = n - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        \n        return pref;\n    }\n};"
    ]
  },
  {
    "number": 4,
    "question": "Can you solve this real interview question? Minimize Maximum of Array - You are given a 0-indexed array nums comprising of n non-negative integers.\n\nIn one operation, you must:\n\n * Choose an integer i such that 1 <= i < n and nums[i] > 0.\n * Decrease nums[i] by 1.\n * Increase nums[i - 1] by 1.\n\nReturn the minimum possible value of the maximum integer of nums after performing any number of operations.\n\n \n\nExample 1:\n\n\nInput: nums = [3,7,1,6]\nOutput: 5\nExplanation:\nOne set of optimal operations is as follows:\n1. Choose i = 1, and nums becomes [4,6,1,6].\n2. Choose i = 3, and nums becomes [4,6,2,5].\n3. Choose i = 1, and nums becomes [5,5,2,5].\nThe maximum integer of nums is 5. It can be shown that the maximum number cannot be less than 5.\nTherefore, we return 5.\n\n\nExample 2:\n\n\nInput: nums = [10,1]\nOutput: 10\nExplanation:\nIt is optimal to leave nums as is, and since 10 is the maximum value, we return 10.\n\n\n \n\nConstraints:\n\n * n == nums.length\n * 2 <= n <= 105\n * 0 <= nums[i] <= 109",
    "code": "class Solution {\npublic:\n    int minimizeArrayValue(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int minimizeArrayValue(vector<int>& nums) {\n        // Initialize answer and the prefix sum.\n        long long answer = 0, prefixSum = 0;\n        \n        // Iterate over nums, update prefix sum and answer.\n        for (int i = 0; i < nums.size(); ++i) {\n            prefixSum += nums[i];\n            answer = max(answer, (prefixSum + i) / (i + 1));\n        }\n        \n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 5,
    "question": "Can you solve this real interview question? Total Cost to Hire K Workers - You are given a 0-indexed integer array costs where costs[i] is the cost of hiring the ith worker.\n\nYou are also given two integers k and candidates. We want to hire exactly k workers according to the following rules:\n\n * You will run k sessions and hire exactly one worker in each session.\n * In each hiring session, choose the worker with the lowest cost from either the first candidates workers or the last candidates workers. Break the tie by the smallest index.\n   * For example, if costs = [3,2,7,7,1,2] and candidates = 2, then in the first hiring session, we will choose the 4th worker because they have the lowest cost [3,2,7,7,1,2].\n   * In the second hiring session, we will choose 1st worker because they have the same lowest cost as 4th worker but they have the smallest index [3,2,7,7,2]. Please note that the indexing may be changed in the process.\n * If there are fewer than candidates workers remaining, choose the worker with the lowest cost among them. Break the tie by the smallest index.\n * A worker can only be chosen once.\n\nReturn the total cost to hire exactly k workers.\n\n \n\nExample 1:\n\n\nInput: costs = [17,12,10,2,7,2,11,20,8], k = 3, candidates = 4\nOutput: 11\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [17,12,10,2,7,2,11,20,8]. The lowest cost is 2, and we break the tie by the smallest index, which is 3. The total cost = 0 + 2 = 2.\n- In the second hiring round we choose the worker from [17,12,10,7,2,11,20,8]. The lowest cost is 2 (index 4). The total cost = 2 + 2 = 4.\n- In the third hiring round we choose the worker from [17,12,10,7,11,20,8]. The lowest cost is 7 (index 3). The total cost = 4 + 7 = 11. Notice that the worker with index 3 was common in the first and last four workers.\nThe total hiring cost is 11.\n\n\nExample 2:\n\n\nInput: costs = [1,2,4,1], k = 3, candidates = 3\nOutput: 4\nExplanation: We hire 3 workers in total. The total cost is initially 0.\n- In the first hiring round we choose the worker from [1,2,4,1]. The lowest cost is 1, and we break the tie by the smallest index, which is 0. The total cost = 0 + 1 = 1. Notice that workers with index 1 and 2 are common in the first and last 3 workers.\n- In the second hiring round we choose the worker from [2,4,1]. The lowest cost is 1 (index 2). The total cost = 1 + 1 = 2.\n- In the third hiring round there are less than three candidates. We choose the worker from the remaining workers [2,4]. The lowest cost is 2 (index 0). The total cost = 2 + 2 = 4.\nThe total hiring cost is 4.\n\n\n \n\nConstraints:\n\n * 1 <= costs.length <= 105\n * 1 <= costs[i] <= 105\n * 1 <= k, candidates <= costs.length",
    "code": "class Solution {\npublic:\n    long long totalCost(vector<int>& costs, int k, int \ncandidates) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public long totalCost(int[] costs, int k, int candidates) {\n        PriorityQueue<Integer> headWorkers = new PriorityQueue<>();\n        PriorityQueue<Integer> tailWorkers = new PriorityQueue<>();\n        \n        // headWorkers stores the first k workers.\n        // tailWorkers stores at most last k workers without any workers from the first k workers.\n        for (int i = 0; i < candidates; i++) {\n            headWorkers.add(costs[i]);\n        }\n        for (int i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {\n            tailWorkers.add(costs[i]);\n        }\n\n        long answer = 0;\n        int nextHead = candidates;\n        int nextTail = costs.length - 1 - candidates;\n\n        for (int i = 0; i < k; i++) {\n            if (tailWorkers.isEmpty() || !headWorkers.isEmpty() && headWorkers.peek() <= tailWorkers.peek()) {\n                answer += headWorkers.poll();\n                \n                // Only refill the queue if there are workers outside the two queues.\n                if (nextHead <= nextTail) {\n                    headWorkers.add(costs[nextHead]);\n                    nextHead++;\n                }\n            } \n            \n            else {\n                answer += tailWorkers.poll();\n\n                // Only refill the queue if there are workers outside the two queues.\n                if (nextHead <= nextTail) {\n                    tailWorkers.add(costs[nextTail]);\n                    nextTail--;\n                }\n            }\n        }\n\n        return answer;\n    }\n}",
      "class Solution {\n    public long totalCost(int[] costs, int k, int candidates) {\n        // The worker with the lowest cost has the highest priority, if two players has the\n        // same cost, break the tie by their indices (0 or 1).\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> {\n            if (a[0] == b[0]) {\n                return a[1] - b[1];\n            }\n            return a[0] - b[0];});\n        \n        // Add the first k workers with section id of 0 and \n        // the last k workers with section id of 1 (without duplication) to pq.\n        for (int i = 0; i < candidates; i++) {\n            pq.offer(new int[] {costs[i], 0});\n        }\n        for (int i = Math.max(candidates, costs.length - candidates); i < costs.length; i++) {\n            pq.offer(new int[] {costs[i], 1});\n        }\n\n        long answer = 0;\n        int nextHead = candidates;\n        int nextTail = costs.length - 1 - candidates;\n\n        for (int i = 0; i < k; i++) {\n            int[] curWorker = pq.poll();\n            int curCost = curWorker[0], curSectionId = curWorker[1];\n            answer += curCost;\n            \n            // Only refill pq if there are workers outside.\n            if (nextHead <= nextTail) {\n                if (curSectionId == 0) {\n                    pq.offer(new int[]{costs[nextHead], 0});\n                    nextHead++;\n                } else {\n                    pq.offer(new int[]{costs[nextTail], 1});\n                    nextTail--;\n                }\n            }\n        }\n\n        return answer;\n    }\n}"
    ]
  },
  {
    "number": 6,
    "question": "Can you solve this real interview question? Count Ways To Build Good Strings - Given the integers zero, one, low, and high, we can construct a string by starting with an empty string, and then at each step perform either of the following:\n\n * Append the character '0' zero times.\n * Append the character '1' one times.\n\nThis can be performed any number of times.\n\nA good string is a string constructed by the above process having a length between low and high (inclusive).\n\nReturn the number of different good strings that can be constructed satisfying these properties. Since the answer can be large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: low = 3, high = 3, zero = 1, one = 1\nOutput: 8\nExplanation: \nOne possible valid good string is \"011\". \nIt can be constructed as follows: \"\" -> \"0\" -> \"01\" -> \"011\". \nAll binary strings from \"000\" to \"111\" are good strings in this example.\n\n\nExample 2:\n\n\nInput: low = 2, high = 3, zero = 1, one = 2\nOutput: 5\nExplanation: The good strings are \"00\", \"11\", \"000\", \"110\", and \"011\".\n\n\n \n\nConstraints:\n\n * 1 <= low <= high <= 105\n * 1 <= zero, one <= low",
    "code": "class Solution {\npublic:\n    int countGoodStrings(int low, int high, int zero, int \none) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int countGoodStrings(int low, int high, int zero, int one) {\n        // Use dp[i] to record to number of good strings of length i.\n        int[] dp = new int[high + 1];\n        dp[0] = 1;\n        int mod = 1_000_000_007;\n        \n        // Iterate over each length `end`.\n        for (int end = 1; end <= high; ++end) {\n            // check if the current string can be made by append zero `0`s or one `1`s.\n            if (end >= zero) {\n                dp[end] += dp[end - zero];\n            }\n            if (end >= one) {\n                dp[end] += dp[end - one];\n            }\n            dp[end] %= mod;\n        }\n        \n        // Add up the number of strings with each valid length [low ~ high].\n        int answer = 0;\n        for (int i = low; i <= high; ++i) {\n            answer += dp[i];\n            answer %= mod;\n        }\n        return answer;\n    }\n}",
      "class Solution {\n    // Use dp[i] to record to number of good strings of length i.\n    int[] dp;\n    int mod = 1_000_000_007;\n    \n    // Find the number of good strings of length `end`.\n    private int dfs(int end, int zero, int one) {\n        if (dp[end] != -1)\n            return dp[end];\n        int count = 0;\n        if (end >= one) {\n            count += dfs(end - one, zero, one);\n        }\n        if (end >= zero) {\n            count += dfs(end - zero, zero, one);\n        }\n        dp[end] = count % mod;\n        return dp[end];\n    }\n    \n    public int countGoodStrings(int low, int high, int zero, int one) {\n        dp = new int[high + 1];\n        Arrays.fill(dp, -1);\n        dp[0] = 1;\n        \n        // Add up the number of strings with each valid length [low ~ high].\n        int answer = 0;\n        for (int end = low; end <= high; ++end) {\n            answer += dfs(end, zero, one);\n            answer %= mod;\n        }\n        return answer;\n    }\n}"
    ]
  },
  {
    "number": 7,
    "question": "Can you solve this real interview question? Difference Between Ones and Zeros in Row and Column - You are given a 0-indexed m x n binary matrix grid.\n\nA 0-indexed m x n difference matrix diff is created with the following procedure:\n\n * Let the number of ones in the ith row be onesRowi.\n * Let the number of ones in the jth column be onesColj.\n * Let the number of zeros in the ith row be zerosRowi.\n * Let the number of zeros in the jth column be zerosColj.\n * diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\n\nReturn the difference matrix diff.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2022/11/06/image-20221106171729-5.png]\n\n\nInput: grid = [[0,1,1],[1,0,1],[0,0,1]]\nOutput: [[0,0,4],[0,0,4],[-2,-2,2]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2022/11/06/image-20221106171747-6.png]\n\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: [[5,5,5],[5,5,5]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n\n\n \n\nConstraints:\n\n * m == grid.length\n * n == grid[i].length\n * 1 <= m, n <= 105\n * 1 <= m * n <= 105\n * grid[i][j] is either 0 or 1.",
    "code": "class Solution {\npublic:\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& \ngrid) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        vector<int> onesRow(m, 0);\n        vector<int> onesCol(n, 0);\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                onesRow[i] += grid[i][j];\n                onesCol[j] += grid[i][j];\n            }\n        }\n        \n        vector<vector<int>> diff(m, vector<int>(n, 0));\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                diff[i][j] = 2 * onesRow[i] + 2 * onesCol[j] - n - m;\n            }\n        }\n        \n        return diff;\n    }\n};"
    ]
  },
  {
    "number": 8,
    "question": "Can you solve this real interview question? Put Marbles in Bags - You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.\n\nDivide the marbles into the k bags according to the following rules:\n\n * No bag is empty.\n * If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\n * If a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].\n\nThe score after distributing the marbles is the sum of the costs of all the k bags.\n\nReturn the difference between the maximum and minimum scores among marble distributions.\n\n \n\nExample 1:\n\n\nInput: weights = [1,3,5,1], k = 2\nOutput: 4\nExplanation: \nThe distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\n\nExample 2:\n\n\nInput: weights = [1, 3], k = 2\nOutput: 0\nExplanation: The only distribution possible is [1],[3]. \nSince both the maximal and minimal score are the same, we return 0.\n\n\n \n\nConstraints:\n\n * 1 <= k <= weights.length <= 105\n * 1 <= weights[i] <= 109",
    "code": "class Solution {\npublic:\n    long long putMarbles(vector<int>& weights, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    long long putMarbles(vector<int>& weights, int k) {\n        // We collect and sort the value of all n - 1 pairs.\n        int n = weights.size();\n        vector<int> pairWeights(n - 1, 0);\n        for (int i = 0; i < n - 1; ++i) {\n            pairWeights[i] += weights[i] + weights[i + 1];\n        }\n        \n        sort(pairWeights.begin(), pairWeights.end());\n        \n        // Get the difference between the largest k - 1 values and the \n        // smallest k - 1 values.\n        long long answer = 0;\n        for (int i = 0; i < k - 1; ++i) {\n            answer += pairWeights[n - 2 - i] - pairWeights[i];\n        }\n\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 9,
    "question": "Can you solve this real interview question? Minimize the Maximum Difference of Pairs - You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\n\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\n\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.\n\n \n\nExample 1:\n\n\nInput: nums = [10,1,2,7,1,3], p = 2\nOutput: 1\nExplanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. \nThe maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.\n\n\nExample 2:\n\n\nInput: nums = [4,2,1,2], p = 1\nOutput: 0\nExplanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 0 <= nums[i] <= 109\n * 0 <= p <= (nums.length)/2",
    "code": "class Solution {\npublic:\n    int minimizeMax(vector<int>& nums, int p) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    // Find the number of valid pairs by greedy approach\n    int countValidPairs(vector<int>& nums, int threshold) {\n        int index = 0, count = 0;\n        while (index < nums.size() - 1) {\n            // If a valid pair is found, skip both numbers.\n            if (nums[index + 1] - nums[index] <= threshold) {\n                count++;\n                index++;\n            }\n            index++;\n        }\n        return count;\n    }\n\n    int minimizeMax(vector<int>& nums, int p) {\n        sort(nums.begin(), nums.end());\n        int n = nums.size();\n        int left = 0, right = nums[n - 1] - nums[0];\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n\n            // If there are enough pairs, look for a smaller threshold.\n            // Otherwise, look for a larger threshold.\n            if (countValidPairs(nums, mid) >= p) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n};"
    ]
  },
  {
    "number": 10,
    "question": "Can you solve this real interview question? Counter - Given an integer n, return a counter function. This counter function initially returns n and then returns 1 more than the previous value every subsequent time it is called (n, n + 1, n + 2, etc).\n\n \n\nExample 1:\n\n\nInput: \nn = 10 \n[\"call\",\"call\",\"call\"]\nOutput: [10,11,12]\nExplanation: \ncounter() = 10 // The first time counter() is called, it returns n.\ncounter() = 11 // Returns 1 more than the previous time.\ncounter() = 12 // Returns 1 more than the previous time.\n\n\nExample 2:\n\n\nInput: \nn = -2\n[\"call\",\"call\",\"call\",\"call\",\"call\"]\nOutput: [-2,-1,0,1,2]\nExplanation: counter() initially returns -2. Then increases after each sebsequent call.\n\n\n \n\nConstraints:\n\n * -1000 <= n <= 1000\n * 0 <= calls.length <= 1000\n * calls[i] === \"call\"",
    "code": "/**\n * @param {number} n\n * @return {Function} counter\n */\nvar createCounter = function(n) {\n    \n    return function() {\n        \n    };\n};\n\n/** \n * const counter = createCounter(10)\n * counter() // 10\n * counter() // 11\n * counter() // 12\n */",
    "solution": [
      "var createCounter = function(n) {\n  let currentCount = n - 1;\n  return function() {\n    currentCount += 1;\n    return currentCount;      \n  };\n};",
      "var createCounter = function(n) {\n  return function() {\n    return n++;      \n  };\n};",
      "var createCounter = function(n) {\n  --n;\n  return function() {\n    return ++n;      \n  };\n};",
      "var createCounter = function(n) {\n  return () => n++;\n};"
    ]
  },
  {
    "number": 11,
    "question": "Can you solve this real interview question? Snail Traversal - Write code that enhances all arrays such that you can call the snail(rowsCount, colsCount) method that transforms the 1D array into a 2D array organised in the pattern known as snail traversal order. Invalid input values should output an empty array. If rowsCount * colsCount !== nums.length, the input is considered invalid.\n\nSnail traversal order starts at the top left cell with the first value of the current array. It then moves through the entire first column from top to bottom, followed by moving to the next column on the right and traversing it from bottom to top. This pattern continues, alternating the direction of traversal with each column, until the entire current array is covered. For example, when given the input array [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15] with rowsCount = 5 and colsCount = 4, the desired output matrix is shown below. Note that iterating the matrix following the arrows corresponds to the order of numbers in the original array.\n\n \n\nTraversal Diagram [https://assets.leetcode.com/uploads/2023/04/10/screen-shot-2023-04-10-at-100006-pm.png]\n\n \n\nExample 1:\n\n\nInput: \nnums = [19, 10, 3, 7, 9, 8, 5, 2, 1, 17, 16, 14, 12, 18, 6, 13, 11, 20, 4, 15]\nrowsCount = 5\ncolsCount = 4\nOutput: \n[\n [19,17,16,15],\n [10,1,14,4],\n [3,2,12,20],\n [7,5,18,11],\n [9,8,6,13]\n]\n\n\nExample 2:\n\n\nInput: \nnums = [1,2,3,4]\nrowsCount = 1\ncolsCount = 4\nOutput: [[1, 2, 3, 4]]\n\n\nExample 3:\n\n\nInput: \nnums = [1,3]\nrowsCount = 2\ncolsCount = 2\nOutput: []\nExplanation: 2 multiplied by 2 is 4, and the original array [1,3] has a length of 2; therefore, the input is invalid.\n\n\n \n\nConstraints:\n\n * 0 <= nums.length <= 250\n * 1 <= nums[i] <= 1000\n * 1 <= rowsCount <= 250\n * 1 <= colsCount <= 250\n\n ",
    "code": "/**\n * @param {number} rowsCount\n * @param {number} colsCount\n * @return {Array<Array<number>>}\n */\nArray.prototype.snail = function(rowsCount, colsCount) {\n    \n}\n\n/**\n * const arr = [1,2,3,4];\n * arr.snail(1,4); // [[1,2,3,4]]\n */",
    "solution": [
      "Array.prototype.snail = function(rowsCount, colsCount) {\n    if (rowsCount * colsCount !== this.length) return [];\n    const arr = this;\n\n    const res  = new Array(rowsCount).fill(0).map(() => new Array(colsCount).fill(0));\n    let isReversed = false;\n\n    for (let i = 0; i < this.length; i++) {\n        const row = !isReversed ? i % rowsCount : rowsCount - 1 - (i % rowsCount);\n        const col = Math.floor(i / rowsCount);\n\n        res[row][col] = arr[i];\n        \n        if ((i % rowsCount) === rowsCount - 1) {\n            isReversed = !isReversed;\n        }\n    }\n\n    return res;\n}",
      "Array.prototype.snail = function(rowsCount, colsCount) {\n    if (this.length !==  rowsCount * colsCount) return [];\n    \n    let result = Array(rowsCount).fill(null).map(() => new Array(colsCount).fill(null));\n    \n    for (let j = 0; j < this.length; j++) {\n        const i = Math.floor(j / rowsCount);\n        \n        if (i % 2 === 0) {\n            result[j % rowsCount][i] = this[j];\n            continue;\n        }\n        \n        result[rowsCount - j % rowsCount - 1][i] = this[j];\n    }\n    return result;\n}\n",
      "Array.prototype.snail = function(rowsCount, colsCount) {\n  if(rowsCount * colsCount !== this.length) return [];\n\n  const res = new Array(rowsCount).fill(null).map(el => new Array(colsCount).fill(null))\n\n  for (let currRow = 0; currRow < rowsCount; currRow++) {\n    for (let currCol = 0; currCol < colsCount; currCol++) {\n      if (currCol % 2 === 0) {\n        res[currRow][currCol] = this[rowsCount * currCol + currRow]\n        continue\n      }\n\n      if (currCol % 2 !== 0) {\n        res[currRow][currCol] = this[rowsCount * currCol + rowsCount - 1 - currRow]\n      }\n    }\n  }\n\n  return res\n}\n",
      "Array.prototype.snail = function(rowsCount, colsCount) {\n    if (rowsCount * colsCount !== this.length) return [];\n    \n    const res = new Array(rowsCount).fill(null).map(() => new Array(colsCount).fill(null));\n\n    const directions = [[1, 0], [-1, 0]]; // down, up\n    let directionIndex = 0;\n    let row = 0;\n    let col = 0;\n\n    for (let i = 0; i < this.length; i++) {\n        res[row][col] = this[i];\n        let nextRow = row + directions[directionIndex][0];\n        let nextCol = col;\n\n        if (nextRow < 0 || nextRow == rowsCount) {\n            directionIndex = (directionIndex + 1) % 2; // change direction\n            nextRow = row;\n            nextCol = col + 1;\n        }\n\n        row = nextRow;\n        col = nextCol;\n    }\n\n    return res;\n}\n"
    ]
  },
  {
    "number": 12,
    "question": "Can you solve this real interview question? Memoize II - Given a function fn, return a memoized version of that function.\n\nA memoized function is a function that will never be called twice with the same inputs. Instead it will return a cached value.\n\nfn can be any function and there are no constraints on what type of values it accepts. Inputs are considered identical if they are === to each other.\n\n \n\nExample 1:\n\n\nInput: \ngetInputs = () => [[2,2],[2,2],[1,2]]\nfn = function (a, b) { return a + b; }\nOutput: [{\"val\":4,\"calls\":1},{\"val\":4,\"calls\":1},{\"val\":3,\"calls\":2}]\nExplanation:\nconst inputs = getInputs();\nconst memoized = memoize(fn);\nfor (const arr of inputs) {\n  memoized(...arr);\n}\n\nFor the inputs of (2, 2): 2 + 2 = 4, and it required a call to fn().\nFor the inputs of (2, 2): 2 + 2 = 4, but those inputs were seen before so no call to fn() was required.\nFor the inputs of (1, 2): 1 + 2 = 3, and it required another call to fn() for a total of 2.\n\n\nExample 2:\n\n\nInput: \ngetInputs = () => [[{},{}],[{},{}],[{},{}]] \nfn = function (a, b) { return ({...a, ...b}); }\nOutput: [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":2},{\"val\":{},\"calls\":3}]\nExplanation:\nMerging two empty objects will always result in an empty object. It may seem like there should only be 1 call to fn() because of cache-hits, however none of those objects are === to each other.\n\n\nExample 3:\n\n\nInput: \ngetInputs = () => { const o = {}; return [[o,o],[o,o],[o,o]]; }\nfn = function (a, b) { return ({...a, ...b}); }\nOutput: [{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1},{\"val\":{},\"calls\":1}]\nExplanation:\nMerging two empty objects will always result in an empty object. The 2nd and 3rd third function calls result in a cache-hit. This is because every object passed in is identical.\n\n\n \n\nConstraints:\n\n * 1 <= inputs.length <= 105\n * 0 <= inputs.flat().length <= 105\n * inputs[i][j] != NaN",
    "code": "/**\n * @param {Function} fn\n * @return {Function}\n */\nfunction memoize(fn) {\n    \n    return function() {\n        \n    }\n}\n\n\n/** \n * let callCount = 0;\n * const memoizedFn = memoize(function (a, b) {\n *   callCount += 1;\n *   return a + b;\n * })\n * memoizedFn(2, 3) // 5\n * memoizedFn(2, 3) // 5\n * console.log(callCount) // 1 \n */",
    "solution": [
      "class LookupTree {\n  map = new Map();\n\n  hasValue = false;\n\n  value = null;\n\n  getValueHelper(path, i) {\n    const key = path[i];\n    if (i >= path.length) {\n      if (this.hasValue) {\n        return { value: this.value, success: true };\n      } else {\n        return { value: undefined, success: false };\n      }\n    } else {\n      if (this.map.has(key)) {\n        return this.map.get(key).getValueHelper(path, i + 1);\n      } else {\n        return { value: undefined, success: false };\n      }\n    }\n  }\n\n  getValue(path) {\n    return this.getValueHelper(path, 0);\n  }\n\n  setValueHelper(path, i, value) {\n    const key = path[i];\n    if (i >= path.length) {\n      this.value = value;\n      this.hasValue = true;\n    } else {\n      if (!this.map.has(key)) {\n        this.map.set(key, new LookupTree());\n      }\n      return this.map.get(key).setValueHelper(path, i + 1, value);\n    }\n  }\n\n  setValue(path, value) {\n    return this.setValueHelper(path, 0, value);\n  }\n}\n\nfunction memoize(func) {\n  const tree = new LookupTree();\n  const newFunction = (...params) => {\n    const cache = tree.getValue(params);\n    if (cache.success) {\n      return cache.value;\n    }\n    const result = func(...params);\n    tree.setValue(params, result);\n    return result;\n  };\n  return newFunction;\n}",
      "type Fn = (...params: any) => any\n\nfunction createKeyGenerator() {\n    let count = 0;\n    const map = new Map<unknown, number>();\n    return function(input: unknown) {\n        if (map.has(input)) return map.get(input);\n        map.set(input, ++count)\n        return count;\n    }\n}\n\nfunction memoize(fn: Fn): Fn {\n    const keyGenerator = createKeyGenerator();\n    const cache = new Map<string, any>();\n    return function(...args) {\n        const numbers = args.map(keyGenerator);\n        const key = numbers.join(',');\n        if (cache.has(key)) return cache.get(key);\n        const result = fn(...args);\n        cache.set(key, result);\n        return result;\n    }\n}"
    ]
  },
  {
    "number": 13,
    "question": "Can you solve this real interview question? Design Graph With Shortest Path Calculator - There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\n\nImplement the Graph class:\n\n * Graph(int n, int[][] edges) initializes the object with n nodes and the given edges.\n * addEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\n * int shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2023/01/11/graph3drawio-2.png]\n\n\nInput\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n\n\n \n\nConstraints:\n\n * 1 <= n <= 100\n * 0 <= edges.length <= n * (n - 1)\n * edges[i].length == edge.length == 3\n * 0 <= fromi, toi, from, to, node1, node2 <= n - 1\n * 1 <= edgeCosti, edgeCost <= 106\n * There are no repeated edges and no self-loops in the graph at any point.\n * At most 100 calls will be made for addEdge.\n * At most 100 calls will be made for shortestPath.",
    "code": "class Graph {\npublic:\n    Graph(int n, vector<vector<int>>& edges) {\n        \n    }\n    \n    void addEdge(vector<int> edge) {\n        \n    }\n    \n    int shortestPath(int node1, int node2) {\n        \n    }\n};\n\n/**\n * Your Graph object will be instantiated and called as \nsuch:\n * Graph* obj = new Graph(n, edges);\n * obj->addEdge(edge);\n * int param_2 = obj->shortestPath(node1,node2);\n */",
    "solution": [
      "class Graph {\npublic:\n    vector<vector<pair<int, int>>> adjList;\n    Graph(int n, vector<vector<int>>& edges) {\n        adjList.resize(n);\n        for (auto& e: edges)\n            adjList[e[0]].push_back(make_pair(e[1], e[2]));\n    }\n\n    void addEdge(vector<int> edge) {\n        adjList[edge[0]].push_back(make_pair(edge[1], edge[2]));\n    }\n\n    int shortestPath(int node1, int node2) {\n        int n = adjList.size();\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\n        vector<int> costForNode(n, INT_MAX);\n        costForNode[node1] = 0;\n        pq.push({0, node1});\n\n        while (!pq.empty()) {\n            int currCost = pq.top()[0];\n            int currNode = pq.top()[1];\n            pq.pop();\n\n            if (currCost > costForNode[currNode]) {\n                continue;\n            }\n            if (currNode == node2) {\n                return currCost;\n            }\n            for (auto& neighbor : adjList[currNode]) {\n                int neighborNode = neighbor.first;\n                int cost = neighbor.second;\n                int newCost = currCost + cost;\n\n                if (newCost < costForNode[neighborNode]) {\n                    costForNode[neighborNode] = newCost;\n                    pq.push({newCost, neighborNode});\n                }\n            }\n        }\n        return -1;\n    }\n};",
      "class Graph {\npublic:\n    vector<vector<int>> adjMatrix;\n    Graph(int n, vector<vector<int>>& edges) {\n        adjMatrix = vector<vector<int>>(n, vector<int>(n, 1e9));\n        for (auto &e : edges)\n            adjMatrix[e[0]][e[1]] = e[2];\n        for (int i = 0; i < n; ++i)\n            adjMatrix[i][i] = 0;\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                for (int k = 0; k < n; k++)\n                    adjMatrix[j][k] = min(adjMatrix[j][k],\n                                           adjMatrix[j][i] + adjMatrix[i][k]);\n    }\n    \n    void addEdge(vector<int> edge) {\n        int n = adjMatrix.size();\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < n; j++)\n                adjMatrix[i][j] = min(adjMatrix[i][j], \n                                       adjMatrix[i][edge[0]] +\n                                       adjMatrix[edge[1]][j] +\n                                       edge[2]);\n    }\n    \n    int shortestPath(int node1, int node2) {\n        if (adjMatrix[node1][node2] == 1e9) \n            return -1;\n        return adjMatrix[node1][node2];\n    }\n};"
    ]
  },
  {
    "number": 14,
    "question": "Can you solve this real interview question? Generate Fibonacci Sequence - Write a generator function that returns a generator object which yields the fibonacci sequence.\n\nThe fibonacci sequence is defined by the relation Xn = Xn-1 + Xn-2.\n\nThe first few numbers of the series are 0, 1, 1, 2, 3, 5, 8, 13.\n\n \n\nExample 1:\n\n\nInput: callCount = 5\nOutput: [0,1,1,2,3]\nExplanation:\nconst gen = fibGenerator();\ngen.next().value; // 0\ngen.next().value; // 1\ngen.next().value; // 1\ngen.next().value; // 2\ngen.next().value; // 3\n\n\nExample 2:\n\n\nInput: callCount = 0\nOutput: []\nExplanation: gen.next() is never called so nothing is outputted\n\n\n \n\nConstraints:\n\n * 0 <= callCount <= 50",
    "code": "/**\n * @return {Generator<number>}\n */\nvar fibGenerator = function*() {\n    \n};\n\n/**\n * const gen = fibGenerator();\n * gen.next().value; // 0\n * gen.next().value; // 1\n */",
    "solution": [
      "var fibGenerator = function*() {\n    let prev1 = 0;\n    let prev2 = 1;\n\n    while(true) {\n        yield prev1;\n        const temp = prev1;\n        prev1 = prev2;\n        prev2 += temp;\n    }\n};\n",
      "var fibGenerator = function*() {\n    let a = 0;\n    let b = 1;\n\n    while (true){\n        yield a;\n        [a,b] = [b, a+b];\n    }\n};\n",
      "var fibGenerator = function*() {\n    let a=0;\n    let b=1;\n    // yield the first two numbers separately\n    yield a;\n    yield b;\n\n    // continue to yield subsequent numbers of the sequence\n    while(true){\n        let c= a+b;\n        yield c;\n        a=b;\n        b=c;\n    }\n};",
      "var fibGenerator = function*(a = 0, b=1) {\n    // yield the first number\n    yield a;\n\n    // recursively call fibGenerator and yield the entire generator function\n    yield* fibGenerator(b, a+b);\n};\n",
      "var fibGenerator = function() {\n    // Determine the number of Fibonacci numbers to generate\n    const lengthOfSequence = 50;\n\n    const fibonacciSequence = Array(lengthOfSequence).fill(0);\n\n    fibonacciSequence[1] = 1;\n\n    for (let i = 2; i < fibonacciSequence.length; i++) {\n        fibonacciSequence[i] = fibonacciSequence[i - 1] + fibonacciSequence[i - 2];\n    }\n\n    // Return an iterator for the array\n    return fibonacciSequence[Symbol.iterator]();\n};\n"
    ]
  },
  {
    "number": 15,
    "question": "Can you solve this real interview question? Create Hello World Function - Write a function createHelloWorld. It should return a new function that always returns \"Hello World\".\n\n \n\nExample 1:\n\n\nInput: args = []\nOutput: \"Hello World\"\nExplanation:\nconst f = createHelloWorld();\nf(); // \"Hello World\"\n\nThe function returned by createHelloWorld should always return \"Hello World\".\n\n\nExample 2:\n\n\nInput: args = [{},null,42]\nOutput: \"Hello World\"\nExplanation:\nconst f = createHelloWorld();\nf({}, null, 42); // \"Hello World\"\n\nAny arguments could be passed to the function but it should still always return \"Hello World\".\n\n\n \n\nConstraints:\n\n * 0 <= args.length <= 10",
    "code": "/**\n * @return {Function}\n */\nvar createHelloWorld = function() {\n    \n    return function(...args) {\n        \n    }\n};\n\n/**\n * const f = createHelloWorld();\n * f(); // \"Hello World\"\n */",
    "solution": [
      "var createHelloWorld = function() {\n    return function() {\n        return \"Hello World\";\n    }\n};",
      "var createHelloWorld = function() {\n    return () => \"Hello World\";\n};",
      "var createHelloWorld = function() {\n    return (...args) => \"Hello World\";\n};"
    ]
  },
  {
    "number": 16,
    "question": "Can you solve this real interview question? Call Function with Custom Context - Enhance all functions to have the callPolyfill method. The method accepts an object obj as it's first parameter and any number of additional arguments. The obj becomes the this context for the function. The additional arguments are passed to the function (that the callPolyfill method belongs on).\n\nFor example if you had the function:\n\n\nfunction tax(price, taxRate) {\n  const totalCost = price * (1 + taxRate);\n  console.log(`The cost of ${this.item} is ${totalCost}`);\n}\n\n\nCalling this function like tax(10, 0.1) will log \"The cost of undefined is 11\". This is because the this context was not defined.\n\nHowever, calling the function like tax.callPolyfill({item: \"salad\"}, 10, 0.1) will log \"The cost of salad is 11\". The this context was appropriately set, and the function logged an appropriate output.\n\nPlease solve this without using the built-in Function.call method.\n\n \n\nExample 1:\n\n\nInput:\nfn = function add(b) {\n  return this.a + b;\n}\nargs = [{\"a\": 5}, 7]\nOutput: 12\nExplanation:\nfn.callPolyfill({\"a\": 5}, 7); // 12\ncallPolyfill sets the \"this\" context to {\"a\": 5}. 7 is passed as an argument.\n\n\nExample 2:\n\n\nInput: \nfn = function tax(price, taxRate) { \n return `The cost of the ${this.item} is ${price * taxRate}`; \n}\nargs = [{\"item\": \"burger\"}, 10, 1.1]\nOutput: \"The cost of the burger is 11\"\nExplanation: callPolyfill sets the \"this\" context to {\"item\": \"burger\"}. 10 and 1.1 are passed as additional arguments.\n\n\n \n\nConstraints:\n\n * typeof args[0] == 'object' and args[0] != null\n * 1 <= args.length <= 100\n * 2 <= JSON.stringify(args[0]).length <= 105",
    "code": "/**\n * @param {Object} context\n * @param {Array} args\n * @return {null|boolean|number|string|Array|Object}\n */\nFunction.prototype.callPolyfill = function(context, ...\nargs) {\n    \n}\n\n/**\n * function increment() { this.count++; return this.count; }\n * increment.callPolyfill({count: 1}); // 2\n */",
    "solution": [
      "function Person(name, age) {\nthis.name = name;\nthis.age = age;\n}\n\nPerson.prototype.greet = function() {\n  console.log(`Hello, my name is ${this.name} and I'm ${this.age} years old.`);\n};\n\nconst user = new Person('User', 21);\nuser.greet(); // Output: \"Hello, my name is User and I'm 21 years old.\"",
      "function sayHello() {\n  console.log(`Hello, ${this.name}!`);\n}\n\nconst person = { name: 'LeetCode-Users' };\n\n// Using callPolyfill to bind the function to the person object\nsayHello.callPolyfill(person); // Output: \"Hello, LeetCode-Users!\"",
      "const calculator = {\n  calculateTotal: function() {\n      return this.num1 + this.num2;\n  }\n};\n\nconst numbers = {\n  num1: 3, \n  num2: 4\n};\n\n// Using callPolyfill to borrow the calculateTotal method from calculator\nconst sum = calculator.calculateTotal.callPolyfill(numbers);\nconsole.log(sum); // Output: 7",
      "Function.prototype.callPolyfill = function(context, ...args) {\n  Object.defineProperty(context, 'fn', {\n    value: this,\n    enumerable: false,\n  });\n\n  return context.fn(...args);\n}",
      "/**\n * @param {Object} context\n * @param {any[]} args\n * @return {any}\n */\nFunction.prototype.callPolyfill = function (context, ...args) {\n  const uniqueSymbol = Symbol();\n  context[uniqueSymbol] = this;\n  const result = context[uniqueSymbol](...args);\n  delete context[uniqueSymbol];\n\n  return result;\n};\n\n/**\n * function increment() { this.count++; return this.count; }\n * increment.callPolyfill({count: 1}); // 2\n */",
      "/**\n * @param {Object} context\n * @param {any[]} args\n * @return {any}\n */\nFunction.prototype.callPolyfill = function(context, ...args) {\n    return this.bind(context)(...args)\n}\n\n/**\n * function increment() { this.count++; return this.count; }\n * increment.callPolyfill({count: 1}); // 2\n */",
      "/**\n * @param {Object} context\n * @param {any[]} args\n * @return {any}\n */\nFunction.prototype.callPolyfill = function(context, ...args) {\n    return this.apply(context, args);\n}\n\n/**\n * function increment() { this.count++; return this.count; }\n * increment.callPolyfill({count: 1}); // 2\n */"
    ]
  },
  {
    "number": 17,
    "question": "Can you solve this real interview question? Find Mode in Binary Search Tree - Given the root of a binary search tree (BST) with duplicates, return all the mode(s) [https://en.wikipedia.org/wiki/Mode_(statistics)] (i.e., the most frequently occurred element) in it.\n\nIf the tree has more than one mode, return them in any order.\n\nAssume a BST is defined as follows:\n\n * The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n * The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n * Both the left and right subtrees must also be binary search trees.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg]\n\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\n\nExample 2:\n\n\nInput: root = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * -105 <= Node.val <= 105\n\n \n\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        dfs(root, counter);\n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, unordered_map<int, int>& counter) {\n        if (node == nullptr) {\n            return;\n        }\n\n        counter[node->val]++;\n        dfs(node->left, counter);\n        dfs(node->right, counter);\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        vector<TreeNode*> stack;\n        stack.push_back(root);\n        \n        while (!stack.empty()) {\n            TreeNode* node = stack.back();\n            stack.pop_back();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                stack.push_back(node->left);\n            }\n            if (node->right != nullptr) {\n                stack.push_back(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        queue<TreeNode*> queue;\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            TreeNode* node = queue.front();\n            queue.pop();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                queue.push(node->left);\n            }\n            if (node->right != nullptr) {\n                queue.push(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        vector<int> values;\n        dfs(root, values);\n        \n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        vector<int> ans;\n        \n        for (int num : values) {\n            if (num == currNum) {\n                currStreak++;\n            } else {\n                currStreak = 1;\n                currNum = num;\n            }\n            \n            if (currStreak > maxStreak) {\n                ans = {};\n                maxStreak = currStreak;\n            }\n            \n            if (currStreak == maxStreak) {\n                ans.push_back(num);\n            }\n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, vector<int>& values) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        // Inorder traversal visits nodes in sorted order\n        dfs(node->left, values);\n        values.push_back(node->val);\n        dfs(node->right, values);\n    }\n};",
      "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n    \n    vector<int> findMode(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n    \n    void dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n\n        dfs(node->left);\n        \n        int num = node->val;\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n\n        \n        dfs(node->right);\n    }\n};",
      "class Solution {\npublic:   \n    vector<int> findMode(TreeNode* root) {\n        vector<int> ans;\n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        \n        TreeNode* curr = root;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                // Find the friend\n                TreeNode* friendNode = curr->left;\n                while (friendNode->right != nullptr) {\n                    friendNode = friendNode->right;\n                }\n                \n                friendNode->right = curr;\n                \n                // Delete the edge after using it\n                TreeNode* left = curr->left;\n                curr->left = nullptr;\n                curr = left;\n            } else {\n                // Handle the current node\n                int num = curr->val;\n                if (num == currNum) {\n                    currStreak++;\n                } else {\n                    currStreak = 1;\n                    currNum = num;\n                }\n\n                if (currStreak > maxStreak) {\n                    ans = {};\n                    maxStreak = currStreak;\n                }\n\n                if (currStreak == maxStreak) {\n                    ans.push_back(num);\n                }\n                \n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n\n    void add(int num) {\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n    }\n    \n    vector<int> findMode(TreeNode* root) {\n        TreeNode* curr = root;\n        TreeNode* friendNode;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                friendNode = curr->left;\n                while (friendNode->right != nullptr && friendNode->right != curr) {\n                    friendNode = friendNode->right;\n                }\n                \n                if (friendNode->right == nullptr) {\n                    friendNode->right = curr;\n                    curr = curr->left;\n                } else {\n                    friendNode->right = nullptr;\n                    add(curr->val);\n                    curr = curr->right;\n                }\n            } else {\n                add(curr->val);\n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 18,
    "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
    "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
    ]
  },
  {
    "number": 19,
    "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
    ]
  },
  {
    "number": 20,
    "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
    "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
    ]
  },
  {
    "number": 21,
    "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
    "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
    ]
  },
  {
    "number": 22,
    "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
    "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
    ]
  },
  {
    "number": 23,
    "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
    "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
    "solution": [
      "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
      "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
    ]
  },
  {
    "number": 24,
    "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
    "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
    "solution": [
      " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
      "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
    ]
  },
  {
    "number": 25,
    "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
    "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
    ]
  },
  {
    "number": 26,
    "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
    "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
    ]
  },
  {
    "number": 27,
    "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
    "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
    ]
  },
  {
    "number": 28,
    "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
    "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
      "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 29,
    "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
    "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
    ]
  },
  {
    "number": 30,
    "question": "Can you solve this real interview question? Find Mode in Binary Search Tree - Given the root of a binary search tree (BST) with duplicates, return all the mode(s) [https://en.wikipedia.org/wiki/Mode_(statistics)] (i.e., the most frequently occurred element) in it.\n\nIf the tree has more than one mode, return them in any order.\n\nAssume a BST is defined as follows:\n\n * The left subtree of a node contains only nodes with keys less than or equal to the node's key.\n * The right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n * Both the left and right subtrees must also be binary search trees.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/03/11/mode-tree.jpg]\n\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\n\nExample 2:\n\n\nInput: root = [0]\nOutput: [0]\n\n\n \n\nConstraints:\n\n * The number of nodes in the tree is in the range [1, 104].\n * -105 <= Node.val <= 105\n\n \n\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
    "code": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right\n(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : \nval(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        dfs(root, counter);\n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, unordered_map<int, int>& counter) {\n        if (node == nullptr) {\n            return;\n        }\n\n        counter[node->val]++;\n        dfs(node->left, counter);\n        dfs(node->right, counter);\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        vector<TreeNode*> stack;\n        stack.push_back(root);\n        \n        while (!stack.empty()) {\n            TreeNode* node = stack.back();\n            stack.pop_back();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                stack.push_back(node->left);\n            }\n            if (node->right != nullptr) {\n                stack.push_back(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        unordered_map<int, int> counter;\n        queue<TreeNode*> queue;\n        queue.push(root);\n        \n        while (!queue.empty()) {\n            TreeNode* node = queue.front();\n            queue.pop();\n\n            counter[node->val]++;\n            if (node->left != nullptr) {\n                queue.push(node->left);\n            }\n            if (node->right != nullptr) {\n                queue.push(node->right);\n            }\n        }\n        \n        int maxFreq = 0;\n        for (auto& [key, val] : counter) {\n            maxFreq = max(maxFreq, val);\n        }\n        \n        vector<int> ans;\n        for (auto& [key, val] : counter) {\n            if (val == maxFreq) {\n                ans.push_back(key);\n            } \n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> findMode(TreeNode* root) {\n        vector<int> values;\n        dfs(root, values);\n        \n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        vector<int> ans;\n        \n        for (int num : values) {\n            if (num == currNum) {\n                currStreak++;\n            } else {\n                currStreak = 1;\n                currNum = num;\n            }\n            \n            if (currStreak > maxStreak) {\n                ans = {};\n                maxStreak = currStreak;\n            }\n            \n            if (currStreak == maxStreak) {\n                ans.push_back(num);\n            }\n        }\n        \n        return ans;\n    }\n    \n    void dfs(TreeNode* node, vector<int>& values) {\n        if (node == nullptr) {\n            return;\n        }\n        \n        // Inorder traversal visits nodes in sorted order\n        dfs(node->left, values);\n        values.push_back(node->val);\n        dfs(node->right, values);\n    }\n};",
      "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n    \n    vector<int> findMode(TreeNode* root) {\n        dfs(root);\n        return ans;\n    }\n    \n    void dfs(TreeNode* node) {\n        if (node == nullptr) {\n            return;\n        }\n\n        dfs(node->left);\n        \n        int num = node->val;\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n\n        \n        dfs(node->right);\n    }\n};",
      "class Solution {\npublic:   \n    vector<int> findMode(TreeNode* root) {\n        vector<int> ans;\n        int maxStreak = 0;\n        int currStreak = 0;\n        int currNum = 0;\n        \n        TreeNode* curr = root;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                // Find the friend\n                TreeNode* friendNode = curr->left;\n                while (friendNode->right != nullptr) {\n                    friendNode = friendNode->right;\n                }\n                \n                friendNode->right = curr;\n                \n                // Delete the edge after using it\n                TreeNode* left = curr->left;\n                curr->left = nullptr;\n                curr = left;\n            } else {\n                // Handle the current node\n                int num = curr->val;\n                if (num == currNum) {\n                    currStreak++;\n                } else {\n                    currStreak = 1;\n                    currNum = num;\n                }\n\n                if (currStreak > maxStreak) {\n                    ans = {};\n                    maxStreak = currStreak;\n                }\n\n                if (currStreak == maxStreak) {\n                    ans.push_back(num);\n                }\n                \n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    vector<int> ans;\n    int maxStreak = 0;\n    int currStreak = 0;\n    int currNum = 0;\n\n    void add(int num) {\n        if (num == currNum) {\n            currStreak++;\n        } else {\n            currStreak = 1;\n            currNum = num;\n        }\n\n        if (currStreak > maxStreak) {\n            ans = {};\n            maxStreak = currStreak;\n        }\n\n        if (currStreak == maxStreak) {\n            ans.push_back(num);\n        }\n    }\n    \n    vector<int> findMode(TreeNode* root) {\n        TreeNode* curr = root;\n        TreeNode* friendNode;\n        while (curr != nullptr) {\n            if (curr->left != nullptr) {\n                friendNode = curr->left;\n                while (friendNode->right != nullptr && friendNode->right != curr) {\n                    friendNode = friendNode->right;\n                }\n                \n                if (friendNode->right == nullptr) {\n                    friendNode->right = curr;\n                    curr = curr->left;\n                } else {\n                    friendNode->right = nullptr;\n                    add(curr->val);\n                    curr = curr->right;\n                }\n            } else {\n                add(curr->val);\n                curr = curr->right;\n            }\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 31,
    "question": "Can you solve this real interview question? Two Sum - Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\n\nYou can return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\n\nExample 2:\n\n\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\n\nExample 3:\n\n\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n\n\n \n\nConstraints:\n\n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n\n \n\nFollow-up: Can you come up with an algorithm that is less than O(n2) time complexity?",
    "code": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        for (int i = 0; i < nums.length; i++) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[j] == target - nums[i]) {\n                    return new int[] { i, j };\n                }\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            map.put(nums[i], i);\n        }\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement) && map.get(complement) != i) {\n                return new int[] { i, map.get(complement) };\n            }\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}",
      "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (map.containsKey(complement)) {\n                return new int[] { map.get(complement), i };\n            }\n            map.put(nums[i], i);\n        }\n        // In case there is no solution, we'll just return null\n        return null;\n    }\n}"
    ]
  },
  {
    "number": 32,
    "question": "Can you solve this real interview question? Add Two Numbers - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\n\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2020/10/02/addtwonumber1.jpg]\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\n\n\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n\n\nExample 3:\n\n\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n\n\n \n\nConstraints:\n\n * The number of nodes in each linked list is in the range [1, 100].\n * 0 <= Node.val <= 9\n * It is guaranteed that the list represents a number that does not have leading zeros.",
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) \n{}\n * };\n */\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummyHead = new ListNode(0);\n        ListNode* curr = dummyHead;\n        int carry = 0;\n        while (l1 != NULL || l2 != NULL || carry != 0) {\n            int x = l1 ? l1->val : 0;\n            int y = l2 ? l2->val : 0;\n            int sum = carry + x + y;\n            carry = sum / 10;\n            curr->next = new ListNode(sum % 10);\n            curr = curr->next;\n            l1 = l1 ? l1->next : nullptr;\n            l2 = l2 ? l2->next : nullptr;\n        }\n        return dummyHead->next;\n    }\n};"
    ]
  },
  {
    "number": 33,
    "question": "Can you solve this real interview question? Median of Two Sorted Arrays - Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n\n\nExample 2:\n\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n\n\n \n\nConstraints:\n\n * nums1.length == m\n * nums2.length == n\n * 0 <= m <= 1000\n * 0 <= n <= 1000\n * 1 <= m + n <= 2000\n * -106 <= nums1[i], nums2[i] <= 106",
    "code": "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, \nvector<int>& nums2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int p1 = 0, p2 = 0;\n\n    // Get the smaller value between nums1[p1] and nums2[p2] and move the pointer forward.\n\n    int getMin(vector<int>& nums1, vector<int>& nums2) {\n        if (p1 < nums1.size() && p2 < nums2.size()) {\n            return nums1[p1] < nums2[p2] ? nums1[p1++] : nums2[p2++];\n        } else if (p1 < nums1.size()) {\n            return nums1[p1++];\n        } else if (p2 < nums2.size()) {\n            return nums2[p2++];\n        } \n        return -1;\n    }\n    \n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        int m = int(nums1.size()), n = int(nums2.size());\n        \n        if ((m + n) % 2 == 0) {\n            for (int i = 0; i < (m + n) / 2 - 1; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return (double)(getMin(nums1, nums2) + getMin(nums1, nums2)) / 2;\n        } else {\n            for (int i = 0; i < (m + n) / 2; ++i) {\n                int _ = getMin(nums1, nums2);\n            }\n            return getMin(nums1, nums2);\n        }\n            \n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& A, vector<int>& B) {\n        int na = int(A.size()), nb = int(B.size());\n        int n = na + nb;\n        if (n % 2) {\n            return solve(A, B, n / 2, 0, na - 1, 0, nb - 1);\n        } else {\n            return 1.0 * (solve(A, B, n/2 - 1, 0, na - 1, 0, nb - 1) + solve(A, B, n/2, 0, na - 1, 0, nb - 1)) / 2;\n        } \n    }\n    int solve(vector<int>& A, vector<int>& B, int k, int aStart, int aEnd, int bStart, int bEnd) {\n        // If the segment of on array is empty, it means we have passed all\n        // its element, just return the corresponding element in the other array.\n        if (aEnd < aStart) {\n            return B[k - aStart];\n        }\n        if (bEnd < bStart) {\n            return A[k - bStart];\n        }\n\n        // Get the middle indexes and middle values of A and B.\n        int aIndex = (aStart + aEnd) / 2, bIndex = (bStart + bEnd) / 2;\n        int aValue = A[aIndex], bValue = B[bIndex];\n        \n        // If k is in the right half of A + B, remove the smaller left half.\n        if (aIndex + bIndex < k) { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aEnd, bIndex + 1, bEnd);\n            } else {\n                return solve(A, B, k, aIndex + 1, aEnd, bStart, bEnd);\n            }\n        } \n        // Otherwise, remove the larger right half.\n        else { \n            if (aValue > bValue) {\n                return solve(A, B, k, aStart, aIndex - 1, bStart, bEnd);\n            } else {\n                return solve(A, B, k, aStart, aEnd, bStart, bIndex - 1);       \n            }\n        }\n        return -1;\n    }\n};",
      "class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        if (nums1.size() > nums2.size()) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n        \n        int m = nums1.size(), n = nums2.size();\n        int left = 0, right = m;\n        \n        while (left <= right) {\n            int partitionA = (left + right) / 2;\n            int partitionB = (m + n + 1) / 2 - partitionA;\n            \n            int maxLeftA = (partitionA == 0) ? INT_MIN : nums1[partitionA - 1];\n            int minRightA = (partitionA == m) ? INT_MAX : nums1[partitionA];\n            int maxLeftB = (partitionB == 0) ? INT_MIN : nums2[partitionB - 1];\n            int minRightB = (partitionB == n) ? INT_MAX : nums2[partitionB];\n            \n            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {\n                if ((m + n) % 2 == 0) {\n                    return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;\n                } else {\n                    return max(maxLeftA, maxLeftB);\n                }\n            } else if (maxLeftA > minRightB) {\n                right = partitionA - 1;\n            } else {\n                left = partitionA + 1;\n            }\n        }\n        \n        return 0.0;\n    }\n};"
    ]
  },
  {
    "number": 34,
    "question": "Can you solve this real interview question? Longest Palindromic Substring - Given a string s, return the longest palindromic substring in s.\n\n \n\nExample 1:\n\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\n\n\nExample 2:\n\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 1000\n * s consist of only digits and English letters.",
    "code": "class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public String longestPalindrome(String s) {\n        for (int length = s.length(); length > 0; length--) {\n            for (int start = 0; start <= s.length() - length; start++) {\n                if (check(start, start + length, s)) {\n                    return s.substring(start, start + length);\n                }\n            }\n        }\n        \n        return \"\";\n    }\n    \n    private boolean check(int i, int j, String s) {\n        int left = i;\n        int right = j - 1;\n        \n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            \n            left++;\n            right--;\n        }\n        \n        return true;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int n = s.length();\n        boolean[][] dp = new boolean[n][n];\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        \n        for (int i = 0; i < n - 1; i++) {\n            if (s.charAt(i) == s.charAt(i + 1)) {\n                dp[i][i + 1] = true;\n                ans[0] = i;\n                ans[1] = i + 1;\n            }\n        }\n        \n        for (int diff = 2; diff < n; diff++) {\n            for (int i = 0; i < n - diff; i++) {\n                int j = i + diff;\n                if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1]) {\n                    dp[i][j] = true;\n                    ans[0] = i;\n                    ans[1] = j;\n                }\n            }\n        }\n        \n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        int[] ans = new int[]{0, 0};\n        \n        for (int i = 0; i < s.length(); i++) {\n            int oddLength = expand(i, i, s);\n            if (oddLength > ans[1] - ans[0] + 1) {\n                int dist = oddLength / 2;\n                ans[0] = i - dist;\n                ans[1] = i + dist;\n            }\n            \n            int evenLength = expand(i, i + 1, s);\n            if (evenLength > ans[1] - ans[0] + 1) {\n                int dist = (evenLength / 2) - 1;\n                ans[0] = i - dist;\n                ans[1] = i + 1 + dist;\n            }\n        }\n\n        int i = ans[0];\n        int j = ans[1];\n        return s.substring(i, j + 1);\n    }\n    \n    private int expand(int i, int j, String s) {\n        int left = i;\n        int right = j;\n        \n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n\n        return right - left - 1;\n    }\n}",
      "class Solution {\n    public String longestPalindrome(String s) {\n        StringBuilder sPrime = new StringBuilder(\"#\");\n        for (char c: s.toCharArray()) {\n            sPrime.append(c).append(\"#\");\n        }\n        \n        int n = sPrime.length();\n        int[] palindromeRadii = new int[n];\n        int center = 0;\n        int radius = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int mirror = 2 * center - i;\n            \n            if (i < radius) {\n                palindromeRadii[i] = Math.min(radius - i, palindromeRadii[mirror]);\n            }\n            \n            while (i + 1 + palindromeRadii[i] < n &&\n                   i - 1 - palindromeRadii[i] >= 0 &&\n                   sPrime.charAt(i + 1 + palindromeRadii[i]) == sPrime.charAt(i - 1 - palindromeRadii[i])) {\n                palindromeRadii[i]++;\n            }\n            \n            if (i + palindromeRadii[i] > radius) {\n                center = i;\n                radius = i + palindromeRadii[i];\n            }\n        }\n        \n        int maxLength = 0;\n        int centerIndex = 0;\n        for (int i = 0; i < n; i++) {\n            if (palindromeRadii[i] > maxLength) {\n                maxLength = palindromeRadii[i];\n                centerIndex = i;\n            }\n        }\n        \n        int startIndex = (centerIndex - maxLength) / 2;\n        String longestPalindrome = s.substring(startIndex, startIndex + maxLength);\n        \n        return longestPalindrome;\n    }\n}"
    ]
  },
  {
    "number": 35,
    "question": "Can you solve this real interview question? Reverse Integer - Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\n\nInput: x = 123\nOutput: 321\n\n\nExample 2:\n\n\nInput: x = -123\nOutput: -321\n\n\nExample 3:\n\n\nInput: x = 120\nOutput: 21\n\n\n \n\nConstraints:\n\n * -231 <= x <= 231 - 1",
    "code": "class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int reverse(int x) {\n        int rev = 0;\n        while (x != 0) {\n            int pop = x % 10;\n            x /= 10;\n            if (rev > INT_MAX/10 || (rev == INT_MAX / 10 && pop > 7)) return 0;\n            if (rev < INT_MIN/10 || (rev == INT_MIN / 10 && pop < -8)) return 0;\n            rev = rev * 10 + pop;\n        }\n        return rev;\n    }\n};"
    ]
  },
  {
    "number": 36,
    "question": "Can you solve this real interview question? Regular Expression Matching - Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n * '.' Matches any single character.\n * '*' Matches zero or more of the preceding element.\n\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 20\n * 1 <= p.length <= 20\n * s contains only lowercase English letters.\n * p contains only lowercase English letters, '.', and '*'.\n * It is guaranteed for each appearance of the character '*', there will be a previous valid character to match.",
    "code": "class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};",
    "solution": [
      "def match(text, pattern):\n    if not pattern: return not text\n    first_match = bool(text) and pattern[0] in {text[0], '.'}\n    return first_match and match(text[1:], pattern[1:])",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        if (pattern.isEmpty()) return text.isEmpty();\n        boolean first_match = (!text.isEmpty() &&\n                               (pattern.charAt(0) == text.charAt(0) || pattern.charAt(0) == '.'));\n\n        if (pattern.length() >= 2 && pattern.charAt(1) == '*'){\n            return (isMatch(text, pattern.substring(2)) ||\n                    (first_match && isMatch(text.substring(1), pattern)));\n        } else {\n            return first_match && isMatch(text.substring(1), pattern.substring(1));\n        }\n    }\n}",
      "enum Result {\n    TRUE, FALSE\n}\n\nclass Solution {\n    Result[][] memo;\n\n    public boolean isMatch(String text, String pattern) {\n        memo = new Result[text.length() + 1][pattern.length() + 1];\n        return dp(0, 0, text, pattern);\n    }\n\n    public boolean dp(int i, int j, String text, String pattern) {\n        if (memo[i][j] != null) {\n            return memo[i][j] == Result.TRUE;\n        }\n        boolean ans;\n        if (j == pattern.length()){\n            ans = i == text.length();\n        } else{\n            boolean first_match = (i < text.length() &&\n                                   (pattern.charAt(j) == text.charAt(i) ||\n                                    pattern.charAt(j) == '.'));\n\n            if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                ans = (dp(i, j+2, text, pattern) ||\n                       first_match && dp(i+1, j, text, pattern));\n            } else {\n                ans = first_match && dp(i+1, j+1, text, pattern);\n            }\n        }\n        memo[i][j] = ans ? Result.TRUE : Result.FALSE;\n        return ans;\n    }\n}",
      "class Solution {\n    public boolean isMatch(String text, String pattern) {\n        boolean[][] dp = new boolean[text.length() + 1][pattern.length() + 1];\n        dp[text.length()][pattern.length()] = true;\n\n        for (int i = text.length(); i >= 0; i--){\n            for (int j = pattern.length() - 1; j >= 0; j--){\n                boolean first_match = (i < text.length() &&\n                                       (pattern.charAt(j) == text.charAt(i) ||\n                                        pattern.charAt(j) == '.'));\n                if (j + 1 < pattern.length() && pattern.charAt(j+1) == '*'){\n                    dp[i][j] = dp[i][j+2] || first_match && dp[i+1][j];\n                } else {\n                    dp[i][j] = first_match && dp[i+1][j+1];\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}"
    ]
  },
  {
    "number": 37,
    "question": "Can you solve this real interview question? Longest Common Prefix - Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\n\nExample 2:\n\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n\n \n\nConstraints:\n\n * 1 <= strs.length <= 200\n * 0 <= strs[i].length <= 200\n * strs[i] consists of only lowercase English letters.",
    "code": "class Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        \n    }\n};",
    "solution": [
      " public String longestCommonPrefix(String[] strs) {\n    if (strs.length == 0) return \"\";\n    String prefix = strs[0];\n    for (int i = 1; i < strs.length; i++)\n        while (strs[i].indexOf(prefix) != 0) {\n            prefix = prefix.substring(0, prefix.length() - 1);\n            if (prefix.isEmpty()) return \"\";\n        }        \n    return prefix;\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";\n    for (int i = 0; i < strs[0].length() ; i++){\n        char c = strs[0].charAt(i);\n        for (int j = 1; j < strs.length; j ++) {\n            if (i == strs[j].length() || strs[j].charAt(i) != c)\n                return strs[0].substring(0, i);             \n        }\n    }\n    return strs[0];\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0) return \"\";    \n        return longestCommonPrefix(strs, 0 , strs.length - 1);\n}\n\nprivate String longestCommonPrefix(String[] strs, int l, int r) {\n    if (l == r) {\n        return strs[l];\n    }\n    else {\n        int mid = (l + r)/2;\n        String lcpLeft =   longestCommonPrefix(strs, l , mid);\n        String lcpRight =  longestCommonPrefix(strs, mid + 1,r);\n        return commonPrefix(lcpLeft, lcpRight);\n   }\n}\n\nString commonPrefix(String left,String right) {\n    int min = Math.min(left.length(), right.length());       \n    for (int i = 0; i < min; i++) {\n        if ( left.charAt(i) != right.charAt(i) )\n            return left.substring(0, i);\n    }\n    return left.substring(0, min);\n}",
      "public String longestCommonPrefix(String[] strs) {\n    if (strs == null || strs.length == 0)\n        return \"\";\n    int minLen = Integer.MAX_VALUE;\n    for (String str : strs)\n        minLen = Math.min(minLen, str.length());\n    int low = 1;\n    int high = minLen;\n    while (low <= high) {\n        int middle = (low + high) / 2;\n        if (isCommonPrefix(strs, middle))\n            low = middle + 1;\n        else\n            high = middle - 1;\n    }\n    return strs[0].substring(0, (low + high) / 2);\n}\n\nprivate boolean isCommonPrefix(String[] strs, int len){\n    String str1 = strs[0].substring(0,len);\n    for (int i = 1; i < strs.length; i++)\n        if (!strs[i].startsWith(str1))\n            return false;\n    return true;\n}",
      "public String longestCommonPrefix(String q, String[] strs) {\n    if (strs == null || strs.length == 0)\n         return \"\";  \n    if (strs.length == 1)\n         return strs[0];\n    Trie trie = new Trie();      \n    for (int i = 1; i < strs.length ; i++) {\n        trie.insert(strs[i]);\n    }\n    return trie.searchLongestPrefix(q);\n}\n\nclass TrieNode {\n\n    // R links to node children\n    private TrieNode[] links;\n\n    private final int R = 26;\n\n    private boolean isEnd;\n\n    // number of children non null links\n    private int size;    \n    public void put(char ch, TrieNode node) {\n        links[ch -'a'] = node;\n        size++;\n    }\n\n    public int getLinks() {\n        return size;\n    }\n    //assume methods containsKey, isEnd, get, put are implemented as it is described\n   //in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n}\n\npublic class Trie {\n\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n//assume methods insert, search, searchPrefix are implemented as it is described\n//in  https://leetcode.com/articles/implement-trie-prefix-tree/)\n    private String searchLongestPrefix(String word) {\n        TrieNode node = root;\n        StringBuilder prefix = new StringBuilder();\n        for (int i = 0; i < word.length(); i++) {\n            char curLetter = word.charAt(i);\n            if (node.containsKey(curLetter) && (node.getLinks() == 1) && (!node.isEnd())) {\n                prefix.append(curLetter);\n                node = node.get(curLetter);\n            }\n            else\n                return prefix.toString();\n\n         }\n         return prefix.toString();\n    }\n}"
    ]
  },
  {
    "number": 38,
    "question": "Can you solve this real interview question? 4Sum - Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n * 0 <= a, b, c, d < n\n * a, b, c, and d are distinct.\n * nums[a] + nums[b] + nums[c] + nums[d] == target\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n\n\nExample 2:\n\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 200\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109",
    "code": "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int \ntarget) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        int lo = start, hi = int(nums.size()) - 1;\n    \n        while (lo < hi) {\n            int curr_sum = nums[lo] + nums[hi];\n            if (curr_sum < target || (lo > start && nums[lo] == nums[lo - 1])) {\n                ++lo;\n            } else if (curr_sum > target || (hi < nums.size() - 1 && nums[hi] == nums[hi + 1])) {\n                --hi;\n            } else {\n                res.push_back({ nums[lo++], nums[hi--] });\n            }\n        }\n                                                           \n        return res;\n    }\n};",
      "class Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        sort(begin(nums), end(nums));\n        return kSum(nums, target, 0, 4);\n    }\n\t\n    vector<vector<int>> kSum(vector<int>& nums, long long target, int start, int k) {\n        vector<vector<int>> res;\n        \n        // If we have run out of numbers to add, return res.\n        if (start == nums.size()) {\n            return res;\n        }\n        \n        // There are k remaining values to add to the sum. The \n        // average of these values is at least target / k.\n        long long average_value = target / k;\n        \n        // We cannot obtain a sum of target if the smallest value\n        // in nums is greater than target / k or if the largest \n        // value in nums is smaller than target / k.\n        if  (nums[start] > average_value || average_value > nums.back()) {\n            return res;\n        }\n            \n        if (k == 2) {\n            return twoSum(nums, target, start);\n        }\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (i == start || nums[i - 1] != nums[i]) {\n                for (vector<int>& subset : kSum(nums, static_cast<long>(target) - nums[i], i + 1, k - 1)) {\n                    res.push_back({nums[i]});\n                    res.back().insert(end(res.back()), begin(subset), end(subset));\n                }\n            }\n        }\n                                            \n        return res;\n    }\n\t\n    vector<vector<int>> twoSum(vector<int>& nums, long long target, int start) {\n        vector<vector<int>> res;\n        unordered_set<long long> s;\n    \n        for (int i = start; i < nums.size(); ++i) {\n            if (res.empty() || res.back()[1] != nums[i]) {\n                if (s.count(target - nums[i])) {\n                    res.push_back({int(target - nums[i]), nums[i]});\n                }\n            }\n            s.insert(nums[i]);\n        }\n                                             \n        return res;\n    }  \n};"
    ]
  },
  {
    "number": 39,
    "question": "Can you solve this real interview question? Next Permutation - A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n * For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n * For example, the next permutation of arr = [1,2,3] is [1,3,2].\n * Similarly, the next permutation of arr = [2,3,1] is [3,1,2].\n * While the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place [http://en.wikipedia.org/wiki/In-place_algorithm] and use only constant extra memory.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\n\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\n\nExample 3:\n\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 100\n * 0 <= nums[i] <= 100",
    "code": "class Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "public class Solution {\n    public void nextPermutation(int[] nums) {\n        int i = nums.length - 2;\n        while (i >= 0 && nums[i + 1] <= nums[i]) {\n            i--;\n        }\n        if (i >= 0) {\n            int j = nums.length - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        reverse(nums, i + 1);\n    }\n\n    private void reverse(int[] nums, int start) {\n        int i = start, j = nums.length - 1;\n        while (i < j) {\n            swap(nums, i, j);\n            i++;\n            j--;\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
    ]
  },
  {
    "number": 40,
    "question": "Can you solve this real interview question? Combination Sum II - Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n\n\nExample 2:\n\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n\n\n \n\nConstraints:\n\n * 1 <= candidates.length <= 100\n * 1 <= candidates[i] <= 50\n * 1 <= target <= 30",
    "code": "class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& \ncandidates, int target) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // container to hold the final combinations\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int candidate : candidates) {\n            if (counter.containsKey(candidate))\n                counter.put(candidate, counter.get(candidate) + 1);\n            else\n                counter.put(candidate, 1);\n        }\n\n        // convert the counter table to a list of (num, count) tuples\n        List<int[]> counterList = new ArrayList<>();\n        counter.forEach((key, value) -> {\n            counterList.add(new int[]{key, value});\n        });\n\n        backtrack(comb, target, 0, counterList, results);\n        return results;\n    }\n\n    private void backtrack(LinkedList<Integer> comb,\n                           int remain, int curr,\n                           List<int[]> counter,\n                           List<List<Integer>> results) {\n\n        if (remain <= 0) {\n            if (remain == 0) {\n                // make a deep copy of the current combination.\n                results.add(new ArrayList<Integer>(comb));\n            }\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < counter.size(); ++nextCurr) {\n            int[] entry = counter.get(nextCurr);\n            Integer candidate = entry[0], freq = entry[1];\n\n            if (freq <= 0)\n                continue;\n\n            // add a new element to the current combination\n            comb.addLast(candidate);\n            counter.set(nextCurr, new int[]{candidate, freq - 1});\n\n            // continue the exploration with the updated combination\n            backtrack(comb, remain - candidate, nextCurr, counter, results);\n\n            // backtrack the changes, so that we can try another candidate\n            counter.set(nextCurr, new int[]{candidate, freq});\n            comb.removeLast();\n        }\n    }\n}",
      "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> results = new ArrayList<>();\n        LinkedList<Integer> comb = new LinkedList<>();\n\n        Arrays.sort(candidates);\n\n        backtrack(candidates, comb, target, 0, results);\n        return results;\n    }\n\n    private void backtrack(int[] candidates, LinkedList<Integer> comb,\n                           Integer remain, Integer curr,\n                           List<List<Integer>> results) {\n        if (remain == 0) {\n            // copy the current combination to the final list.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (int nextCurr = curr; nextCurr < candidates.length; ++nextCurr) {\n            if (nextCurr > curr && candidates[nextCurr] == candidates[nextCurr - 1])\n                continue;\n\n            Integer pick = candidates[nextCurr];\n            // optimization: early stopping\n            if (remain - pick < 0)\n                break;\n\n            comb.addLast(pick);\n            backtrack(candidates, comb, remain - pick, nextCurr + 1, results);\n            comb.removeLast();\n        }\n    }\n}"
    ]
  },
  {
    "number": 41,
    "question": "Can you solve this real interview question? Multiply Strings - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\n\n\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n\n\n \n\nConstraints:\n\n * 1 <= num1.length, num2.length <= 200\n * num1 and num2 consist of digits only.\n * Both num1 and num2 do not contain any leading zero, except the number 0 itself.",
    "code": "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\nprivate:\n    // Calculate the sum of all of the results from multiplyOneDigit.\n    string sumResults(vector<vector<int>>& results) {\n        // Initialize answer as a number from results.\n        vector<int> answer = results.back();\n        vector<int> newAnswer;\n        results.pop_back();\n        \n        // Sum each digit from answer and result\n        for (vector<int> result : results) {\n            newAnswer.clear();\n            int carry = 0;\n            \n            for (int i = 0; i < answer.size() || i < result.size(); ++i) {\n                // If answer is shorter than result or vice versa, use 0 as the current digit.\n                int digit1 = i < result.size() ? result[i] : 0;\n                int digit2 = i < answer.size() ? answer[i] : 0;\n                // Add current digits of both numbers.\n                int sum = digit1 + digit2 + carry;\n                // Set carry equal to the tens place digit of sum.\n                carry = sum / 10;\n                // Append the ones place digit of sum to answer.\n                newAnswer.push_back(sum % 10);\n            }\n\n            if (carry) {\n                newAnswer.push_back(carry);\n            }\n            answer = newAnswer;\n        }\n        \n        // Convert answer to a string.\n        string finalAnswer;\n        for (int digit : answer) {\n            finalAnswer.push_back(digit + '0');\n        }\n        return finalAnswer;\n    }\n    \n    // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n\npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // store the multiplication result (reversed) in results.\n        vector<vector<int>> results;\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            results.push_back(multiplyOneDigit(firstNumber, secondNumber[i], i));\n        }\n        \n        // Add all the results in the results array, and store the sum in the answer string.\n        string answer = sumResults(results);\n        \n        // answer is reversed, so reverse it to get the final answer.\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};",
      "class Solution {\nprivate:\n    // Function to add two strings.\n    vector<int> addStrings(vector<int> num1, vector<int>& num2) {\n        vector<int> ans;\n        int carry = 0;\n        \n        for (int i = 0; i < num1.size() || i < num2.size() || carry; ++i) {\n            // If num1 is shorter than num2 or vice versa, use 0 as the current digit.\n            int digit1 = i < num1.size() ? num1[i] : 0;\n            int digit2 = i < num2.size() ? num2[i] : 0;\n            \n            // Add current digits of both numbers.\n            int sum = digit1 + digit2 + carry;\n            // Set carry equal to the tens place digit of sum.\n            carry = sum / 10;\n            // Append the ones place digit of sum to answer.\n            ans.push_back(sum % 10);\n        }\n        \n        return ans;\n    }\n    \n     // Multiply the current digit of secondNumber with firstNumber.\n    vector<int> multiplyOneDigit(string& firstNumber, char& secondNumberDigit, int numZeros) {\n        // Insert zeros at the beginning based on the current digit's place.\n        vector<int> currentResult(numZeros, 0);\n        int carry = 0;\n\n        // Multiply firstNumber with the current digit of secondNumber.\n        for (char firstNumberDigit : firstNumber) {\n            int multiplication = (secondNumberDigit - '0') * (firstNumberDigit - '0') + carry;\n            // Set carry equal to the tens place digit of multiplication.\n            carry = multiplication / 10;\n            // Append last digit to the current result.\n            currentResult.push_back(multiplication % 10);\n        }\n\n        if (carry) {\n            currentResult.push_back(carry);\n        }\n        return currentResult;\n    }\n    \npublic:\n    string multiply(string firstNumber, string secondNumber) {\n        if (firstNumber == \"0\" || secondNumber == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse both the numbers.\n        reverse(firstNumber.begin(), firstNumber.end());\n        reverse(secondNumber.begin(), secondNumber.end());\n        \n        // To store the multiplication result of each digit of secondNumber with firstNumber.\n        vector<int> ans(firstNumber.size() + secondNumber.size(), 0);\n        \n        // For each digit in secondNumber, multipy the digit by firstNumber and\n        // add the multiplication result to ans.\n        for (int i = 0; i < secondNumber.size(); ++i) {\n            // Add the current result to final ans.\n            ans = addStrings(multiplyOneDigit(firstNumber, secondNumber[i], i), ans);\n        }\n        \n        // Pop excess 0 from the rear of ans.\n        if (ans[ans.size() - 1] == 0) {\n            ans.pop_back();\n        }\n        \n        // Ans is in the reversed order.\n        // Copy it in reverse order to get the final ans.\n        string answer;\n        for (int i = ans.size() - 1; i >= 0; --i) {\n            answer.push_back(ans[i] + '0');\n        }\n        \n        return answer;\n    }\n};",
      "class Solution {\npublic:\n    string multiply(string num1, string num2) {\n        if (num1 == \"0\" || num2 == \"0\") {\n            return \"0\";\n        }\n        \n        // Reverse num1 and num2.\n        reverse(num1.begin(), num1.end());\n        reverse(num2.begin(), num2.end());\n        \n        // Initialize answer as a string of zeros of length N.\n        int N = num1.size() + num2.size();\n        string answer(N, '0');\n        \n        for (int place2 = 0; place2 < num2.size(); place2++) {\n            int digit2 = num2[place2] - '0';\n            \n            // For each digit in num2 multiply the digit by all digits in num1.\n            for (int place1 = 0; place1 < num1.size(); place1++) {\n                int digit1 = num1[place1] - '0';\n                \n                // The number of zeros from multiplying to digits depends on the \n                // place of digit2 in num2 and the place of the digit1 in num1.\n                int numZeros = place1 + place2;\n                \n                // The digit currently at position numZeros in the answer string\n                // is carried over and summed with the current result.\n                int carry = answer[numZeros] - '0';\n                int multiplication = digit1 * digit2 + carry;\n                \n                // Set the ones place of the multiplication result.\n                answer[numZeros] = (multiplication % 10) + '0';\n                \n                // Carry the tens place of the multiplication result by \n                // adding it to the next position in the answer array.\n                answer[numZeros + 1] += (multiplication / 10);\n            }\n        }\n        \n        if (answer.back() == '0') {\n            answer.pop_back();\n        }\n        reverse(answer.begin(), answer.end());\n        return answer;\n    }\n};"
    ]
  },
  {
    "number": 42,
    "question": "Can you solve this real interview question? Permutations II - Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\n\n\nExample 2:\n\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 8\n * -10 <= nums[i] <= 10",
    "code": "class Solution {\npublic:\n    vector<vector<int>> permuteUnique(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> results = new ArrayList<>();\n\n        // count the occurrence of each number\n        HashMap<Integer, Integer> counter = new HashMap<>();\n        for (int num : nums) {\n            if (!counter.containsKey(num))\n                counter.put(num, 0);\n            counter.put(num, counter.get(num) + 1);\n        }\n\n        LinkedList<Integer> comb = new LinkedList<>();\n        this.backtrack(comb, nums.length, counter, results);\n        return results;\n    }\n\n    protected void backtrack(\n            LinkedList<Integer> comb,\n            Integer N,\n            HashMap<Integer, Integer> counter,\n            List<List<Integer>> results) {\n\n        if (comb.size() == N) {\n            // make a deep copy of the resulting permutation,\n            // since the permutation would be backtracked later.\n            results.add(new ArrayList<Integer>(comb));\n            return;\n        }\n\n        for (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\n            Integer num = entry.getKey();\n            Integer count = entry.getValue();\n            if (count == 0)\n                continue;\n            // add this number into the current combination\n            comb.addLast(num);\n            counter.put(num, count - 1);\n\n            // continue the exploration\n            backtrack(comb, N, counter, results);\n\n            // revert the choice for the next exploration\n            comb.removeLast();\n            counter.put(num, count);\n        }\n    }\n}"
    ]
  },
  {
    "number": 43,
    "question": "Can you solve this real interview question?   - You are given four integers sx, sy, fx, fy, and a non-negative integer t.\n\nIn an infinite 2D grid, you start at the cell (sx, sy). Each second, you must move to any of its adjacent cells.\n\nReturn true if you can reach cell (fx, fy) after exactly t seconds, or false otherwise.\n\nA cell's adjacent cells are the 8 cells around it that share at least one corner with it. You can visit the same cell several times.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2023/08/05/example2.svg]\n\n\nInput: sx = 2, sy = 4, fx = 7, fy = 7, t = 6\nOutput: true\nExplanation: Starting at cell (2, 4), we can reach cell (7, 7) in exactly 6 seconds by going through the cells depicted in the picture above. \n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2023/08/05/example1.svg]\n\n\nInput: sx = 3, sy = 1, fx = 7, fy = 3, t = 3\nOutput: false\nExplanation: Starting at cell (3, 1), it takes at least 4 seconds to reach cell (7, 3) by going through the cells depicted in the picture above. Hence, we cannot reach cell (7, 3) at the third second.\n\n\n \n\nConstraints:\n\n * 1 <= sx, sy, fx, fy <= 109\n * 0 <= t <= 109",
    "code": "class Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, \nint t) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    bool isReachableAtTime(int sx, int sy, int fx, int fy, int t) {\n        int width = abs(sx - fx);\n        int height = abs(sy - fy);\n        if (width == 0 && height == 0 && t == 1) {\n            return false;\n        }\n        return t >= max(width, height);\n    }\n};"
    ]
  },
  {
    "number": 44,
    "question": "Can you solve this real interview question? Create a DataFrame from List - Write a solution to create a DataFrame from a 2D list called student_data. This 2D list contains the IDs and ages of some students.\n\nThe DataFrame should have two columns, student_id and age, and be in the same order as the original 2D list.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\nstudent_data:\n[\n  [1, 15],\n  [2, 11],\n  [3, 11],\n  [4, 20]\n]\nOutput:\n+------------+-----+\n| student_id | age |\n+------------+-----+\n| 1          | 15  |\n| 2          | 11  |\n| 3          | 11  |\n| 4          | 20  |\n+------------+-----+\nExplanation:\nA DataFrame was created on top of student_data, with two columns named student_id and age.\n",
    "code": "import pandas as pd\n\ndef createDataframe(student_data: List[List[int]]) -> pd.\nDataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef createDataframe(student_data: List[List[int]]) -> pd.DataFrame:\n    column_names = [\"student_id\", \"age\"]\n    result_dataframe = pd.DataFrame(student_data, columns=column_names)\n    return result_dataframe"
    ]
  },
  {
    "number": 45,
    "question": "Can you solve this real interview question? Get the Size of a DataFrame - \nDataFrame players:\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| player_id   | int    |\n| name        | object |\n| age         | int    |\n| position    | object |\n| ...         | ...    |\n+-------------+--------+\n\n\nWrite a solution to calculate and display the number of rows and columns of players.\n\nReturn the result as an array:\n\n[number of rows, number of columns]\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\n+-----------+----------+-----+-------------+--------------------+\n| player_id | name     | age | position    | team               |\n+-----------+----------+-----+-------------+--------------------+\n| 846       | Mason    | 21  | Forward     | RealMadrid         |\n| 749       | Riley    | 30  | Winger      | Barcelona          |\n| 155       | Bob      | 28  | Striker     | ManchesterUnited   |\n| 583       | Isabella | 32  | Goalkeeper  | Liverpool          |\n| 388       | Zachary  | 24  | Midfielder  | BayernMunich       |\n| 883       | Ava      | 23  | Defender    | Chelsea            |\n| 355       | Violet   | 18  | Striker     | Juventus           |\n| 247       | Thomas   | 27  | Striker     | ParisSaint-Germain |\n| 761       | Jack     | 33  | Midfielder  | ManchesterCity     |\n| 642       | Charlie  | 36  | Center-back | Arsenal            |\n+-----------+----------+-----+-------------+--------------------+\nOutput:\n[10, 5]\nExplanation:\nThis DataFrame contains 10 rows and 5 columns.\n",
    "code": "import pandas as pd\n\ndef getDataframeSize(players: pd.DataFrame) -> List[int]:\n    ",
    "solution": [
      "import pandas as pd\n\ndef getDataframeSize(players: pd.DataFrame) -> List:\n    return [players.shape[0], players.shape[1]]"
    ]
  },
  {
    "number": 46,
    "question": "Can you solve this real interview question? Display the First Three Rows - \nDataFrame: employees\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| employee_id | int    |\n| name        | object |\n| department  | object |\n| salary      | int    |\n+-------------+--------+\n\n\nWrite a solution to display the first 3 rows of this DataFrame.\n\n \n\nExample 1:\n\n\nInput:\nDataFrame employees\n+-------------+-----------+-----------------------+--------+\n| employee_id | name      | department            | salary |\n+-------------+-----------+-----------------------+--------+\n| 3           | Bob       | Operations            | 48675  |\n| 90          | Alice     | Sales                 | 11096  |\n| 9           | Tatiana   | Engineering           | 33805  |\n| 60          | Annabelle | InformationTechnology | 37678  |\n| 49          | Jonathan  | HumanResources        | 23793  |\n| 43          | Khaled    | Administration        | 40454  |\n+-------------+-----------+-----------------------+--------+\nOutput:\n+-------------+---------+-------------+--------+\n| employee_id | name    | department  | salary |\n+-------------+---------+-------------+--------+\n| 3           | Bob     | Operations  | 48675  |\n| 90          | Alice   | Sales       | 11096  |\n| 9           | Tatiana | Engineering | 33805  |\n+-------------+---------+-------------+--------+\nExplanation: \nOnly the first 3 rows are displayed.",
    "code": "import pandas as pd\n\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\n    return employees.head(3)"
    ]
  },
  {
    "number": 47,
    "question": "Can you solve this real interview question? Select Data - \nDataFrame students\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| student_id  | int    |\n| name        | object |\n| age         | int    |\n+-------------+--------+\n\n\n\nWrite a solution to select the name and age of the student with student_id = 101.\n\nThe result format is in the following example.\n\n \n\n\nExample 1:\nInput:\n+------------+---------+-----+\n| student_id | name    | age |\n+------------+---------+-----+\n| 101        | Ulysses | 13  |\n| 53         | William | 10  |\n| 128        | Henry   | 6   |\n| 3          | Henry   | 11  |\n+------------+---------+-----+\nOutput:\n+---------+-----+\n| name    | age | \n+---------+-----+\n| Ulysses | 13  |\n+---------+-----+\nExplanation:\nStudent Ulysses has student_id = 101, we select the name and age.",
    "code": "import pandas as pd\n\ndef selectData(students: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef selectData(students: pd.DataFrame) -> pd.DataFrame:\n    return students.loc[students[\"student_id\"] == 101, [\"name\", \"age\"]]"
    ]
  },
  {
    "number": 48,
    "question": "Can you solve this real interview question? Create a New Column - \nDataFrame employees\n+-------------+--------+\n| Column Name | Type.  |\n+-------------+--------+\n| name        | object |\n| salary      | int.   |\n+-------------+--------+\n\n\nA company plans to provide its employees with a bonus.\n\nWrite a solution to create a new column name bonus that contains the doubled values of the salary column.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\nDataFrame employees\n+---------+--------+\n| name    | salary |\n+---------+--------+\n| Piper   | 4548   |\n| Grace   | 28150  |\n| Georgia | 1103   |\n| Willow  | 6593   |\n| Finn    | 74576  |\n| Thomas  | 24433  |\n+---------+--------+\nOutput:\n+---------+--------+--------+\n| name    | salary | bonus  |\n+---------+--------+--------+\n| Piper   | 4548   | 9096   |\n| Grace   | 28150  | 56300  |\n| Georgia | 1103   | 2206   |\n| Willow  |  593   | 13186  |\n| Finn    | 74576  | 149152 |\n| Thomas  | 24433  | 48866  |\n+---------+--------+--------+\nExplanation: \nA new column bonus is created by doubling the value in the column salary.",
    "code": "import pandas as pd\n\ndef createBonusColumn(employees: pd.DataFrame) -> pd.\nDataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['bonus'] = employees['salary'] * 2\n    return employees"
    ]
  },
  {
    "number": 49,
    "question": "Can you solve this real interview question? Drop Duplicate Rows - \nDataFrame customers\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| customer_id | int    |\n| name        | object |\n| email       | object |\n+-------------+--------+\n\n\nThere are some duplicate rows in the DataFrame based on the email column.\n\nWrite a solution to remove these duplicate rows and keep only the first occurrence.\n\nThe result format is in the following example.\n\n \n\n\nExample 1:\nInput:\n+-------------+---------+---------------------+\n| customer_id | name    | email               |\n+-------------+---------+---------------------+\n| 1           | Ella    | emily@example.com   |\n| 2           | David   | michael@example.com |\n| 3           | Zachary | sarah@example.com   |\n| 4           | Alice   | john@example.com    |\n| 5           | Finn    | john@example.com    |\n| 6           | Violet  | alice@example.com   |\n+-------------+---------+---------------------+\nOutput:  \n+-------------+---------+---------------------+\n| customer_id | name    | email               |\n+-------------+---------+---------------------+\n| 1           | Ella    | emily@example.com   |\n| 2           | David   | michael@example.com |\n| 3           | Zachary | sarah@example.com   |\n| 4           | Alice   | john@example.com    |\n| 6           | Violet  | alice@example.com   |\n+-------------+---------+---------------------+\nExplanation:\nAlic (customer_id = 4) and Finn (customer_id = 5) both use john@example.com, so only the first occurrence of this email is retained.\n",
    "code": "import pandas as pd\n\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.\nDataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:\n    customers.drop_duplicates(subset='email', keep='first', inplace=True)\n    return customers"
    ]
  },
  {
    "number": 50,
    "question": "Can you solve this real interview question? Drop Missing Data - \nDataFrame students\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| student_id  | int    |\n| name        | object |\n| age         | int    |\n+-------------+--------+\n\n\nThere are some rows having missing values in the name column.\n\nWrite a solution to remove the rows with missing values.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\n+------------+---------+-----+\n| student_id | name    | age |\n+------------+---------+-----+\n| 32         | Piper   | 5   |\n| 217        | None    | 19  |\n| 779        | Georgia | 20  |\n| 849        | Willow  | 14  |\n+------------+---------+-----+\nOutput:\n+------------+---------+-----+\n| student_id | name    | age |\n+------------+---------+-----+\n| 32         | Piper   | 5   |\n| 779        | Georgia | 20  | \n| 849        | Willow  | 14  | \n+------------+---------+-----+\nExplanation: \nStudent with id 217 havs empty value in the name column, so it will be removed.",
    "code": "import pandas as pd\n\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\n    students.dropna(subset=['name'], inplace=True)\n    return students"
    ]
  },
  {
    "number": 51,
    "question": "Can you solve this real interview question? Modify Columns - \nDataFrame employees\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| name        | object |\n| salary      | int    |\n+-------------+--------+\n\n\nA company intends to give its employees a pay rise.\n\nWrite a solution to modify the salary column by multiplying each salary by 2.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\nDataFrame employees\n+---------+--------+\n| name    | salary |\n+---------+--------+\n| Jack    | 19666  |\n| Piper   | 74754  |\n| Mia     | 62509  |\n| Ulysses | 54866  |\n+---------+--------+\nOutput:\n+---------+--------+\n| name    | salary |\n+---------+--------+\n| Jack    | 39332  |\n| Piper   | 149508 |\n| Mia     | 125018 |\n| Ulysses | 109732 |\n+---------+--------+\nExplanation:\nEvery salary has been doubled.",
    "code": "import pandas as pd\n\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.\nDataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['salary'] = employees['salary'] * 2\n    return employees"
    ]
  },
  {
    "number": 52,
    "question": "Can you solve this real interview question? Rename Columns - \nDataFrame students\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| id          | int    |\n| first       | object |\n| last        | object |\n| age         | int    |\n+-------------+--------+\n\n\nWrite a solution to rename the columns as follows:\n\n * id to student_id\n * first to first_name\n * last to last_name\n * age to age_in_years\n\nThe result format is in the following example.\n\n \n\n\nExample 1:\nInput:\n+----+---------+----------+-----+\n| id | first   | last     | age |\n+----+---------+----------+-----+\n| 1  | Mason   | King     | 6   |\n| 2  | Ava     | Wright   | 7   |\n| 3  | Taylor  | Hall     | 16  |\n| 4  | Georgia | Thompson | 18  |\n| 5  | Thomas  | Moore    | 10  |\n+----+---------+----------+-----+\nOutput:\n+------------+------------+-----------+--------------+\n| student_id | first_name | last_name | age_in_years |\n+------------+------------+-----------+--------------+\n| 1          | Mason      | King      | 6            |\n| 2          | Ava        | Wright    | 7            |\n| 3          | Taylor     | Hall      | 16           |\n| 4          | Georgia    | Thompson  | 18           |\n| 5          | Thomas     | Moore     | 10           |\n+------------+------------+-----------+--------------+\nExplanation: \nThe column names are changed accordingly.",
    "code": "import pandas as pd\n\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n    students = students.rename(\n        columns={\n            \"id\": \"student_id\",\n            \"first\": \"first_name\",\n            \"last\": \"last_name\",\n            \"age\": \"age_in_years\",\n        }\n    )\n    return students\n"
    ]
  },
  {
    "number": 53,
    "question": "Can you solve this real interview question? Change Data Type - \nDataFrame students\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| student_id  | int    |\n| name        | object |\n| age         | int    |\n| grade       | float  |\n+-------------+--------+\n\n\nWrite a solution to correct the errors:\n\nThe grade column is stored as floats, convert it to integers.\n\nThe result format is in the following example.\n\n \n\n\nExample 1:\nInput:\nDataFrame students:\n+------------+------+-----+-------+\n| student_id | name | age | grade |\n+------------+------+-----+-------+\n| 1          | Ava  | 6   | 73.0  |\n| 2          | Kate | 15  | 87.0  |\n+------------+------+-----+-------+\nOutput:\n+------------+------+-----+-------+\n| student_id | name | age | grade |\n+------------+------+-----+-------+\n| 1          | Ava  | 6   | 73    |\n| 2          | Kate | 15  | 87    |\n+------------+------+-----+-------+\nExplanation: \nThe data types of the column grade is converted to int.",
    "code": "import pandas as pd\n\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n    students = students.astype({'grade': int})\n    return students"
    ]
  },
  {
    "number": 54,
    "question": "Can you solve this real interview question? Fill Missing Data - \nDataFrame products\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| name        | object |\n| quantity    | int    |\n| price       | int    |\n+-------------+--------+\n\n\nWrite a solution to fill in the missing value as 0 in the quantity column.\n\nThe result format is in the following example.\n\n \n\n\nExample 1:\nInput:+-----------------+----------+-------+\n| name            | quantity | price |\n+-----------------+----------+-------+\n| Wristwatch      | None     | 135   |\n| WirelessEarbuds | None     | 821   |\n| GolfClubs       | 779      | 9319  |\n| Printer         | 849      | 3051  |\n+-----------------+----------+-------+\nOutput:\n+-----------------+----------+-------+\n| name            | quantity | price |\n+-----------------+----------+-------+\n| Wristwatch      | 0        | 135   |\n| WirelessEarbuds | 0        | 821   |\n| GolfClubs       | 779      | 9319  |\n| Printer         | 849      | 3051  |\n+-----------------+----------+-------+\nExplanation: \nThe quantity for Wristwatch and WirelessEarbuds are filled by 0.",
    "code": "import pandas as pd\n\ndef fillMissingValues(products: pd.DataFrame) -> pd.\nDataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef fillMissingValues(products: pd.DataFrame) -> pd.DataFrame:\n    products['quantity'].fillna(0, inplace=True)\n    return products\n"
    ]
  },
  {
    "number": 55,
    "question": "Can you solve this real interview question? Reshape Data: Concatenate - \nDataFrame df1\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| student_id  | int    |\n| name        | object |\n| age         | int    |\n+-------------+--------+\n\nDataFrame df2\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| student_id  | int    |\n| name        | object |\n| age         | int    |\n+-------------+--------+\n\n\n\nWrite a solution to concatenate these two DataFrames vertically into one DataFrame.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\ndf1\n+------------+---------+-----+\n| student_id | name    | age |\n+------------+---------+-----+\n| 1          | Mason   | 8   |\n| 2          | Ava     | 6   |\n| 3          | Taylor  | 15  |\n| 4          | Georgia | 17  |\n+------------+---------+-----+\ndf2\n+------------+------+-----+\n| student_id | name | age |\n+------------+------+-----+\n| 5          | Leo  | 7   |\n| 6          | Alex | 7   |\n+------------+------+-----+\nOutput:\n+------------+---------+-----+\n| student_id | name    | age |\n+------------+---------+-----+\n| 1          | Mason   | 8   |\n| 2          | Ava     | 6   |\n| 3          | Taylor  | 15  |\n| 4          | Georgia | 17  |\n| 5          | Leo     | 7   |\n| 6          | Alex    | 7   |\n+------------+---------+-----+\nExplanation:\nThe two DataFramess are stacked vertically, and their rows are combined.",
    "code": "import pandas as pd\n\ndef concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) \n-> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef concatenateTables(df1: pd.DataFrame, df2: pd.DataFrame) -> pd.DataFrame:\n    return pd.concat([df1, df2], axis=0)"
    ]
  },
  {
    "number": 56,
    "question": "Can you solve this real interview question? Reshape Data: Pivot - \nDataFrame weather\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| city        | object |\n| month       | object |\n| temperature | int    |\n+-------------+--------+\n\n\nWrite a solution to pivot the data so that each row represents temperatures for a specific month, and each city is a separate column.\n\nThe result format is in the following example.\n\n \n\n\nExample 1:\nInput:\n+--------------+----------+-------------+\n| city         | month    | temperature |\n+--------------+----------+-------------+\n| Jacksonville | January  | 13          |\n| Jacksonville | February | 23          |\n| Jacksonville | March    | 38          |\n| Jacksonville | April    | 5           |\n| Jacksonville | May      | 34          |\n| ElPaso       | January  | 20          |\n| ElPaso       | February | 6           |\n| ElPaso       | March    | 26          |\n| ElPaso       | April    | 2           |\n| ElPaso       | May      | 43          |\n+--------------+----------+-------------+\nOutput:\n+----------+--------+--------------+\n| month    | ElPaso | Jacksonville |\n+----------+--------+--------------+\n| April    | 2      | 5            |\n| February | 6      | 23           |\n| January  | 20     | 13           |\n| March    | 26     | 38           |\n| May      | 43     | 34           |\n+----------+--------+--------------+\nExplanation:\nThe table is pivoted, each column represents a city, and each row represents a specific month.",
    "code": "import pandas as pd\n\ndef pivotTable(weather: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef pivotTable(weather: pd.DataFrame) -> pd.DataFrame:\n    ans = weather.pivot(index='month', columns='city', values='temperature')\n    return ans"
    ]
  },
  {
    "number": 57,
    "question": "Can you solve this real interview question? Reshape Data: Melt - \nDataFrame report\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| product     | object |\n| quarter_1   | int    |\n| quarter_2   | int    |\n| quarter_3   | int    |\n| quarter_4   | int    |\n+-------------+--------+\n\n\nWrite a solution to reshape the data so that each row represents sales data for a product in a specific quarter.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput:\n+-------------+-----------+-----------+-----------+-----------+\n| product     | quarter_1 | quarter_2 | quarter_3 | quarter_4 |\n+-------------+-----------+-----------+-----------+-----------+\n| Umbrella    | 417       | 224       | 379       | 611       |\n| SleepingBag | 800       | 936       | 93        | 875       |\n+-------------+-----------+-----------+-----------+-----------+\nOutput:\n+-------------+-----------+-------+\n| product     | quarter   | sales |\n+-------------+-----------+-------+\n| Umbrella    | quarter_1 | 417   |\n| SleepingBag | quarter_1 | 800   |\n| Umbrella    | quarter_2 | 224   |\n| SleepingBag | quarter_2 | 936   |\n| Umbrella    | quarter_3 | 379   |\n| SleepingBag | quarter_3 | 93    |\n| Umbrella    | quarter_4 | 611   |\n| SleepingBag | quarter_4 | 875   |\n+-------------+-----------+-------+\nExplanation:\nThe DataFrame is reshaped from wide to long format. Each row represents the sales of a product in a quarter.\n",
    "code": "import pandas as pd\n\ndef meltTable(report: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef meltTable(report: pd.DataFrame) -> pd.DataFrame:\n    report = report.melt(\n        id_vars=[\"product\"],\n        value_vars=[\"quarter_1\", \"quarter_2\", \"quarter_3\", \"quarter_4\"],\n        var_name=\"quarter\",\n        value_name=\"sales\",\n    )\n    return report"
    ]
  },
  {
    "number": 58,
    "question": "Can you solve this real interview question? Method Chaining - \nDataFrame animals\n+-------------+--------+\n| Column Name | Type   |\n+-------------+--------+\n| name        | object |\n| species     | object |\n| age         | int    |\n| weight      | int    |\n+-------------+--------+\n\n\nWrite a solution to list the names of animals that weigh strictly more than 100 kilograms.\n\nReturn the animals sorted by weight in descending order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nDataFrame animals:\n+----------+---------+-----+--------+\n| name     | species | age | weight |\n+----------+---------+-----+--------+\n| Tatiana  | Snake   | 98  | 464    |\n| Khaled   | Giraffe | 50  | 41     |\n| Alex     | Leopard | 6   | 328    |\n| Jonathan | Monkey  | 45  | 463    |\n| Stefan   | Bear    | 100 | 50     |\n| Tommy    | Panda   | 26  | 349    |\n+----------+---------+-----+--------+\nOutput: \n+----------+\n| name     |\n+----------+\n| Tatiana  |\n| Jonathan |\n| Tommy    |\n| Alex     |\n+----------+\nExplanation: \nAll animals weighing more than 100 should be included in the results table.\nTatiana's weight is 464, Jonathan's weight is 463, Tommy's weight is 349, and Alex's weight is 328.\nThe results should be sorted in descending order of weight.\n\n \n\nIn Pandas, method chaining enables us to perform operations on a DataFrame without breaking up each operation into a separate line or creating multiple temporary variables. \n\nCan you complete this task in just one line of code using method chaining?",
    "code": "import pandas as pd\n\ndef findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:\n    ",
    "solution": [
      "import pandas as pd\n\ndef findHeavyAnimals(animals: pd.DataFrame) -> pd.DataFrame:\n    return animals[animals['weight'] > 100].sort_values(by='weight', ascending=False)[['name']]\n"
    ]
  }
]