[
  {
    "number": 1,
    "question": "Can you solve this real interview question? Maximum Number of Events That Can Be Attended II - You are given an array of events where events[i] = [startDayi, endDayi, valuei]. The ith event starts at startDayi and ends at endDayi, and if you attend this event, you will receive a value of valuei. You are also given an integer k which represents the maximum number of events you can attend.\n\nYou can only attend one event at a time. If you choose to attend an event, you must attend the entire event. Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\n\nReturn the maximum sum of values that you can receive by attending events.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60048-pm.png]\n\n\nInput: events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\nOutput: 7\nExplanation: Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60150-pm.png]\n\n\nInput: events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\nOutput: 10\nExplanation: Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do not have to attend k events.\n\nExample 3:\n\n[https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60703-pm.png]\n\n\nInput: events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\nOutput: 9\nExplanation: Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.\n\n \n\nConstraints:\n\n * 1 <= k <= events.length\n * 1 <= k * events.length <= 106\n * 1 <= startDayi <= endDayi <= 109\n * 1 <= valuei <= 106",
    "code": "class Solution {\npublic:\n    int maxValue(vector<vector<int>>& events, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    public int maxValue(int[][] events, int k) {\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n        int n = events.length;\n        \n        dp = new int[k + 1][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        \n        return dfs(0, k, events);\n    }    \n    \n    private int[][] dp;\n    private int dfs(int curIndex, int count, int[][] events) {\n        if (count == 0 || curIndex == events.length) {\n            return 0;\n        }\n        if (dp[count][curIndex] != -1) {\n            return dp[count][curIndex];\n        }\n        int nextIndex = bisectRight(events, events[curIndex][1]);\n        dp[count][curIndex] = Math.max(dfs(curIndex + 1, count, events), events[curIndex][2] + dfs(nextIndex, count - 1, events));\n        return dp[count][curIndex];\n    }\n    \n    public static int bisectRight(int[][] events, int target) {\n        int left = 0, right = events.length;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (events[mid][0] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }   \n}",
      "class Solution {\n    public static int bisectRight(int[][] events, int target) {\n        int left = 0, right = events.length;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (events[mid][0] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    } \n    \n    public int maxValue(int[][] events, int k) {\n        int n = events.length;\n        int[][] dp = new int[k + 1][n + 1];\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n\n        for (int curIndex = n - 1; curIndex >= 0; --curIndex) {\n            for (int count = 1; count <= k; count++) {\n                int nextIndex = bisectRight(events, events[curIndex][1]);\n                dp[count][curIndex] = Math.max(dp[count][curIndex + 1], events[curIndex][2] + dp[count - 1][nextIndex]);\n            }\n        }\n        return dp[k][0];\n    }\n}",
      "class Solution {\n    public int maxValue(int[][] events, int k) {\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n        int n = events.length;\n        nextIndices = new int[n];\n        for (int curIndex = 0; curIndex < n; ++curIndex) {\n            nextIndices[curIndex] = bisectRight(events, events[curIndex][1]);\n        }\n        \n        dp = new int[k + 1][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        \n        return dfs(0, k, events);\n    }    \n    \n    private int[][] dp;\n    private int[] nextIndices;\n    private int dfs(int curIndex, int count, int[][] events) {\n        if (count == 0 || curIndex == events.length) {\n            return 0;\n        }\n        if (dp[count][curIndex] != -1) {\n            return dp[count][curIndex];\n        }\n        int nextIndex = nextIndices[curIndex];\n        dp[count][curIndex] = Math.max(dfs(curIndex + 1, count, events), events[curIndex][2] + dfs(nextIndex, count - 1, events));\n        return dp[count][curIndex];\n    }\n    \n    public static int bisectRight(int[][] events, int target) {\n        int left = 0, right = events.length;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (events[mid][0] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    }   \n}",
      "class Solution {\n    public static int bisectRight(int[][] events, int target) {\n        int left = 0, right = events.length;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (events[mid][0] <= target) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n        return left;\n    } \n    \n    public int maxValue(int[][] events, int k) {\n        int n = events.length;\n        int[][] dp = new int[k + 1][n + 1];\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n\n        for (int curIndex = n - 1; curIndex >= 0; --curIndex) {\n            int nextIndex = bisectRight(events, events[curIndex][1]);\n            for (int count = 1; count <= k; count++) {\n                dp[count][curIndex] = Math.max(dp[count][curIndex + 1], events[curIndex][2] + dp[count - 1][nextIndex]);\n            }\n        }\n        return dp[k][0];\n    }\n}",
      "class Solution {\n    int[][] dp;\n    public int maxValue(int[][] events, int k) {\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\n        int n = events.length;\n        dp = new int[k + 1][n];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n        return dfs(0, 0, -1, events, k);\n    }\n    \n    private int dfs(int curIndex, int count, int prevEndingTime, int[][] events, int k) {\n        if (curIndex == events.length || count == k) {\n            return 0;\n        }\n        \n        if (prevEndingTime >= events[curIndex][0]) {\n            return dfs(curIndex + 1, count, prevEndingTime, events, k);\n        }\n        \n        if (dp[count][curIndex] != -1) {\n            return dp[count][curIndex];\n        }\n        \n        int ans = Math.max(dfs(curIndex + 1, count, prevEndingTime, events, k),\n                           dfs(curIndex + 1, count + 1, events[curIndex][1], events, k) + events[curIndex][2]);\n        dp[count][curIndex] = ans;\n        return ans;\n    }\n}"
    ]
  },
  {
    "number": 2,
    "question": "Can you solve this real interview question? Recyclable and Low Fat Products - Table: Products\n\n\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| product_id  | int     |\n| low_fats    | enum    |\n| recyclable  | enum    |\n+-------------+---------+\nproduct_id is the primary key (column with unique values) for this table.\nlow_fats is an ENUM (category) of type ('Y', 'N') where 'Y' means this product is low fat and 'N' means it is not.\nrecyclable is an ENUM (category) of types ('Y', 'N') where 'Y' means this product is recyclable and 'N' means it is not.\n\n \n\nWrite a solution to find the ids of products that are both low fat and recyclable.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nProducts table:\n+-------------+----------+------------+\n| product_id  | low_fats | recyclable |\n+-------------+----------+------------+\n| 0           | Y        | N          |\n| 1           | Y        | Y          |\n| 2           | N        | Y          |\n| 3           | Y        | Y          |\n| 4           | N        | N          |\n+-------------+----------+------------+\nOutput: \n+-------------+\n| product_id  |\n+-------------+\n| 1           |\n| 3           |\n+-------------+\nExplanation: Only products 1 and 3 are both low fat and recyclable.\n",
    "code": "# Write your MySQL query statement below\n",
    "solution": [
      "import pandas as pd\n\ndef find_products(products: pd.DataFrame) -> pd.DataFrame:\n    df = products[(products['low_fats'] == 'Y') & (products['recyclable'] == 'Y')]\n\n    df = df[['product_id']]\n    \n    return df"
    ]
  },
  {
    "number": 3,
    "question": "Can you solve this real interview question? Minimum Changes To Make Alternating Binary String - You are given a string s consisting only of the characters '0' and '1'. In one operation, you can change any '0' to '1' or vice versa.\n\nThe string is called alternating if no two adjacent characters are equal. For example, the string \"010\" is alternating, while the string \"0100\" is not.\n\nReturn the minimum number of operations needed to make s alternating.\n\n \n\nExample 1:\n\n\nInput: s = \"0100\"\nOutput: 1\nExplanation: If you change the last character to '1', s will be \"0101\", which is alternating.\n\n\nExample 2:\n\n\nInput: s = \"10\"\nOutput: 0\nExplanation: s is already alternating.\n\n\nExample 3:\n\n\nInput: s = \"1111\"\nOutput: 2\nExplanation: You need two operations to reach \"0101\" or \"1010\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 104\n * s[i] is either '0' or '1'.",
    "code": "class Solution {\npublic:\n    int minOperations(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int minOperations(string s) {\n        int start0 = 0;\n        int start1 = 0;\n        \n        for (int i = 0; i < s.size(); i++) {\n            if (i % 2 == 0) {\n                if (s[i] == '0') {\n                    start1++;\n                } else {\n                    start0++;\n                }\n            } else {\n                if (s[i] == '1') {\n                    start1++;\n                } else {\n                    start0++;\n                }\n            }\n        }\n        \n        return min(start0, start1);\n    }\n};",
      "class Solution {\npublic:\n    int minOperations(string s) {\n        int start0 = 0;\n        \n        for (int i = 0; i < s.size(); i++) {\n            if (i % 2 == 0) {\n                if (s[i] == '1') {\n                    start0++;\n                }\n            } else {\n                if (s[i] == '0') {\n                    start0++;\n                }\n            }\n        }\n        \n        return min(start0, (int) s.size() - start0);\n    }\n};"
    ]
  },
  {
    "number": 4,
    "question": "Can you solve this real interview question? Count Number of Homogenous Substrings - Given a string s, return the number of homogenous substrings of s. Since the answer may be too large, return it modulo 109 + 7.\n\nA string is homogenous if all the characters of the string are the same.\n\nA substring is a contiguous sequence of characters within a string.\n\n \n\nExample 1:\n\n\r\nInput: s = \"abbcccaa\"\r\nOutput: 13\r\nExplanation: The homogenous substrings are listed as below:\r\n\"a\"   appears 3 times.\r\n\"aa\"  appears 1 time.\r\n\"b\"   appears 2 times.\r\n\"bb\"  appears 1 time.\r\n\"c\"   appears 3 times.\r\n\"cc\"  appears 2 times.\r\n\"ccc\" appears 1 time.\r\n3 + 1 + 2 + 1 + 3 + 2 + 1 = 13.\n\nExample 2:\n\n\r\nInput: s = \"xy\"\r\nOutput: 2\r\nExplanation: The homogenous substrings are \"x\" and \"y\".\n\nExample 3:\n\n\r\nInput: s = \"zzzzz\"\r\nOutput: 15\r\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s consists of lowercase letters.",
    "code": "class Solution {\npublic:\n    int countHomogenous(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int countHomogenous(string s) {\n        int ans = 0;\n        int currStreak = 0;\n        int MOD = 1e9 + 7;\n        \n        for (int i = 0; i < s.size(); i++) {\n            if (i == 0 || s[i] == s[i - 1]) {\n                currStreak++;\n            } else {\n                currStreak = 1;\n            }\n            \n            ans = (ans + currStreak) % MOD;\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 5,
    "question": "Can you solve this real interview question? Merge Strings Alternately - You are given two strings word1 and word2. Merge the strings by adding letters in alternating order, starting with word1. If a string is longer than the other, append the additional letters onto the end of the merged string.\n\nReturn the merged string.\n\n \n\nExample 1:\n\n\r\nInput: word1 = \"abc\", word2 = \"pqr\"\r\nOutput: \"apbqcr\"\r\nExplanation: The merged string will be merged as so:\r\nword1:  a   b   c\r\nword2:    p   q   r\r\nmerged: a p b q c r\r\n\n\nExample 2:\n\n\r\nInput: word1 = \"ab\", word2 = \"pqrs\"\r\nOutput: \"apbqrs\"\r\nExplanation: Notice that as word2 is longer, \"rs\" is appended to the end.\r\nword1:  a   b \r\nword2:    p   q   r   s\r\nmerged: a p b q   r   s\r\n\n\nExample 3:\n\n\r\nInput: word1 = \"abcd\", word2 = \"pq\"\r\nOutput: \"apbqcd\"\r\nExplanation: Notice that as word1 is longer, \"cd\" is appended to the end.\r\nword1:  a   b   c   d\r\nword2:    p   q \r\nmerged: a p b q c   d\r\n\n\n \n\nConstraints:\n\n * 1 <= word1.length, word2.length <= 100\n * word1 and word2 consist of lowercase English letters.",
    "code": "class Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        string result = \"\";\n        int i = 0, j = 0;\n\n        while (i < m || j < n) {\n            if (i < m) {\n                result.push_back(word1[i++]);\n            }\n            if (j < n) {\n                result.push_back(word2[j++]);\n            }\n        }\n\n        return result;\n    }\n};",
      "class Solution {\npublic:\n    string mergeAlternately(string word1, string word2) {\n        int m = word1.size();\n        int n = word2.size();\n        string result = \"\";\n\n        for (int i = 0; i < max(m, n); i++) {\n            if (i < m) {\n                result.push_back(word1[i]);\n            }\n            if (i < n) {\n                result.push_back(word2[i]);\n            }\n        }\n\n        return result;\n    }\n};"
    ]
  },
  {
    "number": 6,
    "question": "Can you solve this real interview question? Product's Price for Each Store - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
    "code": "",
    "solution": [
      "import pandas as pd\n\ndef products_price(products: pd.DataFrame) -> pd.DataFrame:\n    # Approach: Utilize .pivot() to get unique stores\n\n    # Utilizing product_id as the index, we will destructure the values \n    # as columns and have the values be the price\n    df = products.pivot(index='product_id', columns='store', values='price').reset_index()\n\n    return df"
    ]
  },
  {
    "number": 7,
    "question": "Can you solve this real interview question? Primary Department for Each Employee - Table: Employee\n\n\n+---------------+---------+\n| Column Name   |  Type   |\n+---------------+---------+\n| employee_id   | int     |\n| department_id | int     |\n| primary_flag  | varchar |\n+---------------+---------+\n(employee_id, department_id) is the primary key (combination of columns with unique values) for this table.\nemployee_id is the id of the employee.\ndepartment_id is the id of the department to which the employee belongs.\nprimary_flag is an ENUM (category) of type ('Y', 'N'). If the flag is 'Y', the department is the primary department for the employee. If the flag is 'N', the department is not the primary.\n\n\n \n\nEmployees can belong to multiple departments. When the employee joins other departments, they need to decide which department is their primary department. Note that when an employee belongs to only one department, their primary column is 'N'.\n\nWrite a solution to report all the employees with their primary department. For employees who belong to one department, report their only department.\n\nReturn the result table in any order.\n\nThe result format is in the following example.\n\n \n\nExample 1:\n\n\nInput: \nEmployee table:\n+-------------+---------------+--------------+\n| employee_id | department_id | primary_flag |\n+-------------+---------------+--------------+\n| 1           | 1             | N            |\n| 2           | 1             | Y            |\n| 2           | 2             | N            |\n| 3           | 3             | N            |\n| 4           | 2             | N            |\n| 4           | 3             | Y            |\n| 4           | 4             | N            |\n+-------------+---------------+--------------+\nOutput: \n+-------------+---------------+\n| employee_id | department_id |\n+-------------+---------------+\n| 1           | 1             |\n| 2           | 1             |\n| 3           | 3             |\n| 4           | 3             |\n+-------------+---------------+\nExplanation: \n- The Primary department for employee 1 is 1.\n- The Primary department for employee 2 is 1.\n- The Primary department for employee 3 is 3.\n- The Primary department for employee 4 is 3.\n",
    "code": "# Write your MySQL query statement below\n",
    "solution": [
      "import pandas as pd\n\ndef find_primary_department(employee: pd.DataFrame) -> pd.DataFrame:\n    # 1. Calculate EmployeeCount as the number of rows for each employee_id\n    employee[\"EmployeeCount\"] = employee.groupby(\"employee_id\")[\n        \"employee_id\"\n    ].transform(\"size\")\n\n    # 2. Filter based on the EmployeeCount or primary_flag\n    result = employee[\n        (employee[\"EmployeeCount\"] == 1) | (employee[\"primary_flag\"] == \"Y\")\n    ][[\"employee_id\", \"department_id\"]]\n\n    # 3. Return result\n    return result"
    ]
  },
  {
    "number": 8,
    "question": "Can you solve this real interview question? Maximum Score of a Good Subarray - You are given an array of integers nums (0-indexed) and an integer k.\n\nThe score of a subarray (i, j) is defined as min(nums[i], nums[i+1], ..., nums[j]) * (j - i + 1). A good subarray is a subarray where i <= k <= j.\n\nReturn the maximum possible score of a good subarray.\n\n \n\nExample 1:\n\n\nInput: nums = [1,4,3,7,4,5], k = 3\nOutput: 15\nExplanation: The optimal subarray is (1, 5) with a score of min(4,3,7,4,5) * (5-1+1) = 3 * 5 = 15. \n\n\nExample 2:\n\n\nInput: nums = [5,5,4,5,4,1,1,1], k = 0\nOutput: 20\nExplanation: The optimal subarray is (0, 4) with a score of min(5,5,4,5,4) * (4-0+1) = 4 * 5 = 20.\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 2 * 104\n * 0 <= k < nums.length",
    "code": "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int ans = solve(nums, k);\n        reverse(nums.begin(), nums.end());\n        return max(ans, solve(nums, nums.size() - k - 1));\n    }\n    \n    int solve(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> left(k, 0);\n        int currMin = INT_MAX;\n        for (int i = k - 1; i >= 0; i--) {\n            currMin = min(currMin, nums[i]);\n            left[i] = currMin;\n        }\n        \n        vector<int> right;\n        currMin = INT_MAX;\n        for (int i = k; i < n; i++) {\n            currMin = min(currMin, nums[i]);\n            right.push_back(currMin);\n        }\n        \n        int ans = 0;\n        for (int j = 0; j < right.size(); j++) {\n            currMin = right[j];\n            int i = lower_bound(left.begin(), left.end(), currMin) - left.begin();\n            int size = (k + j) - i + 1;\n            ans = max(ans, currMin * size);\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> left(n, -1);\n        vector<int> stack;\n        \n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.empty() && nums[stack.back()] > nums[i]) {\n                left[stack.back()] = i;\n                stack.pop_back();\n            }\n            \n            stack.push_back(i);\n        }\n        \n        vector<int> right(n, n);\n        stack.clear();\n        for (int i = 0; i < n; i++) {\n            while (!stack.empty() && nums[stack.back()] > nums[i]) {\n                right[stack.back()] = i;\n                stack.pop_back();\n            }\n            \n            stack.push_back(i);\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < n; i++) {\n            if (left[i] < k && right[i] > k) {\n                ans = max(ans, nums[i] * (right[i] - left[i] - 1));\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int maximumScore(vector<int>& nums, int k) {\n        int n = nums.size();\n        int left = k;\n        int right = k;\n        int ans = nums[k];\n        int currMin = nums[k];\n        \n        while (left > 0 || right < n - 1) {\n            if ((left > 0 ? nums[left - 1]: 0) < (right < n - 1 ? nums[right + 1] : 0)) {\n                right++;\n                currMin = min(currMin, nums[right]);\n            } else {\n                left--;\n                currMin = min(currMin, nums[left]);\n            }\n            \n            ans = max(ans, currMin * (right - left + 1));\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 9,
    "question": "Can you solve this real interview question? Maximum Value at a Given Index in a Bounded Array - You are given three positive integers: n, index, and maxSum. You want to construct an array nums (0-indexed) that satisfies the following conditions:\n\n * nums.length == n\n * nums[i] is a positive integer where 0 <= i < n.\n * abs(nums[i] - nums[i+1]) <= 1 where 0 <= i < n-1.\n * The sum of all the elements of nums does not exceed maxSum.\n * nums[index] is maximized.\n\nReturn nums[index] of the constructed array.\n\nNote that abs(x) equals x if x >= 0, and -x otherwise.\n\n \n\nExample 1:\n\n\nInput: n = 4, index = 2,  maxSum = 6\nOutput: 2\nExplanation: nums = [1,2,2,1] is one array that satisfies all the conditions.\nThere are no arrays that satisfy all the conditions and have nums[2] == 3, so 2 is the maximum nums[2].\n\n\nExample 2:\n\n\nInput: n = 6, index = 1,  maxSum = 10\nOutput: 3\n\n\n \n\nConstraints:\n\n * 1 <= n <= maxSum <= 109\n * 0 <= index < n",
    "code": "class Solution {\npublic:\n    int maxValue(int n, int index, int maxSum) {\n        \n    }\n};",
    "solution": [
      "class Solution {\n    private long getSum(int index, int value, int n) {\n        long count = 0;\n        \n        // On index's left:\n        // If value > index, there are index + 1 numbers in the arithmetic sequence:\n        // [value - index, ..., value - 1, value].\n        // Otherwise, there are value numbers in the arithmetic sequence:\n        // [1, 2, ..., value - 1, value], plus a sequence of length (index - value + 1) of 1s. \n        if (value > index) {\n            count += (long)(value + value - index) * (index + 1) / 2;\n        } else {\n            count += (long)(value + 1) * value / 2 + index - value + 1;\n        };\n        // On index's right:\n        // If value >= n - index, there are n - index numbers in the arithmetic sequence:\n        // [value, value - 1, ..., value - n + 1 + index].\n        // Otherwise, there are value numbers in the arithmetic sequence:\n        // [value, value - 1, ..., 1], plus a sequence of length (n - index - value) of 1s. \n        if (value >= n - index) {\n            count += (long)(value + value - n + 1 + index) * (n - index) / 2;\n        } else {\n            count += (long)(value + 1) * value / 2 + n - index - value;\n        }   \n        \n        return count - value;\n        \n    }\n    public int maxValue(int n, int index, int maxSum) {\n        int left = 1, right = maxSum;\n        while (left < right) {\n            int mid = (left + right + 1) / 2;\n            if (getSum(index, mid, n) <= maxSum) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        return left;\n    }\n}"
    ]
  },
  {
    "number": 10,
    "question": "Can you solve this real interview question? Count Nice Pairs in an Array - You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n\n * 0 <= i < j < nums.length\n * nums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\n\nReturn the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.\n\n \n\nExample 1:\n\n\nInput: nums = [42,11,1,97]\nOutput: 2\nExplanation: The two pairs are:\n - (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n - (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.\n\n\nExample 2:\n\n\nInput: nums = [13,10,35,24,76]\nOutput: 4\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 0 <= nums[i] <= 109",
    "code": "class Solution {\npublic:\n    int countNicePairs(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int countNicePairs(vector<int>& nums) {\n        vector<int> arr;\n        for (int i = 0; i < nums.size(); i++) {\n            arr.push_back(nums[i] - rev(nums[i]));\n        }\n        \n        unordered_map<int, int> dic;\n        int ans = 0;\n        int MOD = 1e9 + 7;\n        for (int num : arr) {\n            ans = (ans + dic[num]) % MOD;\n            dic[num]++;\n        }\n        \n        return ans;\n    }\n    \n    int rev(int num) {\n        int result = 0;\n        while (num > 0) {\n            result = result * 10 + num % 10;\n            num /= 10;\n        }\n        \n        return result;\n    }\n};"
    ]
  },
  {
    "number": 11,
    "question": "Can you solve this real interview question? Sign of the Product of an Array - There is a function signFunc(x) that returns:\n\n * 1 if x is positive.\n * -1 if x is negative.\n * 0 if x is equal to 0.\n\nYou are given an integer array nums. Let product be the product of all values in the array nums.\n\nReturn signFunc(product).\n\n \n\nExample 1:\n\n\nInput: nums = [-1,-2,-3,-4,3,2,1]\nOutput: 1\nExplanation: The product of all values in the array is 144, and signFunc(144) = 1\n\n\nExample 2:\n\n\nInput: nums = [1,5,0,2,-3]\nOutput: 0\nExplanation: The product of all values in the array is 0, and signFunc(0) = 0\n\n\nExample 3:\n\n\nInput: nums = [-1,1,-1,1,-1]\nOutput: -1\nExplanation: The product of all values in the array is -1, and signFunc(-1) = -1\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 1000\n * -100 <= nums[i] <= 100",
    "code": "class Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        int countNegativeNumbers = 0;\n        for (int num : nums) {\n            if (num == 0) {\n                return 0;\n            }\n            if (num < 0) {\n                countNegativeNumbers++;\n            }\n        }\n\n        return countNegativeNumbers % 2 == 0 ? 1 : -1;\n    }\n};",
      "class Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        int sign = 1;\n        for (int num : nums) {\n            if (num == 0) {\n                return 0;\n            }\n            if (num < 0) {\n                sign = -1 * sign;\n            }\n        }\n\n        return sign;\n    }\n};"
    ]
  },
  {
    "number": 12,
    "question": "Can you solve this real interview question? Frequency of the Most Frequent Element - The frequency of an element is the number of times it occurs in an array.\n\nYou are given an integer array nums and an integer k. In one operation, you can choose an index of nums and increment the element at that index by 1.\n\nReturn the maximum possible frequency of an element after performing at most k operations.\n\n \n\nExample 1:\n\n\nInput: nums = [1,2,4], k = 5\nOutput: 3\nExplanation: Increment the first element three times and the second element two times to make nums = [4,4,4].\n4 has a frequency of 3.\n\nExample 2:\n\n\nInput: nums = [1,4,8,13], k = 5\nOutput: 2\nExplanation: There are multiple optimal solutions:\n- Increment the first element three times to make nums = [4,4,8,13]. 4 has a frequency of 2.\n- Increment the second element four times to make nums = [1,8,8,13]. 8 has a frequency of 2.\n- Increment the third element five times to make nums = [1,4,13,13]. 13 has a frequency of 2.\n\n\nExample 3:\n\n\nInput: nums = [3,9,6], k = 2\nOutput: 1\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 105\n * 1 <= nums[i] <= 105\n * 1 <= k <= 105",
    "code": "class Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int left = 0;\n        int ans = 0;\n        long curr = 0;\n        \n        for (int right = 0; right < nums.size(); right++) {\n            long target = nums[right];\n            curr += target;\n            \n            while ((right - left + 1) * target - curr > k) {\n                curr -= nums[left];\n                left++;\n            }\n            \n            ans = max(ans, right - left + 1);\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int maxFrequency(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        int left = 0;\n        long curr = 0;\n        \n        for (int right = 0; right < nums.size(); right++) {\n            long target = nums[right];\n            curr += target;\n            \n            if ((right - left + 1) * target - curr > k) {\n                curr -= nums[left];\n                left++;\n            }\n        }\n        \n        return nums.size() - left;\n    }\n};",
      "class Solution {\npublic:\n    int check(int i, int k, vector<int>& nums, vector<long>& prefix) {\n        int target = nums[i];\n        int left = 0;\n        int right = i;\n        int best = i;\n        \n        while (left <= right) {\n            int mid = (left + right) / 2;\n            long count = i - mid + 1;\n            long finalSum = count * target;\n            int originalSum = prefix[i] - prefix[mid] + nums[mid];\n            int operationsRequired = finalSum - originalSum;\n            \n            if (operationsRequired > k) {\n                left = mid + 1;\n            } else {\n                best = mid;\n                right = mid - 1;\n            }\n        }\n        \n        return i - best + 1;\n    }\n    \n    int maxFrequency(vector<int>& nums, int k) {\n        sort(nums.begin(), nums.end());\n        vector<long> prefix;\n        prefix.push_back(nums[0]);\n        \n        for (int i = 1; i < nums.size(); i++) {\n            prefix.push_back(nums[i] + prefix.back());\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            ans = max(ans, check(i, k, nums, prefix));\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 13,
    "question": "Can you solve this real interview question? Seat Reservation Manager - Design a system that manages the reservation state of n seats that are numbered from 1 to n.\n\nImplement the SeatManager class:\n\n * SeatManager(int n) Initializes a SeatManager object that will manage n seats numbered from 1 to n. All seats are initially available.\n * int reserve() Fetches the smallest-numbered unreserved seat, reserves it, and returns its number.\n * void unreserve(int seatNumber) Unreserves the seat with the given seatNumber.\n\n \n\nExample 1:\n\n\nInput\n[\"SeatManager\", \"reserve\", \"reserve\", \"unreserve\", \"reserve\", \"reserve\", \"reserve\", \"reserve\", \"unreserve\"]\n[[5], [], [], [2], [], [], [], [], [5]]\nOutput\n[null, 1, 2, null, 2, 3, 4, 5, null]\n\nExplanation\nSeatManager seatManager = new SeatManager(5); // Initializes a SeatManager with 5 seats.\nseatManager.reserve();    // All seats are available, so return the lowest numbered seat, which is 1.\nseatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.\nseatManager.unreserve(2); // Unreserve seat 2, so now the available seats are [2,3,4,5].\nseatManager.reserve();    // The available seats are [2,3,4,5], so return the lowest of them, which is 2.\nseatManager.reserve();    // The available seats are [3,4,5], so return the lowest of them, which is 3.\nseatManager.reserve();    // The available seats are [4,5], so return the lowest of them, which is 4.\nseatManager.reserve();    // The only available seat is seat 5, so return 5.\nseatManager.unreserve(5); // Unreserve seat 5, so now the available seats are [5].\n\n\n \n\nConstraints:\n\n * 1 <= n <= 105\n * 1 <= seatNumber <= n\n * For each call to reserve, it is guaranteed that there will be at least one unreserved seat.\n * For each call to unreserve, it is guaranteed that seatNumber will be reserved.\n * At most 105 calls in total will be made to reserve and unreserve.",
    "code": "class SeatManager {\npublic:\n    SeatManager(int n) {\n        \n    }\n    \n    int reserve() {\n        \n    }\n    \n    void unreserve(int seatNumber) {\n        \n    }\n};\n\n/**\n * Your SeatManager object will be instantiated and called \nas such:\n * SeatManager* obj = new SeatManager(n);\n * int param_1 = obj->reserve();\n * obj->unreserve(seatNumber);\n */",
    "solution": [
      "class SeatManager {\n    // Min heap to store all unreserved seats.\n    priority_queue<int, vector<int>, greater<int>> availableSeats;\n\npublic:\n    SeatManager(int n) {\n        // Initially all seats are unreserved.\n        for (int seatNumber = 1; seatNumber <= n; ++seatNumber) {\n            availableSeats.push(seatNumber);\n        }\n    }\n\n    int reserve() {\n        // Get the smallest-numbered unreserved seat from the min heap.\n        int seatNumber = availableSeats.top();\n        availableSeats.pop();\n        return seatNumber;\n    }\n\n    void unreserve(int seatNumber) {\n        // Push the unreserved seat in the min heap.\n        availableSeats.push(seatNumber);\n    }\n};",
      "class SeatManager {\n    // Marker to point to unreserved seats.\n    int marker;\n\n    // Min heap to store all unreserved seats.\n    priority_queue<int, vector<int>, greater<int>> availableSeats;\n\npublic:\n    SeatManager(int n) {\n        // Set marker to the first unreserved seat.\n        marker = 1;\n    }\n\n    int reserve() {\n        // If min-heap has any element in it, then,\n        // get the smallest-numbered unreserved seat from the min heap.\n        if (!availableSeats.empty()) {\n            int seatNumber = availableSeats.top();\n            availableSeats.pop();\n            return seatNumber;\n        }\n\n        // Otherwise, the marker points to the smallest-numbered seat.\n        int seatNumber = marker;\n        marker++;\n        return seatNumber;\n    }\n\n    void unreserve(int seatNumber) {\n        // Push unreserved seat in the min heap.\n        availableSeats.push(seatNumber);\n    }\n};",
      "class SeatManager {\n    // Marker to point to unreserved seats.\n    int marker;\n\n    // Sorted set to store all unreserved seats.\n    set<int> availableSeats;\n\npublic:\n    SeatManager(int n) {\n        // Set marker to the first unreserved seat.\n        marker = 1;\n    }\n\n    int reserve() {\n        // If the sorted set has any element in it, then,\n        // get the smallest-numbered unreserved seat from it.\n        if (!availableSeats.empty()) {\n            int seatNumber = *availableSeats.begin();\n            availableSeats.erase(availableSeats.begin());\n            return seatNumber;\n        }\n\n        // Otherwise, the marker points to the smallest-numbered seat.\n        int seatNumber = marker;\n        marker++;\n        return seatNumber;\n    }\n\n    void unreserve(int seatNumber) {\n        // Push unreserved seat in the sorted set.\n        availableSeats.insert(seatNumber);\n    }\n};"
    ]
  },
  {
    "number": 14,
    "question": "Can you solve this real interview question? Maximum Element After Decreasing and Rearranging - You are given an array of positive integers arr. Perform some operations (possibly none) on arr so that it satisfies these conditions:\n\n * The value of the first element in arr must be 1.\n * The absolute difference between any 2 adjacent elements must be less than or equal to 1. In other words, abs(arr[i] - arr[i - 1]) <= 1 for each i where 1 <= i < arr.length (0-indexed). abs(x) is the absolute value of x.\n\nThere are 2 types of operations that you can perform any number of times:\n\n * Decrease the value of any element of arr to a smaller positive integer.\n * Rearrange the elements of arr to be in any order.\n\nReturn the maximum possible value of an element in arr after performing the operations to satisfy the conditions.\n\n \n\nExample 1:\n\n\nInput: arr = [2,2,1,2,1]\nOutput: 2\nExplanation: \nWe can satisfy the conditions by rearranging arr so it becomes [1,2,2,2,1].\nThe largest element in arr is 2.\n\n\nExample 2:\n\n\nInput: arr = [100,1,1000]\nOutput: 3\nExplanation: \nOne possible way to satisfy the conditions is by doing the following:\n1. Rearrange arr so it becomes [1,100,1000].\n2. Decrease the value of the second element to 2.\n3. Decrease the value of the third element to 3.\nNow arr = [1,2,3], which satisfies the conditions.\nThe largest element in arr is 3.\n\n\nExample 3:\n\n\nInput: arr = [1,2,3,4,5]\nOutput: 5\nExplanation: The array already satisfies the conditions, and the largest element is 5.\n\n\n \n\nConstraints:\n\n * 1 <= arr.length <= 105\n * 1 <= arr[i] <= 109",
    "code": "class Solution {\npublic:\n    int maximumElementAfterDecrementingAndRearranging\n(vector<int>& arr) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {\n        sort(arr.begin(), arr.end());\n        int ans = 1;\n        \n        for (int i = 1; i < arr.size(); i++) {\n            if (arr[i] >= ans + 1) {\n                ans++;\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int maximumElementAfterDecrementingAndRearranging(vector<int>& arr) {\n        int n = arr.size();\n        vector<int> counts = vector(n + 1, 0);\n        \n        for (int num : arr) {\n            counts[min(num, n)]++;\n        }\n        \n        int ans = 1;\n        for (int num = 2; num <= n; num++) {\n            ans = min(ans + counts[num], num);\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 15,
    "question": "Can you solve this real interview question? Minimize Maximum Pair Sum in Array - The pair sum of a pair (a,b) is equal to a + b. The maximum pair sum is the largest pair sum in a list of pairs.\n\n * For example, if we have pairs (1,5), (2,3), and (4,4), the maximum pair sum would be max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8.\n\nGiven an array nums of even length n, pair up the elements of nums into n / 2 pairs such that:\n\n * Each element of nums is in exactly one pair, and\n * The maximum pair sum is minimized.\n\nReturn the minimized maximum pair sum after optimally pairing up the elements.\n\n \n\nExample 1:\n\n\r\nInput: nums = [3,5,2,3]\r\nOutput: 7\r\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\r\n\n\nExample 2:\n\n\r\nInput: nums = [3,5,4,2,4,6]\r\nOutput: 8\r\nExplanation: The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\r\n\n\n \n\nConstraints:\n\n * n == nums.length\n * 2 <= n <= 105\n * n is even.\n * 1 <= nums[i] <= 105",
    "code": "class Solution {\npublic:\n    int minPairSum(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int minPairSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        \n        int maxSum = 0;\n        for (int i = 0; i < nums.size() / 2; i++) {\n            maxSum = max(maxSum, nums[i] + nums[nums.size() - 1 - i]);\n        }\n        \n        return maxSum;\n    }\n};"
    ]
  },
  {
    "number": 16,
    "question": "Can you solve this real interview question? Reduction Operations to Make the Array Elements Equal - Given an integer array nums, your goal is to make all elements in nums equal. To complete one operation, follow these steps:\n\n 1. Find the largest value in nums. Let its index be i (0-indexed) and its value be largest. If there are multiple elements with the largest value, pick the smallest i.\n 2. Find the next largest value in nums strictly smaller than largest. Let its value be nextLargest.\n 3. Reduce nums[i] to nextLargest.\n\nReturn the number of operations to make all elements in nums equal.\n\n \n\nExample 1:\n\n\nInput: nums = [5,1,3]\nOutput: 3\nExplanation: It takes 3 operations to make all elements in nums equal:\n1. largest = 5 at index 0. nextLargest = 3. Reduce nums[0] to 3. nums = [3,1,3].\n2. largest = 3 at index 0. nextLargest = 1. Reduce nums[0] to 1. nums = [1,1,3].\n3. largest = 3 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1].\n\n\nExample 2:\n\n\nInput: nums = [1,1,1]\nOutput: 0\nExplanation: All elements in nums are already equal.\n\n\nExample 3:\n\n\nInput: nums = [1,1,2,2,3]\nOutput: 4\nExplanation: It takes 4 operations to make all elements in nums equal:\n1. largest = 3 at index 4. nextLargest = 2. Reduce nums[4] to 2. nums = [1,1,2,2,2].\n2. largest = 2 at index 2. nextLargest = 1. Reduce nums[2] to 1. nums = [1,1,1,2,2].\n3. largest = 2 at index 3. nextLargest = 1. Reduce nums[3] to 1. nums = [1,1,1,1,2].\n4. largest = 2 at index 4. nextLargest = 1. Reduce nums[4] to 1. nums = [1,1,1,1,1].\n\n\n \n\nConstraints:\n\n * 1 <= nums.length <= 5 * 104\n * 1 <= nums[i] <= 5 * 104",
    "code": "class Solution {\npublic:\n    int reductionOperations(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int reductionOperations(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        int ans = 0;\n        int up = 0;\n        \n        for (int i = 1; i < nums.size(); i++) {\n            if (nums[i] != nums[i - 1]) {\n                up++;\n            }\n            \n            ans += up;\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 17,
    "question": "Can you solve this real interview question? Redistribute Characters to Make All Strings Equal - You are given an array of strings words (0-indexed).\n\nIn one operation, pick two distinct indices i and j, where words[i] is a non-empty string, and move any character from words[i] to any position in words[j].\n\nReturn true if you can make every string in words equal using any number of operations, and false otherwise.\n\n \n\nExample 1:\n\n\nInput: words = [\"abc\",\"aabc\",\"bc\"]\nOutput: true\nExplanation: Move the first 'a' in words[1] to the front of words[2],\nto make words[1] = \"abc\" and words[2] = \"abc\".\nAll the strings are now equal to \"abc\", so return true.\n\n\nExample 2:\n\n\nInput: words = [\"ab\",\"a\"]\nOutput: false\nExplanation: It is impossible to make all the strings equal using the operation.\n\n\n \n\nConstraints:\n\n * 1 <= words.length <= 100\n * 1 <= words[i].length <= 100\n * words[i] consists of lowercase English letters.",
    "code": "class Solution {\npublic:\n    bool makeEqual(vector<string>& words) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    bool makeEqual(vector<string>& words) {\n        unordered_map<char, int> counts;\n        for (string word : words) {\n            for (char c : word) {\n                counts[c]++;\n            }\n        }\n        \n        int n = words.size();\n        for (auto& [key, val] : counts) {\n            if (val % n != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};",
      "class Solution:\n    def makeEqual(self, words: List[str]) -> bool:\n        return not any([val % len(words) for val in collections.Counter(\"\".join(words)).values()])",
      "class Solution {\npublic:\n    bool makeEqual(vector<string>& words) {\n        vector<int> counts(26, 0);\n        for (string word : words) {\n            for (char c : word) {\n                counts[c - 'a']++;\n            }\n        }\n        \n        int n = words.size();\n        for (int val : counts) {\n            if (val % n != 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n};"
    ]
  },
  {
    "number": 18,
    "question": "Can you solve this real interview question? Largest Odd Number in String - You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string \"\" if no odd integer exists.\n\nA substring is a contiguous sequence of characters within a string.\n\n \n\nExample 1:\n\n\nInput: num = \"52\"\nOutput: \"5\"\nExplanation: The only non-empty substrings are \"5\", \"2\", and \"52\". \"5\" is the only odd number.\n\n\nExample 2:\n\n\nInput: num = \"4206\"\nOutput: \"\"\nExplanation: There are no odd numbers in \"4206\".\n\n\nExample 3:\n\n\nInput: num = \"35427\"\nOutput: \"35427\"\nExplanation: \"35427\" is already an odd number.\n\n\n \n\nConstraints:\n\n * 1 <= num.length <= 105\n * num only consists of digits and does not contain any leading zeros.",
    "code": "class Solution {\npublic:\n    string largestOddNumber(string num) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    string largestOddNumber(string num) {\n        for (int i = num.size() - 1; i >= 0; i--) {\n            if ((num[i] - '0') % 2 != 0) {\n                return num.substr(0, i + 1);\n            }\n        }\n        \n        return \"\";\n    }\n};"
    ]
  },
  {
    "number": 19,
    "question": "Can you solve this real interview question? Maximum Product Difference Between Two Pairs - The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\n\n * For example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\n\nGiven an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\n\nReturn the maximum such product difference.\n\n \n\nExample 1:\n\n\r\nInput: nums = [5,6,2,7,4]\r\nOutput: 34\r\nExplanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\r\nThe product difference is (6 * 7) - (2 * 4) = 34.\r\n\n\nExample 2:\n\n\r\nInput: nums = [4,2,5,9,7,4,8]\r\nOutput: 64\r\nExplanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\r\nThe product difference is (9 * 8) - (2 * 4) = 64.\r\n\n\n \n\nConstraints:\n\n * 4 <= nums.length <= 104\n * 1 <= nums[i] <= 104",
    "code": "class Solution {\npublic:\n    int maxProductDifference(vector<int>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int maxProductDifference(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        return nums[nums.size() - 1] * nums[nums.size() - 2] - nums[0] * nums[1];\n    }\n};",
      "class Solution {\npublic:\n    int maxProductDifference(vector<int>& nums) {\n        int biggest = 0;\n        int secondBiggest = 0;\n        int smallest = INT_MAX;\n        int secondSmallest = INT_MAX;\n        \n        for (int num : nums) {\n            if (num > biggest) {\n                secondBiggest = biggest;\n                biggest = num;\n            } else {\n                secondBiggest = max(secondBiggest, num);\n            }\n            \n            if (num < smallest) {\n                secondSmallest = smallest;\n                smallest = num;\n            } else {\n                secondSmallest = min(secondSmallest, num);\n            }\n        }\n        \n        return biggest * secondBiggest - smallest * secondSmallest;\n    }\n};"
    ]
  },
  {
    "number": 20,
    "question": "Can you solve this real interview question? Eliminate Maximum Number of Monsters - You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.\n\nThe monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.\n\nYou have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.\n\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.\n\nReturn the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.\n\n \n\nExample 1:\n\n\nInput: dist = [1,3,4], speed = [1,1,1]\nOutput: 3\nExplanation:\nIn the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are [X,X,2]. You eliminate the thrid monster.\nAll 3 monsters can be eliminated.\n\nExample 2:\n\n\nInput: dist = [1,1,2,3], speed = [1,1,1,1]\nOutput: 1\nExplanation:\nIn the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,1,2], so you lose.\nYou can only eliminate 1 monster.\n\n\nExample 3:\n\n\nInput: dist = [3,2,4], speed = [5,3,2]\nOutput: 1\nExplanation:\nIn the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,2], so you lose.\nYou can only eliminate 1 monster.\n\n\n \n\nConstraints:\n\n * n == dist.length == speed.length\n * 1 <= n <= 105\n * 1 <= dist[i], speed[i] <= 105",
    "code": "class Solution {\npublic:\n    int eliminateMaximum(vector<int>& dist, vector<int>& \nspeed) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n        vector<float> arrival;\n        for (int i = 0; i < dist.size(); i++) {\n            arrival.push_back((float) dist[i] / speed[i]);\n        }\n        \n        sort(arrival.begin(), arrival.end());\n        int ans = 0;\n        \n        for (int i = 0; i < arrival.size(); i++) {\n            if (arrival[i] <= i) {\n                break;\n            }\n            \n            ans++;\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n        priority_queue<float, vector<float>, greater<float>> heap;\n        \n        for (int i = 0; i < dist.size(); i++) {\n            heap.push((float) dist[i] / speed[i]);\n        }\n\n        int ans = 0;\n        while (!heap.empty()) {\n            if (heap.top() <= ans) {\n                break;\n            }\n            \n            ans++;\n            heap.pop();\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 21,
    "question": "Can you solve this real interview question? Unique Length-3 Palindromic Subsequences - Given a string s, return the number of unique palindromes of length three that are a subsequence of s.\n\nNote that even if there are multiple ways to obtain the same subsequence, it is still only counted once.\n\nA palindrome is a string that reads the same forwards and backwards.\n\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n * For example, \"ace\" is a subsequence of \"abcde\".\n\n \n\nExample 1:\n\n\nInput: s = \"aabca\"\nOutput: 3\nExplanation: The 3 palindromic subsequences of length 3 are:\n- \"aba\" (subsequence of \"aabca\")\n- \"aaa\" (subsequence of \"aabca\")\n- \"aca\" (subsequence of \"aabca\")\n\n\nExample 2:\n\n\nInput: s = \"adc\"\nOutput: 0\nExplanation: There are no palindromic subsequences of length 3 in \"adc\".\n\n\nExample 3:\n\n\nInput: s = \"bbcbaba\"\nOutput: 4\nExplanation: The 4 palindromic subsequences of length 3 are:\n- \"bbb\" (subsequence of \"bbcbaba\")\n- \"bcb\" (subsequence of \"bbcbaba\")\n- \"bab\" (subsequence of \"bbcbaba\")\n- \"aba\" (subsequence of \"bbcbaba\")\n\n\n \n\nConstraints:\n\n * 3 <= s.length <= 105\n * s consists of only lowercase English letters.",
    "code": "class Solution {\npublic:\n    int countPalindromicSubsequence(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int countPalindromicSubsequence(string s) {\n        unordered_set<char> letters;\n        for (char c : s) {\n            letters.insert(c);\n        }\n        \n        int ans = 0;\n        for (char letter : letters) {\n            int i = -1;\n            int j = 0;\n            \n            for (int k = 0; k < s.size(); k++) {\n                if (s[k] == letter) {\n                    if (i == -1) {\n                        i = k;\n                    }\n                    \n                    j = k;\n                }\n            }\n            \n            unordered_set<char> between;\n            for (int k = i + 1; k < j; k++) {\n                between.insert(s[k]);\n            }\n            \n            ans += between.size();\n        }\n        \n        return ans;\n    }\n};\n\n",
      "class Solution:\n    def countPalindromicSubsequence(self, s: str) -> int:\n        return sum([len(set(s[s.index(letter)+1:s.rindex(letter)])) for letter in set(s)])",
      "class Solution {\npublic:\n    int countPalindromicSubsequence(string s) {\n        vector<int> first = vector(26, -1);\n        vector<int> last = vector(26, -1);\n        \n        for (int i = 0; i < s.size(); i++) {\n            int curr = s[i] - 'a';\n            if (first[curr] == - 1) {\n                first[curr] = i;\n            }\n            \n            last[curr] = i;\n        }\n        \n        int ans = 0;\n        for (int i = 0; i < 26; i++) {\n            if (first[i] == -1) {\n                continue;\n            }\n            \n            unordered_set<char> between;\n            for (int j = first[i] + 1; j < last[i]; j++) {\n                between.insert(s[j]);\n            }\n            \n            ans += between.size();\n        }\n        \n        return ans;\n    }\n};"
    ]
  },
  {
    "number": 22,
    "question": "Can you solve this real interview question? Maximum Number of Points with Cost - You are given an m x n integer matrix points (0-indexed). Starting with 0 points, you want to maximize the number of points you can get from the matrix.\n\nTo gain points, you must pick one cell in each row. Picking the cell at coordinates (r, c) will add points[r][c] to your score.\n\nHowever, you will lose points if you pick a cell too far from the cell that you picked in the previous row. For every two adjacent rows r and r + 1 (where 0 <= r < m - 1), picking cells at coordinates (r, c1) and (r + 1, c2) will subtract abs(c1 - c2) from your score.\n\nReturn the maximum number of points you can achieve.\n\nabs(x) is defined as:\n\n * x for x >= 0.\n * -x for x < 0.\n\n \n\nExample 1:\n\n[https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-40-26-diagram-drawio-diagrams-net.png]\n\n\nInput: points = [[1,2,3],[1,5,1],[3,1,1]]\nOutput: 9\nExplanation:\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 2), (1, 1), and (2, 0).\nYou add 3 + 5 + 3 = 11 to your score.\nHowever, you must subtract abs(2 - 1) + abs(1 - 0) = 2 from your score.\nYour final score is 11 - 2 = 9.\n\n\nExample 2:\n\n[https://assets.leetcode.com/uploads/2021/07/12/screenshot-2021-07-12-at-13-42-14-diagram-drawio-diagrams-net.png]\n\n\nInput: points = [[1,5],[2,3],[4,2]]\nOutput: 11\nExplanation:\nThe blue cells denote the optimal cells to pick, which have coordinates (0, 1), (1, 1), and (2, 0).\nYou add 5 + 3 + 4 = 12 to your score.\nHowever, you must subtract abs(1 - 1) + abs(1 - 0) = 1 from your score.\nYour final score is 12 - 1 = 11.\n\n\n \n\nConstraints:\n\n * m == points.length\n * n == points[r].length\n * 1 <= m, n <= 105\n * 1 <= m * n <= 105\n * 0 <= points[r][c] <= 105",
    "code": "class Solution {\npublic:\n    long long maxPoints(vector<vector<int>>& points) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    long long maxPoints(vector<vector<int>>& points) {\n        const int n = int(points[0].size());\n        vector<vector<long long>> dp(2, vector<long long>(n));\n        for (int i = 0; i < n; ++i) {\n            dp[0][i] = points[0][i];\n        }\n        int last = 0;\n        for (int i = 1; i < points.size(); ++i) {\n            int now = last ^ 1;\n            long long temp = 0;\n            for (int j = 0; j < n; ++j) {\n                temp = max(temp, dp[last][j] + j);\n                dp[now][j] = temp - j + points[i][j];\n            }\n            temp = -n;\n            for (int j = n - 1; j >= 0; --j) {\n                temp = max(temp, dp[last][j] - j);\n                dp[now][j] = max(dp[now][j], temp + j + points[i][j]);\n            }\n            last = now;\n        }\n        return *max_element(dp[last].begin(), dp[last].end());\n    }\n};\n"
    ]
  },
  {
    "number": 23,
    "question": "Can you solve this real interview question? Find Unique Binary String - Given an array of strings nums containing n unique binary strings each of length n, return a binary string of length n that does not appear in nums. If there are multiple answers, you may return any of them.\n\n \n\nExample 1:\n\n\nInput: nums = [\"01\",\"10\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"00\" would also be correct.\n\n\nExample 2:\n\n\nInput: nums = [\"00\",\"01\"]\nOutput: \"11\"\nExplanation: \"11\" does not appear in nums. \"10\" would also be correct.\n\n\nExample 3:\n\n\nInput: nums = [\"111\",\"011\",\"001\"]\nOutput: \"101\"\nExplanation: \"101\" does not appear in nums. \"000\", \"010\", \"100\", and \"110\" would also be correct.\n\n\n \n\nConstraints:\n\n * n == nums.length\n * 1 <= n <= 16\n * nums[i].length == n\n * nums[i] is either '0' or '1'.\n * All the strings of nums are unique.",
    "code": "class Solution {\npublic:\n    string findDifferentBinaryString(vector<string>& nums) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int n;\n    unordered_set<string> numsSet;\n    \n    string generate(string curr) {\n        if (curr.size() == n) {\n            if (numsSet.find(curr) == numsSet.end()) {\n                return curr;\n            }\n            \n            return \"\";\n        }\n        \n        string addZero = generate(curr + \"0\");\n        if (addZero.size() > 0) {\n            return addZero;\n        }\n        \n        return generate(curr + \"1\");\n    }\n    \n    string findDifferentBinaryString(vector<string>& nums) {\n        n = nums.size();\n        for (string s : nums) {\n            numsSet.insert(s);\n        }\n        \n        return generate(\"\");\n    }\n};",
      "class Solution {\npublic:\n    string findDifferentBinaryString(vector<string>& nums) {\n        unordered_set<int> integers;\n        for (string num : nums) {\n            integers.insert(stoi(num, 0, 2));\n        }\n        \n        int n = nums.size();\n        for (int num = 0; num <= n; num++) {\n            if (integers.find(num) == integers.end()) {\n                string ans = bitset<16>(num).to_string();\n                return ans.substr(16 - n);\n            }\n        }\n        \n        return \"\";\n    }\n};",
      "class Solution {\npublic:\n    string findDifferentBinaryString(vector<string>& nums) {\n        unordered_set<int> integers;\n        for (string num : nums) {\n            integers.insert(stoi(num, 0, 2));\n        }\n        \n        int ans = stoi(nums[0], 0, 2);\n        int n = nums.size();\n        \n        while (integers.find(ans) != integers.end()) {\n            ans = rand() % (int) pow(2, n);\n        }\n        \n        return bitset<16>(ans).to_string().substr(16 - n);\n    }\n};",
      "class Solution {\npublic:\n    string findDifferentBinaryString(vector<string>& nums) {\n        string ans;\n        for (int i = 0; i < nums.size(); i++) {\n            char curr = nums[i][i];\n            ans += curr == '0' ? '1' : '0';\n        }\n        \n        return ans;\n    }\n};"
    ]
  }
]