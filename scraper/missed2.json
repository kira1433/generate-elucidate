[
  {
    "number": 1,
    "question": "Can you solve this real interview question? Compact Object - Given an object or array obj, return a compact object. A compact object is the same as the original object, except with keys containing falsy values removed. This operation applies to the object and any nested objects. Arrays are considered objects where the indices are keys. A value is considered falsy when Boolean(value) returns false.\n\nYou may assume the obj is the output of JSON.parse. In other words, it is valid JSON.\n\n \n\nExample 1:\n\n\nInput: obj = [null, 0, false, 1]\nOutput: [1]\nExplanation: All falsy values have been removed from the array.\n\n\nExample 2:\n\n\nInput: obj = {\"a\": null, \"b\": [false, 1]}\nOutput: {\"b\": [1]}\nExplanation: obj[\"a\"] and obj[\"b\"][0] had falsy values and were removed.\n\nExample 3:\n\n\nInput: obj = [null, 0, 5, [0], [false, 16]]\nOutput: [5, [], [16]]\nExplanation: obj[0], obj[1], obj[3][0], and obj[4][0] were falsy and removed.\n\n\n \n\nConstraints:\n\n * obj is a valid JSON object\n * 2 <= JSON.stringify(obj).length <= 106",
    "code": "/**\n * @param {Object|Array} obj\n * @return {Object|Array}\n */\nvar compactObject = function(obj) {\n    \n};",
    "solution": [
      "var compactObject = function(obj) {\n  function dfs(obj) {\n      if (!obj) return false;\n      if (typeof obj !== 'object') return obj;\n\n      if (Array.isArray(obj)) {\n          const newArr = [];\n          for(let i = 0; i < obj.length; i++) {\n              const curr = obj[i];\n              const subRes = dfs(curr);\n\n              if(subRes) {\n                  newArr.push(subRes);\n              }\n          }\n\n          return newArr;\n      }\n\n      const newObj = {};\n\n      for (const key in obj) {\n          const subRes = dfs(obj[key])\n          if (subRes) {\n              newObj[key] = subRes;\n          }\n      }\n\n      return newObj;\n  }  \n\n  return dfs(obj);\n};\n",
      "function compactObject(obj) {\n    const stack = [[obj, Array.isArray(obj) ? [] : {}]];\n    let newObj = stack[0][1];\n\n    while (stack.length > 0) {\n        const [currObj, newCurrObj] = stack.pop();\n\n        for (const key in currObj) {\n            const val = currObj[key];\n\n            if (!val) continue;\n            \n            if (typeof val !== 'object') {\n                Array.isArray(newCurrObj) ? newCurrObj.push(val) : newCurrObj[key] = val;\n                continue;\n            }\n\n            const newSubObj = Array.isArray(val) ? [] : {};\n            Array.isArray(newCurrObj) ? newCurrObj.push(newSubObj) : newCurrObj[key] = newSubObj;\n            stack.push([val, newSubObj]);\n        }\n    }\n\n    return newObj;\n}\n"
    ]
  },
  {
    "number": 2,
    "question": "Can you solve this real interview question? Extra Characters in a String - You are given a 0-indexed string s and a dictionary of words dictionary. You have to break s into one or more non-overlapping substrings such that each substring is present in dictionary. There may be some extra characters in s which are not present in any of the substrings.\n\nReturn the minimum number of extra characters left over if you break up s optimally.\n\n \n\nExample 1:\n\n\nInput: s = \"leetscode\", dictionary = [\"leet\",\"code\",\"leetcode\"]\nOutput: 1\nExplanation: We can break s in two substrings: \"leet\" from index 0 to 3 and \"code\" from index 5 to 8. There is only 1 unused character (at index 4), so we return 1.\n\n\n\nExample 2:\n\n\nInput: s = \"sayhelloworld\", dictionary = [\"hello\",\"world\"]\nOutput: 3\nExplanation: We can break s in two substrings: \"hello\" from index 3 to 7 and \"world\" from index 8 to 12. The characters at indices 0, 1, 2 are not used in any substring and thus are considered as extra characters. Hence, we return 3.\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 50\n * 1 <= dictionary.length <= 50\n * 1 <= dictionary[i].length <= 50\n * dictionary[i] and s consists of only lowercase English letters\n * dictionary contains distinct words",
    "code": "class Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    int minExtraChar(string s, vector<string> dictionary) {\n        int n = s.length();\n        unordered_set<string> dictionarySet(dictionary.begin(), dictionary.end());\n        unordered_map<int, int> memo;\n\n        function<int(int)> dp = [&](int start) {\n            if (start == n) {\n                return 0;\n            }\n            if (memo.count(start)) {\n                return memo[start];\n            }\n            // To count this character as a left over character \n            // move to index 'start + 1'\n            int ans = dp(start + 1) + 1;\n            for (int end = start; end < n; end++) {\n                auto curr = s.substr(start, end - start + 1);\n                if (dictionarySet.count(curr)) {\n                    ans = min(ans, dp(end + 1));\n                }\n            }\n\n            return memo[start] = ans;\n        };\n\n        return dp(0);\n    }\n};",
      "class Solution {\npublic:\n    int minExtraChar(string s, vector<string> dictionary) {\n        int n = s.length();\n        unordered_set<string> dictionarySet(dictionary.begin(), dictionary.end());\n        vector<int> dp(n + 1, 0);\n\n        for (int start = n - 1; start >= 0; start--) {\n            dp[start] = dp[start + 1] + 1;\n            for (int end = start; end < n; end++) {\n                auto curr = s.substr(start, end - start + 1);\n                if (dictionarySet.count(curr)) {\n                    dp[start] = min(dp[start], dp[end + 1]);\n                }\n            }\n        }\n\n        return dp[0];\n    }\n};",
      "class TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool is_word;\n};\n\nclass Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = s.length();\n        auto root = buildTrie(dictionary);\n        unordered_map<int, int> memo;\n\n        function<int(int)> dp = [&](int start) {\n            if (start == n) {\n                return 0;\n            }\n            if (memo.count(start)) {\n                return memo[start];\n            }\n            // To count this character as a left over character \n            // move to index 'start + 1'\n            int ans = dp(start + 1) + 1;\n            TrieNode* node = root;\n            for (int end = start; end < n; end++) {\n                char c = s[end];\n                if (node->children.find(c) == node->children.end()) {\n                    break;\n                }\n                node = node->children[c];\n                if (node->is_word) {\n                    ans = min(ans, dp(end + 1));\n                }\n            }\n\n            return memo[start] = ans;\n        };\n\n        return dp(0);\n    }\n\n    TrieNode* buildTrie(vector<string>& dictionary) {\n        auto root = new TrieNode();\n        for (auto& word : dictionary) {\n            auto node = root;\n            for (auto& c : word) {\n                if (node->children.find(c) == node->children.end()) {\n                    node->children[c] = new TrieNode();\n                }\n                node = node->children[c];\n            }\n            node->is_word = true;\n        }\n        return root;\n    }\n};",
      "class TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool is_word;\n};\n\nclass Solution {\npublic:\n    int minExtraChar(string s, vector<string>& dictionary) {\n        int n = s.length();\n        auto root = buildTrie(dictionary);\n        vector<int> dp(n + 1, 0);\n\n        for (int start = n - 1; start >= 0; start--) {\n            dp[start] = dp[start + 1] + 1;\n            auto node = root;\n            for (int end = start; end < n; end++) {\n                if (node->children.find(s[end]) == node->children.end()) {\n                    break;\n                }\n                node = node->children[s[end]];\n                if (node->is_word) {\n                    dp[start] = min(dp[start], dp[end + 1]);\n                }\n            }\n        }\n\n        return dp[0];\n    }\n\n    TrieNode* buildTrie(vector<string>& dictionary) {\n        auto root = new TrieNode();\n        for (auto& word : dictionary) {\n            auto node = root;\n            for (auto& c : word) {\n                if (node->children.find(c) == node->children.end()) {\n                    node->children[c] = new TrieNode();\n                }\n                node = node->children[c];\n            }\n            node->is_word = true;\n        }\n        return root;\n    }\n};"
    ]
  },
  {
    "number": 3,
    "question": "Can you solve this real interview question? Timeout Cancellation - Given a function fn, an array of arguments args, and a timeout t in milliseconds, return a cancel function cancelFn.\n\nAfter a delay of t, fn should be called with args passed as parameters unless cancelFn was invoked before the delay of t milliseconds elapses, specifically at cancelT ms. In that case, fn should never be called.\n\n \n\nExample 1:\n\n\nInput: fn = (x) => x * 5, args = [2], t = 20, cancelT = 50\nOutput: [{\"time\": 20, \"returned\": 10}]\nExplanation: \nconst result = []\n\nconst fn = (x) => x * 5\n\nconst start = performance.now() \n\nconst log = (...argsArr) => {\n    const diff = Math.floor(performance.now() - start);\n    result.push({\"time\": diff, \"returned\": fn(...argsArr)})\n}\n     \nconst cancel = cancellable(log, [2], 20);\n\nconst maxT = Math.max(t, 50)\n          \nsetTimeout(cancel, cancelT)\n\nsetTimeout(() => {\n     console.log(result) // [{\"time\":20,\"returned\":10}]\n}, 65)\n\nThe cancellation was scheduled to occur after a delay of cancelT (50ms), which happened after the execution of fn(2) at 20ms.\n\n\nExample 2:\n\n\nInput: fn = (x) => x**2, args = [2], t = 100, cancelT = 50 \nOutput: []\nExplanation: The cancellation was scheduled to occur after a delay of cancelT (50ms), which happened before the execution of fn(2) at 100ms, resulting in fn(2) never being called.\n\n\nExample 3:\n\n\nInput: fn = (x1, x2) => x1 * x2, args = [2,4], t = 30, cancelT = 100\nOutput: [{\"time\": 30, \"returned\": 8}]\nExplanation: The cancellation was scheduled to occur after a delay of cancelT (100ms), which happened after the execution of fn(2,4) at 30ms.\n\n\n \n\nConstraints:\n\n * fn is a function\n * args is a valid JSON array\n * 1 <= args.length <= 10\n * 20 <= t <= 1000\n * 10 <= cancelT <= 1000",
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    \n};\n\n/**\n *  const result = []\n *\n *  const fn = (x) => x * 5\n *  const args = [2], t = 20, cancelT = 50\n *\n *  const start = performance.now() \n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...\nargsArr)})\n *  }\n *       \n *  const cancel = cancellable(log, args, t);",
    "solution": [
      "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n  const timeoutId = setTimeout(function() {\n    fn.apply(null, args);\n  }, t);\n\n  const cancelFn = function() {\n    clearTimeout(timeoutId);\n  };\n\n  return cancelFn;\n};",
      "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n  let isCancelled = false;\n  setTimeout(() => {\n      if(!isCancelled)\n          fn(...args);\n  }, t);\n\n  return () => {\n    isCancelled = true;\n  };\n};"
    ]
  },
  {
    "number": 4,
    "question": "Can you solve this real interview question? Execute Asynchronous Functions in Parallel - Given an array of asynchronous functions functions, return a new promise promise. Each function in the array accepts no arguments and returns a promise. All the promises should be executed in parallel.\n\npromise resolves:\n\n * When all the promises returned from functions were resolved successfully in parallel. The resolved value of promise should be an array of all the resolved values of promises in the same order as they were in the functions. The promise should resolve when all the asynchronous functions in the array have completed execution in parallel.\n\npromise rejects:\n\n * When any of the promises returned from functions were rejected. promise should also reject with the reason of the first rejection.\n\nPlease solve it without using the built-in Promise.all function.\n\n \n\nExample 1:\n\n\nInput: functions = [\n  () => new Promise(resolve => setTimeout(() => resolve(5), 200))\n]\nOutput: {\"t\": 200, \"resolved\": [5]}\nExplanation: \npromiseAll(functions).then(console.log); // [5]\n\nThe single function was resolved at 200ms with a value of 5.\n\n\nExample 2:\n\n\nInput: functions = [\n    () => new Promise(resolve => setTimeout(() => resolve(1), 200)), \n    () => new Promise((resolve, reject) => setTimeout(() => reject(\"Error\"), 100))\n]\nOutput: {\"t\": 100, \"rejected\": \"Error\"}\nExplanation: Since one of the promises rejected, the returned promise also rejected with the same error at the same time.\n\n\nExample 3:\n\n\nInput: functions = [\n    () => new Promise(resolve => setTimeout(() => resolve(4), 50)), \n    () => new Promise(resolve => setTimeout(() => resolve(10), 150)), \n    () => new Promise(resolve => setTimeout(() => resolve(16), 100))\n]\nOutput: {\"t\": 150, \"resolved\": [4, 10, 16]}\nExplanation: All the promises resolved with a value. The returned promise resolved when the last promise resolved.\n\n\n \n\nConstraints:\n\n * functions is an array of functions that returns promises\n * 1 <= functions.length <= 10",
    "code": "/**\n * @param {Array<Function>} functions\n * @return {Promise<any>}\n */\nvar promiseAll = function(functions) {\n    \n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res\n(42))])\n * promise.then(console.log); // [42]\n */",
    "solution": [
      "var promiseAll = async function(functions) {\n    return new Promise((resolve,reject) => {\n        if(functions.length === []) {\n            resolve([]);\n            return;\n        }\n        \n        const res = new Array(functions.length).fill(null);\n\n        let resolvedCount = 0;\n\n        functions.forEach(async (el,idx) => {\n            try {\n                const subResult = await el();\n                res[idx] = subResult;\n                resolvedCount++;\n                if(resolvedCount=== functions.length) {\n                    resolve(res);\n                }\n            } catch(err) {\n                reject(err);\n            }\n        });\n    });\n};",
      "var promiseAll = function(functions) {\n    return new Promise((resolve, reject) => {\n        if(functions.length === []) {\n            resolve([]);\n            return;\n        }\n        \n        const res = new Array(functions.length).fill(null);\n\n        let resolvedCount = 0;\n\n        functions.forEach((el, idx) => {\n            el().then((subResult) => {\n                res[idx] = subResult;\n                resolvedCount++;\n                if(resolvedCount === functions.length) {\n                    resolve(res);\n                }\n            }).catch((err) => {\n                reject(err);\n            })\n        });\n    });\n};\n"
    ]
  },
  {
    "number": 5,
    "question": "Can you solve this real interview question? Join Two Arrays by ID - Given two arrays arr1 and arr2, return a new array joinedArray. All the objects in each of the two inputs arrays will contain an id field that has an integer value. joinedArray is an array formed by merging arr1 and arr2 based on their id key. The length of joinedArray should be the length of unique values of id. The returned array should be sorted in ascending order based on the id key.\n\nIf a given id exists in one array but not the other, the single object with that id should be included in the result array without modification.\n\nIf two objects share an id, their properties should be merged into a single object:\n\n * If a key only exists in one object, that single key-value pair should be included in the object.\n * If a key is included in both objects, the value in the object from arr2 should override the value from arr1.\n\n \n\nExample 1:\n\n\nInput: \narr1 = [\n    {\"id\": 1, \"x\": 1},\n    {\"id\": 2, \"x\": 9}\n], \narr2 = [\n    {\"id\": 3, \"x\": 5}\n]\nOutput: \n[\n    {\"id\": 1, \"x\": 1},\n    {\"id\": 2, \"x\": 9},\n    {\"id\": 3, \"x\": 5}\n]\nExplanation: There are no duplicate ids so arr1 is simply concatenated with arr2.\n\n\nExample 2:\n\n\nInput: \narr1 = [\n    {\"id\": 1, \"x\": 2, \"y\": 3},\n    {\"id\": 2, \"x\": 3, \"y\": 6}\n], \narr2 = [\n    {\"id\": 2, \"x\": 10, \"y\": 20},\n    {\"id\": 3, \"x\": 0, \"y\": 0}\n]\nOutput: \n[\n    {\"id\": 1, \"x\": 2, \"y\": 3},\n    {\"id\": 2, \"x\": 10, \"y\": 20},\n    {\"id\": 3, \"x\": 0, \"y\": 0}\n]\nExplanation: The two objects with id=1 and id=3 are included in the result array without modifiction. The two objects with id=2 are merged together. The keys from arr2 override the values in arr1.\n\n\nExample 3:\n\n\nInput: \narr1 = [\n    {\"id\": 1, \"b\": {\"b\": 94},\"v\": [4, 3], \"y\": 48}\n]\narr2 = [\n    {\"id\": 1, \"b\": {\"c\": 84}, \"v\": [1, 3]}\n]\nOutput: [\n    {\"id\": 1, \"b\": {\"c\": 84}, \"v\": [1, 3], \"y\": 48}\n]\nExplanation: The two objects with id=1 are merged together. For the keys \"b\" and \"v\" the values from arr2 are used. Since the key \"y\" only exists in arr1, that value is taken form arr1.\n\n \n\nConstraints:\n\n * arr1 and arr2 are valid JSON arrays\n * Each object in arr1 and arr2 has a unique integer id key\n * 2 <= JSON.stringify(arr1).length <= 106\n * 2 <= JSON.stringify(arr2).length <= 106",
    "code": "/**\n * @param {Array} arr1\n * @param {Array} arr2\n * @return {Array}\n */\nvar join = function(arr1, arr2) {\n    \n};",
    "solution": [
      "/**\n * @param {Array} arr1\n * @param {Array} arr2\n * @return {Array}\n */\nvar join = function(arr1, arr2) {\n  const combinedArray = arr1.concat(arr2);\n  const merged = {};\n\n  combinedArray.forEach((obj) => {\n    const id = obj.id;\n    if (!merged[id]) {\n      merged[id] = { ...obj };\n    } else {\n      merged[id] = { ...merged[id], ...obj };\n    }\n  });\n\n  const joinedArray = Object.values(merged);\n  joinedArray.sort((a, b) => a.id - b.id);\n\n  return joinedArray;\n};",
      "/**\n * @param {Array} arr1\n * @param {Array} arr2\n * @return {Array}\n */\nvar join = function(arr1, arr2) {\n    const map = new Map();\n    for(const obj of arr1) map.set(obj.id, obj);\n    for(const obj of arr2) {\n        if(!map.has(obj.id)) map.set(obj.id, obj);\n        else {\n            const prevObj = map.get(obj.id);\n            for(const key of Object.keys(obj)) prevObj[key] = obj[key];\n        }\n    }\n    const res = new Array();\n    for(let key of map.keys()) res.push(map.get(key));\n    return res.sort((a,b)=>a.id-b.id); \n};",
      "/**\n * @param {Array} arr1\n * @param {Array} arr2\n * @return {Array}\n */\nvar join = function(arr1, arr2) {\n    arr1.sort((a,b) => a.id - b.id)\n    arr2.sort((a,b) => a.id - b.id)\n    let i = 0\n    let j = 0\n\n    const joinedArray = []\n\n    while(i < arr1.length && j < arr2.length) {\n\n        if(arr1[i].id === arr2[j].id) {\n            joinedArray.push({...arr1[i], ...arr2[j]})\n            i++\n            j++\n            continue\n        }\n\n        if(arr1[i].id < arr2[j].id) {\n            joinedArray.push({...arr1[i]})\n            i++\n            continue\n        }\n\n        joinedArray.push({...arr2[j]})\n        j++\n    }\n\n    while(i < arr1.length) {\n        joinedArray.push({...arr1[i]})\n        i++\n    }\n\n    while(j < arr2.length) {\n        joinedArray.push({...arr2[j]})\n        j++\n    }\n\n    return joinedArray\n}"
    ]
  },
  {
    "number": 6,
    "question": "Can you solve this real interview question? Sort By - Given an array arr and a function fn, return a sorted array sortedArr. You can assume fn only returns numbers and those numbers determine the sort order of sortedArr. sortedArray must be sorted in ascending order by fn output.\n\nYou may assume that fn will never duplicate numbers for a given array.\n\n \n\nExample 1:\n\n\nInput: arr = [5, 4, 1, 2, 3], fn = (x) => x\nOutput: [1, 2, 3, 4, 5]\nExplanation: fn simply returns the number passed to it so the array is sorted in ascending order.\n\n\nExample 2:\n\n\nInput: arr = [{\"x\": 1}, {\"x\": 0}, {\"x\": -1}], fn = (d) => d.x\nOutput: [{\"x\": -1}, {\"x\": 0}, {\"x\": 1}]\nExplanation: fn returns the value for the \"x\" key. So the array is sorted based on that value.\n\n\nExample 3:\n\n\nInput: arr = [[3, 4], [5, 2], [10, 1]], fn = (x) => x[1]\nOutput: [[10, 1], [5, 2], [3, 4]]\nExplanation: arr is sorted in ascending order by number at index=1. \n\n\n \n\nConstraints:\n\n * arr is a valid JSON array\n * fn is a function that returns a number\n * 1 <= arr.length <= 5 * 105",
    "code": "/**\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\nvar sortBy = function(arr, fn) {\n    \n};",
    "solution": [
      "var sortBy = function(arr, fn) {\n    return arr.sort((a,b) => fn(a) - fn(b))\n};\n",
      "var sortBy = function(arr, fn) {\n    function swap(a, b) {\n        return (fn(a) < fn(b)) ? -1 : 1\n    }\n\n    return arr.sort(swap)\n};"
    ]
  },
  {
    "number": 7,
    "question": "Can you solve this real interview question? Interval Cancellation - Given a function fn, an array of arguments args, and an interval time t, return a cancel function cancelFn.\n\nThe function fn should be called with args immediately and then called again every t milliseconds until cancelFn is called at cancelT ms.\n\n \n\nExample 1:\n\n\nInput: fn = (x) => x * 2, args = [4], t = 35, cancelT = 190\nOutput: \n[\n   {\"time\": 0, \"returned\": 8},\n   {\"time\": 35, \"returned\": 8},\n   {\"time\": 70, \"returned\": 8},\n   {\"time\": 105, \"returned\": 8},\n   {\"time\": 140, \"returned\": 8},\n   {\"time\": 175, \"returned\": 8}\n]\nExplanation: \nconst result = []\nconst fn = (x) => x * 2\nconst args = [4], t = 35, cancelT = 190\n\nconst start = performance.now()\n\nconst log = (...argsArr) => {\n    const diff = Math.floor(performance.now() - start)\n    result.push({\"time\": diff, \"returned\": fn(...argsArr)})\n}\n\nconst cancel = cancellable(log, [4], 35);\nsetTimeout(cancel, 190);\n\nsetTimeout(() => {\n    console.log(result) // Output\n }, cancelT + t + 15)  \n\nEvery 35ms, fn(4) is called. Until t=190ms, then it is cancelled.\n1st fn call is at 0ms. fn(4) returns 8.\n2nd fn call is at 35ms. fn(4) returns 8.\n3rd fn call is at 70ms. fn(4) returns 8.\n4th fn call is at 105ms. fn(4) returns 8.\n5th fn call is at 140ms. fn(4) returns 8.\n6th fn call is at 175ms. fn(4) returns 8.\nCancelled at 190ms\n\n\nExample 2:\n\n\nInput: fn = (x1, x2) => (x1 * x2), args = [2, 5], t = 30, cancelT = 165\nOutput: \n[\n   {\"time\": 0, \"returned\": 10},\n   {\"time\": 30, \"returned\": 10},\n   {\"time\": 60, \"returned\": 10},\n   {\"time\": 90, \"returned\": 10},\n   {\"time\": 120, \"returned\": 10},\n   {\"time\": 150, \"returned\": 10}\n]\nExplanation: Every 30ms, fn(2, 5) is called. Until t=165ms, then it is cancelled.\n1st fn call is at 0ms \n2nd fn call is at 30ms \n3rd fn call is at 60ms \n4th fn call is at 90ms \n5th fn call is at 120ms \n6th fn call is at 150ms\nCancelled at 165ms\n\n\nExample 3:\n\n\nInput: fn = (x1, x2, x3) => (x1 + x2 + x3), args = [5, 1, 3], t = 50, cancelT = 180\nOutput: \n[\n   {\"time\": 0, \"returned\": 9},\n   {\"time\": 50, \"returned\": 9},\n   {\"time\": 100, \"returned\": 9},\n   {\"time\": 150, \"returned\": 9}\n]\nExplanation: Every 50ms, fn(5, 1, 3) is called. Until t=180ms, then it is cancelled. \n1st fn call is at 0ms\n2nd fn call is at 50ms\n3rd fn call is at 100ms\n4th fn call is at 150ms\nCancelled at 180ms\n\n\n \n\nConstraints:\n\n * fn is a function\n * args is a valid JSON array\n * 1 <= args.length <= 10\n * 30 <= t <= 100\n * 10 <= cancelT <= 500",
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    \n};\n\n/**\n *  const result = []\n *\n *  const fn = (x) => x * 2\n *  const args = [4], t = 35, cancelT = 190\n *\n *  const start = performance.now()\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start)\n *      result.push({\"time\": diff, \"returned\": fn(...\nargsArr)})\n *  }\n *       \n *  const cancel = cancellable(log, args, t);",
    "solution": [
      "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    fn(...args);\n    const timer = setInterval(() => fn(...args), t);\n\n    const cancelFn = () => clearInterval(timer);\n    return cancelFn;\n};",
      "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    let isCancelled = false;\n    fn(...args);\n    const startInterval = () => {\n        setTimeout(() => {\n            fn(...args);\n            if (isCancelled) return;\n            startInterval();\n        }, t);\n    }\n    startInterval();\n    const cancelInterval = () => {\n        isCancelled = true;\n    }\n\n    return cancelInterval;\n};",
      "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    let timerId = null;\n    fn(...args);\n\n    const startInterval = () => {\n        timerId = setTimeout(() => {\n            fn(...args);\n            startInterval();\n        }, t);\n    };\n    startInterval();\n\n    const cancelInterval = () => {\n        if (timerId !== null) { // not totally needed as clearTimeout is very forgiving fn\n            clearTimeout(timerId);\n        }\n    };\n\n    return cancelInterval;\n};"
    ]
  },
  {
    "number": 8,
    "question": "Can you solve this real interview question? Calculator with Method Chaining - Design a Calculator class. The class should provide the mathematical operations of addition, subtraction, multiplication, division, and exponentiation. It should also allow consecutive operations to be performed using method chaining. The Calculator class constructor should accept a number which serves as the initial value of result.\n\nYour Calculator class should have the following methods:\n\n * add - This method adds the given number value to the result and returns the updated Calculator.\n * subtract - This method subtracts the given number value from the result and returns the updated Calculator.\n * multiply - This method multiplies the result  by the given number value and returns the updated Calculator.\n * divide - This method divides the result by the given number value and returns the updated Calculator. If the passed value is 0, an error \"Division by zero is not allowed\" should be thrown.\n * power - This method raises the result to the power of the given number value and returns the updated Calculator.\n * getResult - This method returns the result.\n\nSolutions within 10-5 of the actual result are considered correct.\n\n \n\nExample 1:\n\n\nInput: \nactions = [\"Calculator\", \"add\", \"subtract\", \"getResult\"], \nvalues = [10, 5, 7]\nOutput: 8\nExplanation: \nnew Calculator(10).add(5).subtract(7).getResult() // 10 + 5 - 7 = 8\n\n\nExample 2:\n\n\nInput: \nactions = [\"Calculator\", \"multiply\", \"power\", \"getResult\"], \nvalues = [2, 5, 2]\nOutput: 100\nExplanation: \nnew Calculator(2).multiply(5).power(2).getResult() // (2 * 5) ^ 2 = 100\n\n\nExample 3:\n\n\nInput: \nactions = [\"Calculator\", \"divide\", \"getResult\"], \nvalues = [20, 0]\nOutput: \"Division by zero is not allowed\"\nExplanation: \nnew Calculator(20).divide(0).getResult() // 20 / 0 \n\nThe error should be thrown because we cannot divide by zero.\n\n\n \n\nConstraints:\n\n * actions is a valid JSON array of strings\n * values is a valid JSON array of numbers\n * 2 <= actions.length <= 2 * 104\n * 1 <= values.length <= 2 * 104 - 1\n * actions[i] is one of \"Calculator\", \"add\", \"subtract\", \"multiply\", \"divide\", \"power\", and \"getResult\"\n * First action is always \"Calculator\"\n * Last action is always \"getResult\"",
    "code": "class Calculator {\n  \n    /** \n     * @param {number} value\n     */\n    constructor(value) {\n        \n    }\n\n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */\n    add(value){\n        \n    }\n\n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */\n    subtract(value){\n        \n    }\n",
    "solution": [
      "class Calculator {\n  constructor(value) {\n    this.result = value;\n  }\n  add(value){\n    this.result += value;\n    return this;\n  }\n  subtract(value){\n    this.result -= value;\n    return this;\n  }\n  multiply(value) {\n    this.result *= value;\n    return this;\n  }\n  divide(value) {\n    if(value === 0) throw \"Division by zero is not allowed\";\n    this.result /= value;\n    return this;\n  }\n  power(value) {\n    this.result **= value;\n    return this;\n  }\n  getResult() {\n    return this.result;\n  }\n}\n"
    ]
  },
  {
    "number": 9,
    "question": "Can you solve this real interview question? Is Object Empty - Given an object or an array, return if it is empty.\n\n * An empty object contains no key-value pairs.\n * An empty array contains no elements.\n\nYou may assume the object or array is the output of JSON.parse.\n\n \n\nExample 1:\n\n\nInput: obj = {\"x\": 5, \"y\": 42}\nOutput: false\nExplanation: The object has 2 key-value pairs so it is not empty.\n\n\nExample 2:\n\n\nInput: obj = {}\nOutput: true\nExplanation: The object doesn't have any key-value pairs so it is empty.\n\n\nExample 3:\n\n\nInput: obj = [null, false, 0]\nOutput: false\nExplanation: The array has 3 elements so it is not empty.\n\n\n \n\nConstraints:\n\n * obj is a valid JSON object or array\n * 2 <= JSON.stringify(obj).length <= 105\n\n \n\nCan you solve it in O(1) time?",
    "code": "/**\n * @param {Object|Array} obj\n * @return {boolean}\n */\nvar isEmpty = function(obj) {\n    \n};",
    "solution": [
      "var isEmpty = function(obj) {\n    if (JSON.stringify(obj).length <= 2) return true\n    else return false\n};",
      "var isEmpty = function(obj) {\n  return Object.keys(obj).length === 0\n};",
      "var isEmpty = function(obj) {\n    for (const _ in obj) return false;\n    return true;\n};"
    ]
  },
  {
    "number": 10,
    "question": "Can you solve this real interview question? Count Occurrences in Text - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
    "code": "",
    "solution": [
      "import pandas as pd\n\ndef count_occurrences(files: pd.DataFrame) -> pd.DataFrame:\n    bull_count = files[\n        files[\"content\"].str.contains(r\"(\\s+bull\\s+)\", regex=True, case=False)\n    ][\"file_name\"].nunique()\n    bear_count = files[\n        files[\"content\"].str.contains(r\"(\\s+bear\\s+)\", regex=True, case=False)\n    ][\"file_name\"].nunique()\n\n    data = {\"word\": [\"bull\", \"bear\"], \"count\": [bull_count, bear_count]}\n\n    result_df = pd.DataFrame(data)\n\n    return result_df\n",
      "import pandas as pd\n\ndef count_occurrences(files: pd.DataFrame) -> pd.DataFrame:\n    bull_count = files[\"content\"].str.contains(\" bull \", case=False).sum()\n    bear_count = files[\"content\"].str.contains(\" bear \", case=False).sum()\n\n    data = {\"word\": [\"bull\", \"bear\"], \"count\": [bull_count, bear_count]}\n\n    result_df = pd.DataFrame(data)\n\n    return result_df\n"
    ]
  },
  {
    "number": 11,
    "question": "Can you solve this real interview question? Painting the Walls - You are given two 0-indexed integer arrays, cost and time, of size n representing the costs and the time taken to paint n different walls respectively. There are two painters available:\n\n * A paid painter that paints the ith wall in time[i] units of time and takes cost[i] units of money.\n * A free painter that paints any wall in 1 unit of time at a cost of 0. But the free painter can only be used if the paid painter is already occupied.\n\nReturn the minimum amount of money required to paint the n walls.\n\n \n\nExample 1:\n\n\nInput: cost = [1,2,3,2], time = [1,2,3,2]\nOutput: 3\nExplanation: The walls at index 0 and 1 will be painted by the paid painter, and it will take 3 units of time; meanwhile, the free painter will paint the walls at index 2 and 3, free of cost in 2 units of time. Thus, the total cost is 1 + 2 = 3.\n\n\nExample 2:\n\n\nInput: cost = [2,3,4,2], time = [1,1,1,1]\nOutput: 4\nExplanation: The walls at index 0 and 3 will be painted by the paid painter, and it will take 2 units of time; meanwhile, the free painter will paint the walls at index 1 and 2, free of cost in 2 units of time. Thus, the total cost is 2 + 2 = 4.\n\n\n \n\nConstraints:\n\n * 1 <= cost.length <= 500\n * cost.length == time.length\n * 1 <= cost[i] <= 106\n * 1 <= time[i] <= 500",
    "code": "class Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    vector<vector<int>> memo;\n    int n;\n    \n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        n = cost.size();\n        memo = vector(n, vector(n + 1, -1));\n        return dp(0, n, cost, time);\n    }\n    \n    int dp(int i, int remain, vector<int>& cost, vector<int>& time) { \n        if (remain <= 0) {\n            return 0;\n        }\n        \n        if (i == n) {\n            return 1e9;\n        }\n        \n        if (memo[i][remain] != -1) {\n            return memo[i][remain];\n        }\n        \n        \n        int paint = cost[i] + dp(i + 1, remain - 1 - time[i], cost, time);\n        int dontPaint = dp(i + 1, remain, cost, time);\n        memo[i][remain] = min(paint, dontPaint);\n        return memo[i][remain];\n    }\n};\n",
      "class Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<vector<int>> dp(n + 1, vector(n + 1, 0));\n        \n        for (int i = 1; i <= n; i++) {\n            dp[n][i] = 1e9;\n        }\n        \n        for (int i = n - 1; i >= 0; i--) {\n            for (int remain = 1; remain <= n; remain++) {\n                int paint = cost[i] + dp[i + 1][max(0, remain - 1 - time[i])];\n                int dontPaint = dp[i + 1][remain];\n                dp[i][remain] = min(paint, dontPaint);\n            }\n        }\n        \n        return dp[0][n];\n    }\n};",
      "class Solution {\npublic:\n    int paintWalls(vector<int>& cost, vector<int>& time) {\n        int n = cost.size();\n        vector<int> dp = vector(n + 1, 0);\n        vector<int> prevDp = vector(n + 1, (int) 1e9);\n        prevDp[0] = 0;\n        \n        for (int i = n - 1; i >= 0; i--) {\n            dp = vector(n + 1, 0);\n            for (int remain = 1; remain <= n; remain++) {\n                int paint = cost[i] + prevDp[max(0, remain - 1 - time[i])];\n                int dontPaint = prevDp[remain];\n                dp[remain] = min(paint, dontPaint);\n            }\n            \n            prevDp = dp;\n        }\n        \n        return dp[n];\n    }\n};"
    ]
  },
  {
    "number": 12,
    "question": "Can you solve this real interview question? Array Upper Bound - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
    "code": "",
    "solution": [
      "/** \n * @param {number} target\n * @return {number}\n */\nArray.prototype.upperBound = function(target) {\n    let result = -1;\n    this.forEach((val, ind)=> {\n        if(val === target){\n            result = ind;\n        }\n    })\n    return result;\n};",
      "/** \n * @param {number} target\n * @return {number}\n */\nArray.prototype.upperBound = function(target) {\n    let left = 0;\n    let right = this.length - 1;\n    let result = -1; // Target not found\n\n    while (left <= right) {\n        const mid = left + ((right - left) >> 1);\n\n        if (this[mid] === target) {\n            result = mid;\n            left = mid + 1; // Continue searching in the right half for the last occurrence\n        } else if (this[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return result;\n};",
      "/** \n * @param {number} target\n * @return {number}\n */\nArray.prototype.upperBound = function(target) {\n    return this.lastIndexOf(target)\n};"
    ]
  },
  {
    "number": 13,
    "question": "Can you solve this real interview question? Convert Callback Based Function to Promise Based Function - Level up your coding skills and quickly land a job. This is the best place to expand your knowledge and get prepared for your next interview.",
    "code": "",
    "solution": [
      "\nvar promisify = function(fn) {\n  return function(...args) {\n    return new Promise((resolve, reject) => {\n      function callback(result, error) {\n        // If error, reject the Promise \n        if(error) {\n          reject(error);\n        // If no error, resolve the Promise\n        } else {\n          resolve(result);\n        }\n      }\n\n      fn(callback, ...args);\n    });\n  };\n};\n",
      "var promisify = (fn) => async (...args) =>\n  new Promise((resolve, reject) =>\n    fn((data, err) => err ? reject(err) : resolve(data), ...args)\n  );\n"
    ]
  },
  {
    "number": 14,
    "question": "Can you solve this real interview question? Sort Vowels in a String - Given a 0-indexed string s, permute s to get a new string t such that:\n\n * All consonants remain in their original places. More formally, if there is an index i with 0 <= i < s.length such that s[i] is a consonant, then t[i] = s[i].\n * The vowels must be sorted in the nondecreasing order of their ASCII values. More formally, for pairs of indices i, j with 0 <= i < j < s.length such that s[i] and s[j] are vowels, then t[i] must not have a higher ASCII value than t[j].\n\nReturn the resulting string.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in lowercase or uppercase. Consonants comprise all letters that are not vowels.\n\n \n\nExample 1:\n\n\nInput: s = \"lEetcOde\"\nOutput: \"lEOtcede\"\nExplanation: 'E', 'O', and 'e' are the vowels in s; 'l', 't', 'c', and 'd' are all consonants. The vowels are sorted according to their ASCII values, and the consonants remain in the same places.\n\n\nExample 2:\n\n\nInput: s = \"lYmpH\"\nOutput: \"lYmpH\"\nExplanation: There are no vowels in s (all characters in s are consonants), so we return \"lYmpH\".\n\n\n \n\nConstraints:\n\n * 1 <= s.length <= 105\n * s consists only of letters of the English alphabet in uppercase and lowercase.",
    "code": "class Solution {\npublic:\n    string sortVowels(string s) {\n        \n    }\n};",
    "solution": [
      "class Solution {\npublic:\n    // Returns true if the character is a vowel.\n    bool isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'o'|| c == 'u'|| c == 'i' \n            || c == 'A' || c == 'E' || c == 'O'|| c == 'U'|| c == 'I';\n    }\n\n    string sortVowels(string s) {\n        string temp;\n\n        // Store the vowels in the temporary string.\n        for (char c : s) {\n            if (isVowel(c)) {\n                temp += c;\n            }\n        }\n        \n        // Sort the temporary string characters in ascending order.\n        sort(temp.begin(), temp.end());\n\n        int j = 0;\n        string ans;\n        for (int i = 0; i < s.size(); i++) {\n            // If the character is a vowel, replace it with the character in the string temp.\n            if (isVowel(s[i])) {\n                ans += temp[j];\n                j++;\n            } else {\n                ans += s[i];\n            }\n        }\n        \n        return ans;\n    }\n};",
      "class Solution {\npublic:\n    // Returns true if the character is a vowel.\n    bool isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'o'|| c == 'u'|| c == 'i' \n            || c == 'A' || c == 'E' || c == 'O'|| c == 'U'|| c == 'I';\n    }\n    \n    string sortVowels(string s) {\n        unordered_map<char, int> count;\n\n        // Store the frequencies for each character.\n        for (char c : s) {\n            if (isVowel(c)) {\n                count[c]++;\n            }\n        }\n\n        // Sorted string having all the vowels.\n        string sortedVowel = \"AEIOUaeiou\";\n        string ans;\n        int j = 0;\n        for (int i = 0; i < s.size(); i++) {\n            if (!isVowel(s[i])) {\n                ans += s[i];\n            } else {\n                // Skip to the character which is having remaining count.\n                while (count[sortedVowel[j]] == 0) {\n                    j++;\n                }\n\n                ans += sortedVowel[j];\n                count[sortedVowel[j]]--;\n            }\n        }\n        return ans;\n    }\n};"
    ]
  }
]